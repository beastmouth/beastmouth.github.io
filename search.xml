<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Binlog日志格式</title>
    <url>/2021/12/30/Binlog%E6%97%A5%E5%BF%97%E6%A0%BC%E5%BC%8F/</url>
    <content><![CDATA[<p>查看binlog日志格式</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">show variables like &#x27;binlog%&#x27;;</span><br></pre></td></tr></table></figure>
<p>三种格式的区别</p>
<p>statement 记录sql原文 limit情况下可能是unsafe的，存在错误使用索引的情况</p>
<p>row 会替换成Table_map 和 Delete_rows，记录要操作的表和具体操作的记录</p>
<p>mix 折中，mysql判断会不会引起主从不一致，从而选择row或者statement</p>
<p>statement格式的binlog</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://bb3e216f.onedrive-cf-index-ng-e34.pages.dev/api/raw?path=/Public/BlogImg/MySQL/Binlog%E6%97%A5%E5%BF%97%E6%A0%BC%E5%BC%8F%20statement.png"
                      alt="Binlog日志格式 statement.png"
                ></p>
<p>row格式的binlog</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://bb3e216f.onedrive-cf-index-ng-e34.pages.dev/api/raw?path=/Public/BlogImg/MySQL/BInlog%E6%97%A5%E5%BF%97%E6%A0%BC%E5%BC%8F%20row.png"
                      alt="BInlog日志格式 row.png"
                ></p>

<div id="gitalk-container"></div>
<script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

		<script>
		var gitalkConfig = {"clientID":"26b8e6758f16d4524e69","clientSecret":"ecfd9e9a439bcb8a4c4fd21f4677fa102c68b352","repo":"beastmouth.github.io","owner":"beastmouth","admin":["beastmouth"],"distractionFreeMode":false,"createIssueManually":true};
	    gitalkConfig.id = md5(location.pathname);
		var gitalk = new Gitalk(gitalkConfig);
	    gitalk.render("gitalk-container");
	    </script>]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
  </entry>
  <entry>
    <title>Dubbo基础篇服务引用</title>
    <url>/2022/08/02/Dubbo%E5%9F%BA%E7%A1%80%E7%AF%87%E6%9C%8D%E5%8A%A1%E5%BC%95%E7%94%A8/</url>
    <content><![CDATA[<h1 id="完整流程图"><a href="#完整流程图" class="headerlink" title="完整流程图"></a>完整流程图</h1><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://bb3e216f.onedrive-cf-index-ng-e34.pages.dev/api/raw?path=/Public/BlogImg/Dubbo/Dubbo%E5%9F%BA%E7%A1%80%E7%AF%87%20%E6%9C%8D%E5%8A%A1%E5%BC%95%E7%94%A8%E5%AE%8C%E6%95%B4%E6%B5%81%E7%A8%8B.png"
                      alt="Dubbo基础篇 服务引用完整流程.png"
                ></p>
<h1 id="一句话概括流程"><a href="#一句话概括流程" class="headerlink" title="一句话概括流程"></a>一句话概括流程</h1><p>具体可以概括为以下五点</p>
<ul>
<li><p>两种模式（饿汉式/懒汉式）</p>
</li>
<li><p>组装URL并向注册中心注册</p>
</li>
<li><p>获取服务提供者信息并根据协议（默认Dubbo协议）开始Invoker的创建流程</p>
</li>
<li><p>通过Cluster包装Invoker（默认FailoverCluster）</p>
</li>
<li><p>返回代理类</p>
<h1 id="服务引用的两个时机"><a href="#服务引用的两个时机" class="headerlink" title="服务引用的两个时机"></a>服务引用的两个时机</h1></li>
<li><p>饿汉式：通过实现Spring的 IntitalizingBean 接口的 afterProperties 方法，容器通过调用 ReferenceBean 的 afterPropertiesSet 方法时引入服务 (ReferenceBean实现了IntitalizingBean接口)<br>Bean实例化完成后填充属性时引入服务，这里具体的Bean是Invoker的代理对象</p>
</li>
<li><p>懒汉式：只有当这个服务被注入到其他类中时启动引入流程</p>
</li>
</ul>
<p><em>注释：我们创建出来的远程调用的代理对象，实际上是ReferenceBean的一个成员变量（相当于我们在代理对象上套了个壳，把这个壳作为一个bean注册到spring容器中）</em><br>饿汉式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterPropertiesSet</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Initializes Dubbo&#x27;s Config Beans before @Reference bean autowiring</span></span><br><span class="line">    prepareDubboConfigBeans();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// lazy init by default.</span></span><br><span class="line">    <span class="keyword">if</span> (init == <span class="keyword">null</span>) &#123;</span><br><span class="line">        init = <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// eager init if necessary.</span></span><br><span class="line">    <span class="keyword">if</span> (shouldInit()) &#123;</span><br><span class="line">        getObject();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>懒汉式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">getObject</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> get();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> T <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (destroyed) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;The invoker of ReferenceConfig(&quot;</span> + url + <span class="string">&quot;) has already destroyed!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (ref == <span class="keyword">null</span>) &#123;</span><br><span class="line">        init();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ref;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>关于这点的解释。如果 <a class="link"   href="dubbo:reference" >dubbo:reference<i class="fas fa-external-link-alt"></i></a> 的init属性开启（饿汉式），创建完ReferenceBean 的时候，在afterProperties方法里面调用对应的getObject方法，将对应的Invoker的Bean创建出来并注册到容器中。而懒汉式则是在其他的Bean去注入它的时候，才会去进行Invoker的创建流程<br>然后ContextRefreshedEvent事件那一步的处理会将我上面没有去实例化的那些Invoker也实例化一次（个人猜测是那些懒加载没有被其他Bean注入的Bean）<br><strong>为什么要是用FactoryBean接口的方式去创建对应的Bean</strong>。因为FactoryBean本身的作用是为了能够进行复杂的Bean逻辑创建，而不通过Spring本身的三级缓存的方式创建Bean。而且此处的Invoker还涉及到动态代理之类的情况，FactoryBean就很适合这种创建Bean场景<br>同样的，例如SpringCloud的Feign之类的也是通过这样的方式注入Bean</p>
<h1 id="入口关键类-ReferenceConfig"><a href="#入口关键类-ReferenceConfig" class="headerlink" title="入口关键类 ReferenceConfig"></a>入口关键类 ReferenceConfig</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">get</span><span class="params">(ReferenceConfigBase&lt;T&gt; referenceConfig)</span> </span>&#123;</span><br><span class="line">    String key = generator.generateKey(referenceConfig);</span><br><span class="line">    Class&lt;?&gt; type = referenceConfig.getInterfaceClass();</span><br><span class="line"></span><br><span class="line">    proxies.computeIfAbsent(type, _t -&gt; <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;());</span><br><span class="line"></span><br><span class="line">    ConcurrentMap&lt;String, Object&gt; proxiesOfType = proxies.get(type);</span><br><span class="line">    proxiesOfType.computeIfAbsent(key, _k -&gt; &#123;</span><br><span class="line">        <span class="comment">// 触发的地方，最终调用到init</span></span><br><span class="line">        Object proxy = referenceConfig.get();</span><br><span class="line">        referredReferences.put(key, referenceConfig);</span><br><span class="line">        <span class="keyword">return</span> proxy;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (T) proxiesOfType.get(key);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (initialized) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (bootstrap == <span class="keyword">null</span>) &#123;</span><br><span class="line">        bootstrap = DubboBootstrap.getInstance();</span><br><span class="line">        bootstrap.initialize();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    checkAndUpdateSubConfigs();</span><br><span class="line"></span><br><span class="line">    checkStubAndLocal(interfaceClass);</span><br><span class="line">    ConfigValidationUtils.checkMock(interfaceClass, <span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">    Map&lt;String, String&gt; map = <span class="keyword">new</span> HashMap&lt;String, String&gt;();</span><br><span class="line">    map.put(SIDE_KEY, CONSUMER_SIDE);</span><br><span class="line"></span><br><span class="line">    ReferenceConfigBase.appendRuntimeParameters(map);</span><br><span class="line">    <span class="keyword">if</span> (!ProtocolUtils.isGeneric(generic)) &#123;</span><br><span class="line">        String revision = Version.getVersion(interfaceClass, version);</span><br><span class="line">        <span class="keyword">if</span> (revision != <span class="keyword">null</span> &amp;&amp; revision.length() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            map.put(REVISION_KEY, revision);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        String[] methods = Wrapper.getWrapper(interfaceClass).getMethodNames();</span><br><span class="line">        <span class="keyword">if</span> (methods.length == <span class="number">0</span>) &#123;</span><br><span class="line">            logger.warn(<span class="string">&quot;No method found in service interface &quot;</span> + interfaceClass.getName());</span><br><span class="line">            map.put(METHODS_KEY, ANY_VALUE);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            map.put(METHODS_KEY, StringUtils.join(<span class="keyword">new</span> HashSet&lt;String&gt;(Arrays.asList(methods)), COMMA_SEPARATOR));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    map.put(INTERFACE_KEY, interfaceName);</span><br><span class="line">    AbstractConfig.appendParameters(map, getMetrics());</span><br><span class="line">    AbstractConfig.appendParameters(map, getApplication());</span><br><span class="line">    AbstractConfig.appendParameters(map, getModule());</span><br><span class="line">    <span class="comment">// remove &#x27;default.&#x27; prefix for configs from ConsumerConfig</span></span><br><span class="line">    <span class="comment">// appendParameters(map, consumer, Constants.DEFAULT_KEY);</span></span><br><span class="line">    AbstractConfig.appendParameters(map, consumer);</span><br><span class="line">    AbstractConfig.appendParameters(map, <span class="keyword">this</span>);</span><br><span class="line">    MetadataReportConfig metadataReportConfig = getMetadataReportConfig();</span><br><span class="line">    <span class="keyword">if</span> (metadataReportConfig != <span class="keyword">null</span> &amp;&amp; metadataReportConfig.isValid()) &#123;</span><br><span class="line">        map.putIfAbsent(METADATA_KEY, REMOTE_METADATA_STORAGE_TYPE);</span><br><span class="line">    &#125;</span><br><span class="line">    Map&lt;String, AsyncMethodInfo&gt; attributes = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (CollectionUtils.isNotEmpty(getMethods())) &#123;</span><br><span class="line">        attributes = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (MethodConfig methodConfig : getMethods()) &#123;</span><br><span class="line">            AbstractConfig.appendParameters(map, methodConfig, methodConfig.getName());</span><br><span class="line">            String retryKey = methodConfig.getName() + <span class="string">&quot;.retry&quot;</span>;</span><br><span class="line">            <span class="keyword">if</span> (map.containsKey(retryKey)) &#123;</span><br><span class="line">                String retryValue = map.remove(retryKey);</span><br><span class="line">                <span class="keyword">if</span> (<span class="string">&quot;false&quot;</span>.equals(retryValue)) &#123;</span><br><span class="line">                    map.put(methodConfig.getName() + <span class="string">&quot;.retries&quot;</span>, <span class="string">&quot;0&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            AsyncMethodInfo asyncMethodInfo = AbstractConfig.convertMethodConfig2AsyncInfo(methodConfig);</span><br><span class="line">            <span class="keyword">if</span> (asyncMethodInfo != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="comment">//                    consumerModel.getMethodModel(methodConfig.getName()).addAttribute(ASYNC_KEY, asyncMethodInfo);</span></span><br><span class="line">                attributes.put(methodConfig.getName(), asyncMethodInfo);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    String hostToRegistry = ConfigUtils.getSystemProperty(DUBBO_IP_TO_REGISTRY);</span><br><span class="line">    <span class="keyword">if</span> (StringUtils.isEmpty(hostToRegistry)) &#123;</span><br><span class="line">        hostToRegistry = NetUtils.getLocalHost();</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isInvalidLocalHost(hostToRegistry)) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Specified invalid registry ip from property:&quot;</span> + DUBBO_IP_TO_REGISTRY + <span class="string">&quot;, value:&quot;</span> + hostToRegistry);</span><br><span class="line">    &#125;</span><br><span class="line">    map.put(REGISTER_IP_KEY, hostToRegistry);</span><br><span class="line"></span><br><span class="line">    serviceMetadata.getAttachments().putAll(map);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建代理 即生成invoker（代理中包括invoker）</span></span><br><span class="line">    ref = createProxy(map);</span><br><span class="line"></span><br><span class="line">    serviceMetadata.setTarget(ref);</span><br><span class="line">    serviceMetadata.addAttribute(PROXY_CLASS_REF, ref);</span><br><span class="line">    ConsumerModel consumerModel = repository.lookupReferredService(serviceMetadata.getServiceKey());</span><br><span class="line">    consumerModel.setProxyObject(ref);</span><br><span class="line">    consumerModel.init(attributes);</span><br><span class="line"></span><br><span class="line">    initialized = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">    checkInvokerAvailable();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// dispatch a ReferenceConfigInitializedEvent since 2.7.4</span></span><br><span class="line">    dispatch(<span class="keyword">new</span> ReferenceConfigInitializedEvent(<span class="keyword">this</span>, invoker));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="创建代理类"><a href="#创建代理类" class="headerlink" title="创建代理类"></a>创建代理类</h2><p>主要分为以下几点</p>
<ul>
<li>injvm：走jvm内部调用（自己服务中的dubbo接口调用）</li>
<li>配置了URL：点对点</li>
<li>未配置URL，从注册中心获取服务提供者信息<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> T <span class="title">createProxy</span><span class="params">(Map&lt;String, String&gt; map)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (shouldJvmRefer(map)) &#123;</span><br><span class="line">        <span class="comment">// 本地调用的情况</span></span><br><span class="line">        URL url = <span class="keyword">new</span> URL(LOCAL_PROTOCOL, LOCALHOST_VALUE, <span class="number">0</span>, interfaceClass.getName()).addParameters(map);</span><br><span class="line">        invoker = REF_PROTOCOL.refer(interfaceClass, url);</span><br><span class="line">        <span class="keyword">if</span> (logger.isInfoEnabled()) &#123;</span><br><span class="line">            logger.info(<span class="string">&quot;Using injvm service &quot;</span> + interfaceClass.getName());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        urls.clear();</span><br><span class="line">        <span class="comment">// 配置的url的情况 点对点/注册中心地址</span></span><br><span class="line">        <span class="keyword">if</span> (url != <span class="keyword">null</span> &amp;&amp; url.length() &gt; <span class="number">0</span>) &#123; <span class="comment">// user specified URL, could be peer-to-peer address, or register center&#x27;s address.</span></span><br><span class="line">            String[] us = SEMICOLON_SPLIT_PATTERN.split(url);</span><br><span class="line">            <span class="keyword">if</span> (us != <span class="keyword">null</span> &amp;&amp; us.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">for</span> (String u : us) &#123;</span><br><span class="line">                    URL url = URL.valueOf(u);</span><br><span class="line">                    <span class="keyword">if</span> (StringUtils.isEmpty(url.getPath())) &#123;</span><br><span class="line">                        url = url.setPath(interfaceName);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (UrlUtils.isRegistry(url)) &#123;</span><br><span class="line">                        <span class="comment">// 如果是注册中心，将map转换为查询字符串，并作为refer参数的值添加到url中</span></span><br><span class="line">                        urls.add(url.addParameterAndEncoded(REFER_KEY, StringUtils.toQueryString(map)));</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="comment">// 点对点直连，合并url，移除一些服务提供者的配置</span></span><br><span class="line">                        urls.add(ClusterUtils.mergeUrl(url, map));</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">// assemble URL from register center&#x27;s configuration</span></span><br><span class="line">            <span class="comment">// 未配置url的情况</span></span><br><span class="line">            <span class="comment">// if protocols not injvm checkRegistry</span></span><br><span class="line">            <span class="keyword">if</span> (!LOCAL_PROTOCOL.equalsIgnoreCase(getProtocol())) &#123;</span><br><span class="line">                checkRegistry();</span><br><span class="line">                <span class="comment">// 获取注册中心地址</span></span><br><span class="line">                List&lt;URL&gt; us = ConfigValidationUtils.loadRegistries(<span class="keyword">this</span>, <span class="keyword">false</span>);</span><br><span class="line">                <span class="keyword">if</span> (CollectionUtils.isNotEmpty(us)) &#123;</span><br><span class="line">                    <span class="keyword">for</span> (URL u : us) &#123;</span><br><span class="line">                        URL monitorUrl = ConfigValidationUtils.loadMonitor(<span class="keyword">this</span>, u);</span><br><span class="line">                        <span class="keyword">if</span> (monitorUrl != <span class="keyword">null</span>) &#123;</span><br><span class="line">                            map.put(MONITOR_KEY, URL.encode(monitorUrl.toFullString()));</span><br><span class="line">                        &#125;</span><br><span class="line">                        urls.add(u.addParameterAndEncoded(REFER_KEY, StringUtils.toQueryString(map))); <span class="comment">// registry://127.0.0.1:2181/org.apache.dubbo.registry.RegistryService?application=dubbo-demo-api-consumer&amp;dubbo=2.0.2&amp;pid=52327&amp;refer=application=dubbo-demo-api-consumer&amp;dubbo=2.0.2&amp;generic=true&amp;interface=org.apache.dubbo.demo.DemoService&amp;pid=52327&amp;register.ip=10.167.10.19&amp;side=consumer&amp;sticky=false&amp;timestamp=1631087606024&amp;registry=zookeeper&amp;timestamp=1631087917015</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (urls.isEmpty()) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;No such any registry to reference &quot;</span> + interfaceName + <span class="string">&quot; on the consumer &quot;</span> + NetUtils.getLocalHost() + <span class="string">&quot; use dubbo version &quot;</span> + Version.getVersion() + <span class="string">&quot;, please config &lt;dubbo:registry address=\&quot;...\&quot; /&gt; to your spring config.&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="keyword">if</span> (urls.size() == <span class="number">1</span>) &#123;</span><br><span class="line">            invoker = REF_PROTOCOL.refer(interfaceClass, urls.get(<span class="number">0</span>));</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            List&lt;Invoker&lt;?&gt;&gt; invokers = <span class="keyword">new</span> ArrayList&lt;Invoker&lt;?&gt;&gt;();</span><br><span class="line">            URL registryURL = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">for</span> (URL url : urls) &#123;</span><br><span class="line">                invokers.add(REF_PROTOCOL.refer(interfaceClass, url));</span><br><span class="line">                <span class="keyword">if</span> (UrlUtils.isRegistry(url)) &#123;</span><br><span class="line">                    registryURL = url; <span class="comment">// use last registry url</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (registryURL != <span class="keyword">null</span>) &#123; <span class="comment">// registry url is available</span></span><br><span class="line">                <span class="comment">// for multi-subscription scenario, use &#x27;zone-aware&#x27; policy by default</span></span><br><span class="line">                String cluster = registryURL.getParameter(CLUSTER_KEY, ZoneAwareCluster.NAME);</span><br><span class="line">                <span class="comment">// The invoker wrap sequence would be: ZoneAwareClusterInvoker(StaticDirectory) -&gt; FailoverClusterInvoker(RegistryDirectory, routing happens here) -&gt; Invoker</span></span><br><span class="line">                invoker = Cluster.getCluster(cluster, <span class="keyword">false</span>).join(<span class="keyword">new</span> StaticDirectory(registryURL, invokers));</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123; <span class="comment">// not a registry url, must be direct invoke.</span></span><br><span class="line">                String cluster = CollectionUtils.isNotEmpty(invokers)</span><br><span class="line">                        ? (invokers.get(<span class="number">0</span>).getUrl() != <span class="keyword">null</span> ? invokers.get(<span class="number">0</span>).getUrl().getParameter(CLUSTER_KEY, ZoneAwareCluster.NAME) : Cluster.DEFAULT)</span><br><span class="line">                        : Cluster.DEFAULT;</span><br><span class="line">                invoker = Cluster.getCluster(cluster).join(<span class="keyword">new</span> StaticDirectory(invokers));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (logger.isInfoEnabled()) &#123;</span><br><span class="line">        logger.info(<span class="string">&quot;Refer dubbo service &quot;</span> + interfaceClass.getName() + <span class="string">&quot; from url &quot;</span> + invoker.getUrl());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    URL consumerURL = <span class="keyword">new</span> URL(CONSUMER_PROTOCOL, map.remove(REGISTER_IP_KEY), <span class="number">0</span>, map.get(INTERFACE_KEY), map);</span><br><span class="line">    MetadataUtils.publishServiceDefinition(consumerURL);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// create service proxy 创建代理服务</span></span><br><span class="line">    <span class="keyword">return</span> (T) PROXY_FACTORY.getProxy(invoker, ProtocolUtils.isGeneric(generic));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
此处细讲一下通过注册中心创建Invoker的方式（多个服务提供者的情况）<br>遍历注册中心，将注册中心所有的服务提供者信息（DynamicDirectory）汇集起来，创建出一个ClusterInvoker，并将ClusterInvoker的代理对象T返回给调用点<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;Invoker&lt;?&gt;&gt; invokers = <span class="keyword">new</span> ArrayList&lt;Invoker&lt;?&gt;&gt;();</span><br><span class="line">URL registryURL = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">for</span> (URL url : urls) &#123;</span><br><span class="line">		<span class="comment">// 引用服务</span></span><br><span class="line">    invokers.add(REF_PROTOCOL.refer(interfaceClass, url));</span><br><span class="line">    <span class="keyword">if</span> (UrlUtils.isRegistry(url)) &#123;</span><br><span class="line">        registryURL = url; <span class="comment">// use last registry url</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (registryURL != <span class="keyword">null</span>) &#123; <span class="comment">// registry url is available</span></span><br><span class="line">    <span class="comment">// for multi-subscription scenario, use &#x27;zone-aware&#x27; policy by default</span></span><br><span class="line">    String cluster = registryURL.getParameter(CLUSTER_KEY, ZoneAwareCluster.NAME);</span><br><span class="line">    <span class="comment">// The invoker wrap sequence would be: ZoneAwareClusterInvoker(StaticDirectory) -&gt; FailoverClusterInvoker(RegistryDirectory, routing happens here) -&gt; Invoker</span></span><br><span class="line">    invoker = Cluster.getCluster(cluster, <span class="keyword">false</span>).join(<span class="keyword">new</span> StaticDirectory(registryURL, invokers));</span><br><span class="line">&#125; <span class="keyword">else</span> &#123; <span class="comment">// not a registry url, must be direct invoke.</span></span><br><span class="line">    String cluster = CollectionUtils.isNotEmpty(invokers)</span><br><span class="line">            ? (invokers.get(<span class="number">0</span>).getUrl() != <span class="keyword">null</span> ? invokers.get(<span class="number">0</span>).getUrl().getParameter(CLUSTER_KEY, ZoneAwareCluster.NAME) : Cluster.DEFAULT)</span><br><span class="line">            : Cluster.DEFAULT;</span><br><span class="line">    invoker = Cluster.getCluster(cluster).join(<span class="keyword">new</span> StaticDirectory(invokers));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2>具体协议的引用方法，以RegisterProtocol#refer为例<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">Invoker&lt;T&gt; <span class="title">refer</span><span class="params">(Class&lt;T&gt; type, URL url)</span> <span class="keyword">throws</span> RpcException </span>&#123;</span><br><span class="line">    url = getRegistryUrl(url);</span><br><span class="line">		<span class="comment">// 获取注册中心</span></span><br><span class="line">    Registry registry = registryFactory.getRegistry(url);</span><br><span class="line">    <span class="keyword">if</span> (RegistryService.class.equals(type)) &#123;</span><br><span class="line">        <span class="keyword">return</span> proxyFactory.getInvoker((T) registry, type, url);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// group=&quot;a,b&quot; or group=&quot;*&quot;</span></span><br><span class="line">    Map&lt;String, String&gt; qs = StringUtils.parseQueryString(url.getParameterAndDecoded(REFER_KEY));</span><br><span class="line">    String group = qs.get(GROUP_KEY);</span><br><span class="line">    <span class="keyword">if</span> (group != <span class="keyword">null</span> &amp;&amp; group.length() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((COMMA_SPLIT_PATTERN.split(group)).length &gt; <span class="number">1</span> || <span class="string">&quot;*&quot;</span>.equals(group)) &#123;</span><br><span class="line">            <span class="keyword">return</span> doRefer(Cluster.getCluster(MergeableCluster.NAME), registry, type, url);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Cluster cluster = Cluster.getCluster(qs.get(CLUSTER_KEY));</span><br><span class="line">		<span class="comment">// 引用具体的服务</span></span><br><span class="line">    <span class="keyword">return</span> doRefer(cluster, registry, type, url);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> &lt;T&gt; <span class="function">Invoker&lt;T&gt; <span class="title">doRefer</span><span class="params">(Cluster cluster, Registry registry, Class&lt;T&gt; type, URL url)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> interceptInvoker(getInvoker(cluster, registry, type, url), url);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> &lt;T&gt; <span class="function">ClusterInvoker&lt;T&gt; <span class="title">getInvoker</span><span class="params">(Cluster cluster, Registry registry, Class&lt;T&gt; type, URL url)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 封装成一个directory （invoker的集合）</span></span><br><span class="line">    DynamicDirectory&lt;T&gt; directory = createDirectory(type, url);</span><br><span class="line">    directory.setRegistry(registry);</span><br><span class="line">    directory.setProtocol(protocol);</span><br><span class="line">    <span class="comment">// all attributes of REFER_KEY</span></span><br><span class="line">    Map&lt;String, String&gt; parameters = <span class="keyword">new</span> HashMap&lt;String, String&gt;(directory.getConsumerUrl().getParameters());</span><br><span class="line">    URL urlToRegistry = <span class="keyword">new</span> URL(CONSUMER_PROTOCOL, parameters.remove(REGISTER_IP_KEY), <span class="number">0</span>, type.getName(), parameters);</span><br><span class="line">    <span class="keyword">if</span> (directory.isShouldRegister()) &#123;</span><br><span class="line">        directory.setRegisteredConsumerUrl(urlToRegistry);</span><br><span class="line">        registry.register(directory.getRegisteredConsumerUrl());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 建立路由规则链</span></span><br><span class="line">    directory.buildRouterChain(urlToRegistry);</span><br><span class="line">    <span class="comment">// 订阅provider</span></span><br><span class="line">    directory.subscribe(toSubscribeUrl(urlToRegistry));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 包装集群容错策略到invoker</span></span><br><span class="line">    <span class="keyword">return</span> (ClusterInvoker&lt;T&gt;) cluster.join(directory);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="代理类"><a href="#代理类" class="headerlink" title="代理类"></a>代理类</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">return</span> (T) PROXY_FACTORY.getProxy(invoker, ProtocolUtils.isGeneric(generic));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 以Javassist动态代理为例</span></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">getProxy</span><span class="params">(Invoker&lt;T&gt; invoker, Class&lt;?&gt;[] interfaces)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (T) Proxy.getProxy(interfaces).newInstance(<span class="keyword">new</span> InvokerInvocationHandler(invoker));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
此处创建的代理类，会有一个成员变量，InvocationHandler<br>当进行Dubbo远程调用的时候，就会被对应的InvokerInvocationHandler进行方法拦截处理，把看似本地调用的方法变为远程调用</li>
</ul>

<div id="gitalk-container"></div>
<script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

		<script>
		var gitalkConfig = {"clientID":"26b8e6758f16d4524e69","clientSecret":"ecfd9e9a439bcb8a4c4fd21f4677fa102c68b352","repo":"beastmouth.github.io","owner":"beastmouth","admin":["beastmouth"],"distractionFreeMode":false,"createIssueManually":true};
	    gitalkConfig.id = md5(location.pathname);
		var gitalk = new Gitalk(gitalkConfig);
	    gitalk.render("gitalk-container");
	    </script>]]></content>
      <categories>
        <category>Dubbo</category>
      </categories>
  </entry>
  <entry>
    <title>Dubbo基础篇服务暴露</title>
    <url>/2022/08/02/Dubbo%E5%9F%BA%E7%A1%80%E7%AF%87%E6%9C%8D%E5%8A%A1%E6%9A%B4%E9%9C%B2/</url>
    <content><![CDATA[<h1 id="完整流程图"><a href="#完整流程图" class="headerlink" title="完整流程图"></a>完整流程图</h1><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://bb3e216f.onedrive-cf-index-ng-e34.pages.dev/api/raw?path=/Public/BlogImg/Dubbo/Dubbo%E5%9F%BA%E7%A1%80%E7%AF%87%20%E6%9C%8D%E5%8A%A1%E6%9A%B4%E9%9C%B2%E6%B5%81%E7%A8%8B%E5%9B%BE.png"
                      alt="Dubbo基础篇 服务暴露流程图.png"
                ></p>
<h1 id="一句话概括流程"><a href="#一句话概括流程" class="headerlink" title="一句话概括流程"></a>一句话概括流程</h1><p>在SpringIOC容器刷新完毕后 (export方法 ContenxtRefreshEvent)，根据配置参数组装成URL，通过 <strong>proxyFactory.getInvoker</strong> ，利用javassist进行对象代理，封装真正的实现类，然后通过URL参数选择对应的协议进行protocol.export（默认dubbo协议）。在Producer第一次暴露的时候会调用 createServer 来创建 Server（默认NettyServer），然后将 export 得到的 exporter 存入Map（后面处理请求时查找），然后向注册中心注册提供者的信息</p>
<p>具体可以概括为四点</p>
<ul>
<li><p>组装URL</p>
</li>
<li><p>创建Invoker代理类，封装真正的实现类</p>
</li>
<li><p>打开NettyServer，通过URL选择对应的协议暴露（产生Exporter对象）</p>
<ul>
<li>Exporter对象中会去构建一个调用过滤链（org.apache.dubbo.rpc.protocol.ProtocolFilterWrapper#buildInvokerChain）<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://bb3e216f.onedrive-cf-index-ng-e34.pages.dev/api/raw?path=/Public/BlogImg/Dubbo/Dubbo%E5%9F%BA%E7%A1%80%E7%AF%87%20%E8%B0%83%E7%94%A8%E8%BF%87%E6%BB%A4%E9%93%BE.png"
                      alt="Dubbo基础篇 调用过滤链.png"
                ></li>
</ul>
</li>
<li><p>向注册中心注册提供者信息</p>
<h1 id="入口关键类-ServiceConfig"><a href="#入口关键类-ServiceConfig" class="headerlink" title="入口关键类 ServiceConfig"></a>入口关键类 ServiceConfig</h1><h2 id="入口方法"><a href="#入口方法" class="headerlink" title="入口方法"></a>入口方法</h2><p>服务暴露的入口方法<br>主要做的事情是：扫描ServiceConfig，逐个去进行服务的暴露</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">exportServices</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 遍历service</span></span><br><span class="line">    configManager.getServices().forEach(sc -&gt; &#123;</span><br><span class="line">        <span class="comment">// TODO, compatible with ServiceConfig.export()</span></span><br><span class="line">        ServiceConfig serviceConfig = (ServiceConfig) sc;</span><br><span class="line">        serviceConfig.setBootstrap(<span class="keyword">this</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (exportAsync) &#123;</span><br><span class="line">            ExecutorService executor = executorRepository.getServiceExporterExecutor();</span><br><span class="line">            Future&lt;?&gt; future = executor.submit(() -&gt; &#123;</span><br><span class="line">                sc.export();</span><br><span class="line">                exportedServices.add(sc);</span><br><span class="line">            &#125;);</span><br><span class="line">            asyncExportingFutures.add(future);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            sc.export();</span><br><span class="line">            exportedServices.add(sc);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doExportUrls</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  ServiceRepository repository = ApplicationModel.getServiceRepository();</span><br><span class="line">  ServiceDescriptor serviceDescriptor = repository.registerService(getInterfaceClass());</span><br><span class="line">  <span class="comment">// 往内存中添加provider</span></span><br><span class="line">  repository.registerProvider(</span><br><span class="line">    getUniqueServiceName(),</span><br><span class="line">    ref,</span><br><span class="line">    serviceDescriptor,</span><br><span class="line">    <span class="keyword">this</span>,</span><br><span class="line">    serviceMetadata</span><br><span class="line">  );</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 获取当前服务的注册中心URL（支持多注册中心）</span></span><br><span class="line">  List&lt;URL&gt; registryURLs = ConfigValidationUtils.loadRegistries(<span class="keyword">this</span>, <span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 遍历协议，并在每个协议下暴露服务</span></span><br><span class="line">  <span class="keyword">for</span> (ProtocolConfig protocolConfig : protocols) &#123;</span><br><span class="line">    String pathKey = URL.buildKey(getContextPath(protocolConfig)</span><br><span class="line">                                  .map(p -&gt; p + <span class="string">&quot;/&quot;</span> + path)</span><br><span class="line">                                  .orElse(path), group, version);</span><br><span class="line">    <span class="comment">// In case user specified path, register service one more time to map it to path.</span></span><br><span class="line">    <span class="comment">// 注册dubbo service(放入到map中)</span></span><br><span class="line">    repository.registerService(pathKey, interfaceClass);</span><br><span class="line">    <span class="comment">// TODO, uncomment this line once service key is unified</span></span><br><span class="line">    serviceMetadata.setServiceKey(pathKey);</span><br><span class="line">    <span class="comment">// 暴露(将上面存入的dubbo service,生成invoker,再包装成export暴露)</span></span><br><span class="line">    doExportUrlsFor1Protocol(protocolConfig, registryURLs);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>前面有一大段都是在进行URL的组装的，这边就不细讲了，具体的可以看下代码的注释</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doExportUrlsFor1Protocol</span><span class="params">(ProtocolConfig protocolConfig, List&lt;URL&gt; registryURLs)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// ============================== URL组装前的准备 ==============================</span></span><br><span class="line">        String name = protocolConfig.getName();</span><br><span class="line">        <span class="keyword">if</span> (StringUtils.isEmpty(name)) &#123;</span><br><span class="line">            name = DUBBO;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Map&lt;String, String&gt; map = <span class="keyword">new</span> HashMap&lt;String, String&gt;();</span><br><span class="line">        map.put(SIDE_KEY, PROVIDER_SIDE);</span><br><span class="line"></span><br><span class="line">        ServiceConfig.appendRuntimeParameters(map);</span><br><span class="line">        AbstractConfig.appendParameters(map, getMetrics());</span><br><span class="line">        AbstractConfig.appendParameters(map, getApplication());</span><br><span class="line">        AbstractConfig.appendParameters(map, getModule());</span><br><span class="line">        <span class="comment">// ... 此处省略URL组装前的准备流程</span></span><br><span class="line">        <span class="comment">// ============================== URL组装完成 ==============================</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 构建URL</span></span><br><span class="line">        URL url = <span class="keyword">new</span> URL(name, host, port, getContextPath(protocolConfig).map(p -&gt; p + <span class="string">&quot;/&quot;</span> + path).orElse(path), map);</span><br><span class="line">        <span class="comment">// url的内容</span></span><br><span class="line">        <span class="comment">// dubbo://10.167.10.19:20880/org.apache.dubbo.demo.DemoService?anyhost=true&amp;application=dubbo-demo-api-provider&amp;bind.ip=10.167.10.19&amp;bind.port=20880&amp;default=true&amp;deprecated=false&amp;dubbo=2.0.2&amp;dynamic=true&amp;generic=false&amp;interface=org.apache.dubbo.demo.DemoService&amp;methods=sayHello,sayHelloAsync&amp;pid=43793&amp;release=&amp;side=provider&amp;timestamp=1631080120436</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// You can customize Configurator to append extra parameters</span></span><br><span class="line">        <span class="keyword">if</span> (ExtensionLoader.getExtensionLoader(ConfiguratorFactory.class)</span><br><span class="line">                .hasExtension(url.getProtocol())) &#123;</span><br><span class="line">            url = ExtensionLoader.getExtensionLoader(ConfiguratorFactory.class)</span><br><span class="line">                    .getExtension(url.getProtocol()).getConfigurator(url).configure(url);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        String scope = url.getParameter(SCOPE_KEY);</span><br><span class="line">        <span class="comment">// don&#x27;t export when none is configured</span></span><br><span class="line">        <span class="comment">// 如果scope为SCOPE_NONE不暴露服务</span></span><br><span class="line">        <span class="keyword">if</span> (!SCOPE_NONE.equalsIgnoreCase(scope)) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// export to local if the config is not remote (export to remote only when config is remote)</span></span><br><span class="line">            <span class="comment">// 本地暴露</span></span><br><span class="line">            <span class="keyword">if</span> (!SCOPE_REMOTE.equalsIgnoreCase(scope)) &#123;</span><br><span class="line">                <span class="comment">// 有一个本地暴露，只所以需要本地暴露是考虑到同一个服务内假如需要调用当前的dubbo接口，则可以直接走jvm内部(injvm),减少网络间的通讯</span></span><br><span class="line">                <span class="comment">// 修改url协议为injvm</span></span><br><span class="line">                exportLocal(url);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// export to remote if the config is not local (export to local only when config is local)</span></span><br><span class="line">            <span class="comment">// 远程暴露</span></span><br><span class="line">            <span class="keyword">if</span> (!SCOPE_LOCAL.equalsIgnoreCase(scope)) &#123;</span><br><span class="line">                <span class="comment">// 注册中心不为空</span></span><br><span class="line">                <span class="keyword">if</span> (CollectionUtils.isNotEmpty(registryURLs)) &#123;</span><br><span class="line">                    <span class="comment">// 遍历注册中心</span></span><br><span class="line">                    <span class="keyword">for</span> (URL registryURL : registryURLs) &#123;</span><br><span class="line">                        <span class="comment">//if protocol is only injvm ,not register</span></span><br><span class="line">                        <span class="keyword">if</span> (LOCAL_PROTOCOL.equalsIgnoreCase(url.getProtocol())) &#123;</span><br><span class="line">                            <span class="keyword">continue</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        url = url.addParameterIfAbsent(DYNAMIC_KEY, registryURL.getParameter(DYNAMIC_KEY));</span><br><span class="line">                        URL monitorUrl = ConfigValidationUtils.loadMonitor(<span class="keyword">this</span>, registryURL);</span><br><span class="line">                        <span class="keyword">if</span> (monitorUrl != <span class="keyword">null</span>) &#123;</span><br><span class="line">                            url = url.addParameterAndEncoded(MONITOR_KEY, monitorUrl.toFullString());</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">if</span> (logger.isInfoEnabled()) &#123;</span><br><span class="line">                            <span class="keyword">if</span> (url.getParameter(REGISTER_KEY, <span class="keyword">true</span>)) &#123;</span><br><span class="line">                                logger.info(<span class="string">&quot;Register dubbo service &quot;</span> + interfaceClass.getName() + <span class="string">&quot; url &quot;</span> + url + <span class="string">&quot; to registry &quot;</span> + registryURL);</span><br><span class="line">                            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                                logger.info(<span class="string">&quot;Export dubbo service &quot;</span> + interfaceClass.getName() + <span class="string">&quot; to url &quot;</span> + url);</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        <span class="comment">// For providers, this is used to enable custom proxy to generate invoker</span></span><br><span class="line">                        String proxy = url.getParameter(PROXY_KEY);</span><br><span class="line">                        <span class="keyword">if</span> (StringUtils.isNotEmpty(proxy)) &#123;</span><br><span class="line">                            registryURL = registryURL.addParameter(PROXY_KEY, proxy);</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        <span class="comment">// 生成Invoker对象(动态代理创建 javassist)</span></span><br><span class="line">                        Invoker&lt;?&gt; invoker = PROXY_FACTORY.getInvoker(ref, (Class) interfaceClass, registryURL.addParameterAndEncoded(EXPORT_KEY, url.toFullString()));</span><br><span class="line">                        <span class="comment">// 包装</span></span><br><span class="line">                        DelegateProviderMetaDataInvoker wrapperInvoker = <span class="keyword">new</span> DelegateProviderMetaDataInvoker(invoker, <span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">                        <span class="comment">// provider 需要将 invoker 封装成 expoter(并在此处进行注册)</span></span><br><span class="line">                        Exporter&lt;?&gt; exporter = PROTOCOL.export(wrapperInvoker);</span><br><span class="line">                        exporters.add(exporter);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// 直连方式</span></span><br><span class="line">                    <span class="keyword">if</span> (logger.isInfoEnabled()) &#123;</span><br><span class="line">                        logger.info(<span class="string">&quot;Export dubbo service &quot;</span> + interfaceClass.getName() + <span class="string">&quot; to url &quot;</span> + url);</span><br><span class="line">                    &#125;</span><br><span class="line">                    Invoker&lt;?&gt; invoker = PROXY_FACTORY.getInvoker(ref, (Class) interfaceClass, url);</span><br><span class="line">                    DelegateProviderMetaDataInvoker wrapperInvoker = <span class="keyword">new</span> DelegateProviderMetaDataInvoker(invoker, <span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">                    Exporter&lt;?&gt; exporter = PROTOCOL.export(wrapperInvoker);</span><br><span class="line">                    exporters.add(exporter);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 元数据存储</span></span><br><span class="line">                MetadataUtils.publishServiceDefinition(url);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.urls.add(url);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>默认情况下 ，我们的scope为null，他会进行本地暴露+远程暴露<br>那么从上面的代码我们可以看出，主要是做了两件事情：</p>
</li>
<li><p>URL的组装</p>
</li>
<li><p>本地暴露+远程暴露</p>
<h2 id="为什么需要本地暴露呢？"><a href="#为什么需要本地暴露呢？" class="headerlink" title="为什么需要本地暴露呢？"></a>为什么需要本地暴露呢？</h2><p>因为有可能会存在自己的服务调用自己暴露的接口的情况，假如这种情况还走远程调用的话，效率肯定没有jvm内部的本地调用高</p>
<h2 id="生成Invoker对象"><a href="#生成Invoker对象" class="headerlink" title="生成Invoker对象"></a>生成Invoker对象</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Invoker&lt;?&gt; invoker = PROXY_FACTORY.getInvoker(ref, (Class) interfaceClass, registryURL.addParameterAndEncoded(EXPORT_KEY, url.toFullString()));</span><br></pre></td></tr></table></figure>
<h3 id="以Javassist为例（默认为Javassist）"><a href="#以Javassist为例（默认为Javassist）" class="headerlink" title="以Javassist为例（默认为Javassist）"></a>以Javassist为例（默认为Javassist）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">Invoker&lt;T&gt; <span class="title">getInvoker</span><span class="params">(T proxy, Class&lt;T&gt; type, URL url)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// TODO Wrapper cannot handle this scenario correctly: the classname contains &#x27;$&#x27;</span></span><br><span class="line">    <span class="comment">// 通过Javaassist封装成Wrapper类（Dubbo服务启动时生成，所以在运行时不会产生开销），减少反射的调用</span></span><br><span class="line">		<span class="comment">// Wrapper.getWrapper -&gt; 反射获取对应的类信息，包装成Wrapper对象</span></span><br><span class="line">    <span class="keyword">final</span> Wrapper wrapper = Wrapper.getWrapper(proxy.getClass().getName().indexOf(<span class="string">&#x27;$&#x27;</span>) &lt; <span class="number">0</span> ? proxy.getClass() : type);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> AbstractProxyInvoker&lt;T&gt;(proxy, type, url) &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="comment">// Wrapper最终调用最终调用服务提供者的接口实现类的方法</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> Object <span class="title">doInvoke</span><span class="params">(T proxy, String methodName,</span></span></span><br><span class="line"><span class="params"><span class="function">                                  Class&lt;?&gt;[] parameterTypes,</span></span></span><br><span class="line"><span class="params"><span class="function">                                  Object[] arguments)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> wrapper.invokeMethod(proxy, methodName, parameterTypes, arguments);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="为什么需要Wrapper类修饰"><a href="#为什么需要Wrapper类修饰" class="headerlink" title="为什么需要Wrapper类修饰"></a>为什么需要Wrapper类修饰</h3><p>目的：减少反射调用的开销<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://bb3e216f.onedrive-cf-index-ng-e34.pages.dev/api/raw?path=/Public/BlogImg/Dubbo/Dubbo%E5%9F%BA%E7%A1%80%E7%AF%87%20%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81Wrapper%E7%B1%BB%E4%BF%AE%E9%A5%B01.png"
                      alt="Dubbo基础篇 为什么需要Wrapper类修饰1.png"
                ><br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://bb3e216f.onedrive-cf-index-ng-e34.pages.dev/api/raw?path=/Public/BlogImg/Dubbo/Dubbo%E5%9F%BA%E7%A1%80%E7%AF%87%20%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81Wrapper%E7%B1%BB%E4%BF%AE%E9%A5%B02.png"
                      alt="Dubbo基础篇 为什么需要Wrapper类修饰2.png"
                ></p>
<h2 id="暴露操作"><a href="#暴露操作" class="headerlink" title="暴露操作"></a>暴露操作</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Exporter&lt;?&gt; exporter = PROTOCOL.export(wrapperInvoker)</span><br></pre></td></tr></table></figure>
<h3 id="关于此处重点看两个类"><a href="#关于此处重点看两个类" class="headerlink" title="关于此处重点看两个类"></a>关于此处重点看两个类</h3><h4 id="RegisterProtocol"><a href="#RegisterProtocol" class="headerlink" title="RegisterProtocol"></a>RegisterProtocol</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">Exporter&lt;T&gt; <span class="title">export</span><span class="params">(<span class="keyword">final</span> Invoker&lt;T&gt; originInvoker)</span> <span class="keyword">throws</span> RpcException </span>&#123;</span><br><span class="line">    <span class="comment">// 获取注册中心URL</span></span><br><span class="line">    URL registryUrl = getRegistryUrl(originInvoker);</span><br><span class="line">    <span class="comment">// url to export locally</span></span><br><span class="line">    <span class="comment">// 获取提供者URL</span></span><br><span class="line">    URL providerUrl = getProviderUrl(originInvoker);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Subscribe the override data</span></span><br><span class="line">    <span class="comment">// FIXME When the provider subscribes, it will affect the scene : a certain JVM exposes the service and call</span></span><br><span class="line">    <span class="comment">//  the same service. Because the subscribed is cached key with the name of the service, it causes the</span></span><br><span class="line">    <span class="comment">//  subscription information to cover.</span></span><br><span class="line">    <span class="keyword">final</span> URL overrideSubscribeUrl = getSubscribedOverrideUrl(providerUrl);</span><br><span class="line">    <span class="keyword">final</span> OverrideListener overrideSubscribeListener = <span class="keyword">new</span> OverrideListener(overrideSubscribeUrl, originInvoker);</span><br><span class="line">    overrideListeners.put(overrideSubscribeUrl, overrideSubscribeListener);</span><br><span class="line"></span><br><span class="line">    providerUrl = overrideUrlWithConfig(providerUrl, overrideSubscribeListener);</span><br><span class="line">    <span class="comment">//export invoker</span></span><br><span class="line">    <span class="comment">// 选择具体的协议去暴露服务</span></span><br><span class="line">    <span class="comment">// 以DubboProtocol为例，最终调用到DubboProtocol</span></span><br><span class="line">    <span class="keyword">final</span> ExporterChangeableWrapper&lt;T&gt; exporter = doLocalExport(originInvoker, providerUrl);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// url to registry</span></span><br><span class="line">    <span class="comment">// 获取注册中心</span></span><br><span class="line">    <span class="keyword">final</span> Registry registry = getRegistry(originInvoker);</span><br><span class="line">    <span class="keyword">final</span> URL registeredProviderUrl = getUrlToRegistry(providerUrl, registryUrl);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// decide if we need to delay publish</span></span><br><span class="line">    <span class="keyword">boolean</span> register = providerUrl.getParameter(REGISTER_KEY, <span class="keyword">true</span>);</span><br><span class="line">    <span class="keyword">if</span> (register) &#123;</span><br><span class="line">        <span class="comment">// 注册服务</span></span><br><span class="line">        register(registryUrl, registeredProviderUrl);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// register stated url on provider model</span></span><br><span class="line">    registerStatedUrl(registryUrl, registeredProviderUrl, register);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    exporter.setRegisterUrl(registeredProviderUrl);</span><br><span class="line">    exporter.setSubscribeUrl(overrideSubscribeUrl);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Deprecated! Subscribe to override rules in 2.6.x or before.</span></span><br><span class="line">    <span class="comment">// 订阅</span></span><br><span class="line">    registry.subscribe(overrideSubscribeUrl, overrideSubscribeListener);</span><br><span class="line"></span><br><span class="line">    notifyExport(exporter);</span><br><span class="line">    <span class="comment">//Ensure that a new exporter instance is returned every time export</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> DestroyableExporter&lt;&gt;(exporter);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="DubboProtocol"><a href="#DubboProtocol" class="headerlink" title="DubboProtocol"></a>DubboProtocol</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">Exporter&lt;T&gt; <span class="title">export</span><span class="params">(Invoker&lt;T&gt; invoker)</span> <span class="keyword">throws</span> RpcException </span>&#123;</span><br><span class="line">    URL url = invoker.getUrl();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// export service.</span></span><br><span class="line">    <span class="comment">// 创建ServiceKey</span></span><br><span class="line">    String key = serviceKey(url);</span><br><span class="line">    <span class="comment">// 将上层传入的Invoker对象封装成DubboExporter对象，然后记录到exporterMap集合中</span></span><br><span class="line">    DubboExporter&lt;T&gt; exporter = <span class="keyword">new</span> DubboExporter&lt;T&gt;(invoker, key, exporterMap);</span><br><span class="line">    exporterMap.put(key, exporter);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//export an stub service for dispatching event</span></span><br><span class="line">    Boolean isStubSupportEvent = url.getParameter(STUB_EVENT_KEY, DEFAULT_STUB_EVENT);</span><br><span class="line">    Boolean isCallbackservice = url.getParameter(IS_CALLBACK_SERVICE, <span class="keyword">false</span>);</span><br><span class="line">    <span class="keyword">if</span> (isStubSupportEvent &amp;&amp; !isCallbackservice) &#123;</span><br><span class="line">        String stubServiceMethods = url.getParameter(STUB_EVENT_METHODS_KEY);</span><br><span class="line">        <span class="keyword">if</span> (stubServiceMethods == <span class="keyword">null</span> || stubServiceMethods.length() == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (logger.isWarnEnabled()) &#123;</span><br><span class="line">                logger.warn(<span class="keyword">new</span> IllegalStateException(<span class="string">&quot;consumer [&quot;</span> + url.getParameter(INTERFACE_KEY) +</span><br><span class="line">                        <span class="string">&quot;], has set stubproxy support event ,but no stub methods founded.&quot;</span>));</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 启动ProtocolServer</span></span><br><span class="line">    openServer(url);</span><br><span class="line">    <span class="comment">// 进行序列化的优化处理</span></span><br><span class="line">    optimizeSerialization(url);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> exporter;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="打开一个服务"><a href="#打开一个服务" class="headerlink" title="打开一个服务"></a>打开一个服务</h4><p>以当前的机器的（ip:port）为key，查看缓存中是否存在Server，没有则创建一个<br>不同协议暴露的端口不同，例如http协议可以选择8080端口之类的，dubbo协议为20880<br>默认 NettyServer</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> ProtocolServer <span class="title">createServer</span><span class="params">(URL url)</span> </span>&#123;</span><br><span class="line">  url = URLBuilder.from(url)</span><br><span class="line">          <span class="comment">// send readonly event when server closes, it&#x27;s enabled by default</span></span><br><span class="line">          <span class="comment">// readonlty请求是否阻塞等待</span></span><br><span class="line">          .addParameterIfAbsent(CHANNEL_READONLYEVENT_SENT_KEY, Boolean.TRUE.toString())</span><br><span class="line">          <span class="comment">// enable heartbeat by default</span></span><br><span class="line">          <span class="comment">// 心跳间隔</span></span><br><span class="line">          .addParameterIfAbsent(HEARTBEAT_KEY, String.valueOf(DEFAULT_HEARTBEAT))</span><br><span class="line">          <span class="comment">// Codec2扩展实现</span></span><br><span class="line">          .addParameter(CODEC_KEY, DubboCodec.NAME)</span><br><span class="line">          .build();</span><br><span class="line">  <span class="comment">// 检测SERVER_KEY参数指定的Transporter扩展实现是否合法</span></span><br><span class="line">  String str = url.getParameter(SERVER_KEY, DEFAULT_REMOTING_SERVER);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (str != <span class="keyword">null</span> &amp;&amp; str.length() &gt; <span class="number">0</span> &amp;&amp; !ExtensionLoader.getExtensionLoader(Transporter.class).hasExtension(str)) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> RpcException(<span class="string">&quot;Unsupported server type: &quot;</span> + str + <span class="string">&quot;, url: &quot;</span> + url);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ExchangeServer server;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// 通过Exchangers门面类，创建ExchangeServer对象</span></span><br><span class="line">      <span class="comment">// 处理consumer的请求</span></span><br><span class="line">			<span class="comment">// handler -&gt; 对应netty的handler</span></span><br><span class="line">      server = Exchangers.bind(url, requestHandler);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (RemotingException e) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> RpcException(<span class="string">&quot;Fail to start server(url: &quot;</span> + url + <span class="string">&quot;) &quot;</span> + e.getMessage(), e);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 检测CLIENT_KEY参数指定的Transporter扩展实现是否合法</span></span><br><span class="line">  str = url.getParameter(CLIENT_KEY);</span><br><span class="line">  <span class="keyword">if</span> (str != <span class="keyword">null</span> &amp;&amp; str.length() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      Set&lt;String&gt; supportedTypes = ExtensionLoader.getExtensionLoader(Transporter.class).getSupportedExtensions();</span><br><span class="line">      <span class="keyword">if</span> (!supportedTypes.contains(str)) &#123;</span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> RpcException(<span class="string">&quot;Unsupported client type: &quot;</span> + str);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 将ExchangeServer封装成DubboProtocolServer返回</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> DubboProtocolServer(server);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="注册到注册中心"><a href="#注册到注册中心" class="headerlink" title="注册到注册中心"></a>注册到注册中心</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Registry <span class="title">getRegistry</span><span class="params">(URL url)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (destroyed.get()) &#123;</span><br><span class="line">        LOGGER.warn(<span class="string">&quot;All registry instances have been destroyed, failed to fetch any instance. &quot;</span> +</span><br><span class="line">                <span class="string">&quot;Usually, this means no need to try to do unnecessary redundant resource clearance, all registries has been taken care of.&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> DEFAULT_NOP_REGISTRY;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    url = URLBuilder.from(url)</span><br><span class="line">            .setPath(RegistryService.class.getName())</span><br><span class="line">            .addParameter(INTERFACE_KEY, RegistryService.class.getName())</span><br><span class="line">            .removeParameters(EXPORT_KEY, REFER_KEY)</span><br><span class="line">            .build();</span><br><span class="line">    String key = createRegistryCacheKey(url);</span><br><span class="line">    <span class="comment">// Lock the registry access process to ensure a single instance of the registry</span></span><br><span class="line">    LOCK.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Registry registry = REGISTRIES.get(key);</span><br><span class="line">        <span class="keyword">if</span> (registry != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> registry;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//create registry by spi/ioc</span></span><br><span class="line">				<span class="comment">// 创建注册中心实例</span></span><br><span class="line">        registry = createRegistry(url);</span><br><span class="line">        <span class="keyword">if</span> (registry == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;Can not create registry &quot;</span> + url);</span><br><span class="line">        &#125;</span><br><span class="line">        REGISTRIES.put(key, registry);</span><br><span class="line">        <span class="keyword">return</span> registry;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// Release the lock</span></span><br><span class="line">        LOCK.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">register</span><span class="params">(URL url)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// 注册服务</span></span><br><span class="line">    <span class="keyword">this</span>.register(<span class="keyword">new</span> com.alibaba.dubbo.common.URL(url));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>

<div id="gitalk-container"></div>
<script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

		<script>
		var gitalkConfig = {"clientID":"26b8e6758f16d4524e69","clientSecret":"ecfd9e9a439bcb8a4c4fd21f4677fa102c68b352","repo":"beastmouth.github.io","owner":"beastmouth","admin":["beastmouth"],"distractionFreeMode":false,"createIssueManually":true};
	    gitalkConfig.id = md5(location.pathname);
		var gitalk = new Gitalk(gitalkConfig);
	    gitalk.render("gitalk-container");
	    </script>]]></content>
      <categories>
        <category>Dubbo</category>
      </categories>
  </entry>
  <entry>
    <title>Dubbo基础篇远程调用</title>
    <url>/2022/08/02/Dubbo%E5%9F%BA%E7%A1%80%E7%AF%87%E8%BF%9C%E7%A8%8B%E8%B0%83%E7%94%A8/</url>
    <content><![CDATA[<h1 id="完整流程图"><a href="#完整流程图" class="headerlink" title="完整流程图"></a>完整流程图</h1><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://bb3e216f.onedrive-cf-index-ng-e34.pages.dev/api/raw?path=/Public/BlogImg/Dubbo/Dubbo%E5%9F%BA%E7%A1%80%E7%AF%87%20%E6%9C%8D%E5%8A%A1%E8%B0%83%E7%94%A8%E5%AE%8C%E6%95%B4%E6%B5%81%E7%A8%8B.png"
                      alt="Dubbo基础篇 服务调用完整流程.png"
                ></p>
<h1 id="一句话总结流程"><a href="#一句话总结流程" class="headerlink" title="一句话总结流程"></a>一句话总结流程</h1><p>总结为一句话就是：客户端在发起远程调用时，具体的代理类会被InvokerInvacationHandler拦截，在这里面根据一些条件和负载均衡策略，选择出其中一个符合条件的Invoker，进行远程调用。提供者收到请求后，会从ExpoterMap中选择对应的Invoker（Wrapper包装），最终调用到具体的实现类。处理完请求后将结果返回。返回后客户端根据之前传过去的请求ID，找到之前的请求，然后再进行自己的业务处理</p>
<h1 id="Consumer远程调用"><a href="#Consumer远程调用" class="headerlink" title="Consumer远程调用"></a>Consumer远程调用</h1><ul>
<li>调用对应的代理类</li>
<li>被InvokerInvocationHandler拦截</li>
<li>ClusterInvoker经过路由过滤，负载均衡，选择其中一个Invoker，发起远程调用（带请求ID）</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JavassistProxyFactory</span> <span class="keyword">extends</span> <span class="title">AbstractProxyFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">  <span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">getProxy</span><span class="params">(Invoker&lt;T&gt; invoker, Class&lt;?&gt;[] interfaces)</span> </span>&#123;</span><br><span class="line">			<span class="comment">// InvokerInvocationHandler （重点关注）</span></span><br><span class="line">			<span class="comment">// 远程调用时，调用的方法会被 InvokerInvocationHandler 拦截</span></span><br><span class="line">      <span class="keyword">return</span> (T) Proxy.getProxy(interfaces).newInstance(<span class="keyword">new</span> InvokerInvocationHandler(invoker));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="InvokerInvocationHandler处理"><a href="#InvokerInvocationHandler处理" class="headerlink" title="InvokerInvocationHandler处理"></a>InvokerInvocationHandler处理</h2><ul>
<li><p>构建RpcInvocation</p>
</li>
<li><p>调用对应Invoker的invoke方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (method.getDeclaringClass() == Object.class) &#123;</span><br><span class="line">        <span class="keyword">return</span> method.invoke(invoker, args);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 获取调用的远程方法名</span></span><br><span class="line">    String methodName = method.getName();</span><br><span class="line">    <span class="comment">// 获取参数</span></span><br><span class="line">    Class&lt;?&gt;[] parameterTypes = method.getParameterTypes();</span><br><span class="line">    <span class="keyword">if</span> (parameterTypes.length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="string">&quot;toString&quot;</span>.equals(methodName)) &#123;</span><br><span class="line">            <span class="keyword">return</span> invoker.toString();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">&quot;$destroy&quot;</span>.equals(methodName)) &#123;</span><br><span class="line">            invoker.destroy();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">&quot;hashCode&quot;</span>.equals(methodName)) &#123;</span><br><span class="line">            <span class="keyword">return</span> invoker.hashCode();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (parameterTypes.length == <span class="number">1</span> &amp;&amp; <span class="string">&quot;equals&quot;</span>.equals(methodName)) &#123;</span><br><span class="line">        <span class="keyword">return</span> invoker.equals(args[<span class="number">0</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 构建一个dubbo rpc invocation</span></span><br><span class="line">    RpcInvocation rpcInvocation = <span class="keyword">new</span> RpcInvocation(method, invoker.getInterface().getName(), protocolServiceKey, args);</span><br><span class="line">    String serviceKey = invoker.getUrl().getServiceKey();</span><br><span class="line">    rpcInvocation.setTargetServiceUniqueName(serviceKey);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// invoker.getUrl() returns consumer url.</span></span><br><span class="line">    RpcContext.setRpcContext(invoker.getUrl());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (consumerModel != <span class="keyword">null</span>) &#123;</span><br><span class="line">        rpcInvocation.put(Constants.CONSUMER_MODEL, consumerModel);</span><br><span class="line">        rpcInvocation.put(Constants.METHOD_MODEL, consumerModel.getMethodModel(method));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 远程调用</span></span><br><span class="line">    <span class="keyword">return</span> invoker.invoke(rpcInvocation).recreate();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Invoker-invoker方法"><a href="#Invoker-invoker方法" class="headerlink" title="Invoker#invoker方法"></a>Invoker#invoker方法</h2></li>
<li><p>路由过滤</p>
</li>
<li><p>负载均衡</p>
</li>
</ul>
<p>最终挑选出某一个invoker</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Result <span class="title">invoke</span><span class="params">(<span class="keyword">final</span> Invocation invocation)</span> <span class="keyword">throws</span> RpcException </span>&#123;</span><br><span class="line">    checkWhetherDestroyed();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// binding attachments into invocation.</span></span><br><span class="line">    Map&lt;String, Object&gt; contextAttachments = RpcContext.getContext().getObjectAttachments();</span><br><span class="line">    <span class="keyword">if</span> (contextAttachments != <span class="keyword">null</span> &amp;&amp; contextAttachments.size() != <span class="number">0</span>) &#123;</span><br><span class="line">        ((RpcInvocation) invocation).addObjectAttachments(contextAttachments);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 实际上就是directroy.list 通过方法名寻找invokers 里面回去做一些过滤 获取过滤后的invoke列表</span></span><br><span class="line">    List&lt;Invoker&lt;T&gt;&gt; invokers = list(invocation);</span><br><span class="line">    <span class="comment">// 根据@SPI选择负载均衡的策略</span></span><br><span class="line">    LoadBalance loadbalance = initLoadBalance(invokers, invocation);</span><br><span class="line">    RpcUtils.attachInvocationIdIfAsync(getUrl(), invocation);</span><br><span class="line">    <span class="keyword">return</span> doInvoke(invocation, invokers, loadbalance); <span class="comment">// 调用子类的方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="meta">@SuppressWarnings(&#123;&quot;unchecked&quot;, &quot;rawtypes&quot;&#125;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Result <span class="title">doInvoke</span><span class="params">(Invocation invocation, <span class="keyword">final</span> List&lt;Invoker&lt;T&gt;&gt; invokers, LoadBalance loadbalance)</span> <span class="keyword">throws</span> RpcException </span>&#123;</span><br><span class="line">    List&lt;Invoker&lt;T&gt;&gt; copyInvokers = invokers;</span><br><span class="line">    checkInvokers(copyInvokers, invocation);</span><br><span class="line">    String methodName = RpcUtils.getMethodName(invocation);</span><br><span class="line">    <span class="keyword">int</span> len = getUrl().getMethodParameter(methodName, RETRIES_KEY, DEFAULT_RETRIES) + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (len &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        len = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// retry loop.</span></span><br><span class="line">    RpcException le = <span class="keyword">null</span>; <span class="comment">// last exception.</span></span><br><span class="line">    List&lt;Invoker&lt;T&gt;&gt; invoked = <span class="keyword">new</span> ArrayList&lt;Invoker&lt;T&gt;&gt;(copyInvokers.size()); <span class="comment">// invoked invokers.</span></span><br><span class="line">    Set&lt;String&gt; providers = <span class="keyword">new</span> HashSet&lt;String&gt;(len);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">        <span class="comment">//Reselect before retry to avoid a change of candidate `invokers`.</span></span><br><span class="line">        <span class="comment">//<span class="doctag">NOTE:</span> if `invokers` changed, then `invoked` also lose accuracy.</span></span><br><span class="line">        <span class="keyword">if</span> (i &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            checkWhetherDestroyed();</span><br><span class="line">            copyInvokers = list(invocation);</span><br><span class="line">            <span class="comment">// check again</span></span><br><span class="line">            checkInvokers(copyInvokers, invocation);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 根据负载均衡规则找出一个invoker</span></span><br><span class="line">        Invoker&lt;T&gt; invoker = select(loadbalance, invocation, copyInvokers, invoked);</span><br><span class="line">        invoked.add(invoker);</span><br><span class="line">        RpcContext.getContext().setInvokers((List) invoked);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 远程调用(每次请求都有一个唯一的ID)</span></span><br><span class="line">            Result result = invoker.invoke(invocation);</span><br><span class="line">            <span class="keyword">if</span> (le != <span class="keyword">null</span> &amp;&amp; logger.isWarnEnabled()) &#123;</span><br><span class="line">                logger.warn(<span class="string">&quot;Although retry the method &quot;</span> + methodName</span><br><span class="line">                        + <span class="string">&quot; in the service &quot;</span> + getInterface().getName()</span><br><span class="line">                        + <span class="string">&quot; was successful by the provider &quot;</span> + invoker.getUrl().getAddress()</span><br><span class="line">                        + <span class="string">&quot;, but there have been failed providers &quot;</span> + providers</span><br><span class="line">                        + <span class="string">&quot; (&quot;</span> + providers.size() + <span class="string">&quot;/&quot;</span> + copyInvokers.size()</span><br><span class="line">                        + <span class="string">&quot;) from the registry &quot;</span> + directory.getUrl().getAddress()</span><br><span class="line">                        + <span class="string">&quot; on the consumer &quot;</span> + NetUtils.getLocalHost()</span><br><span class="line">                        + <span class="string">&quot; using the dubbo version &quot;</span> + Version.getVersion() + <span class="string">&quot;. Last error is: &quot;</span></span><br><span class="line">                        + le.getMessage(), le);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RpcException e) &#123;</span><br><span class="line">            <span class="keyword">if</span> (e.isBiz()) &#123; <span class="comment">// biz exception.</span></span><br><span class="line">                <span class="keyword">throw</span> e;</span><br><span class="line">            &#125;</span><br><span class="line">            le = e;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">            le = <span class="keyword">new</span> RpcException(e.getMessage(), e);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            providers.add(invoker.getUrl().getAddress());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> RpcException(le.getCode(), <span class="string">&quot;Failed to invoke the method &quot;</span></span><br><span class="line">            + methodName + <span class="string">&quot; in the service &quot;</span> + getInterface().getName()</span><br><span class="line">            + <span class="string">&quot;. Tried &quot;</span> + len + <span class="string">&quot; times of the providers &quot;</span> + providers</span><br><span class="line">            + <span class="string">&quot; (&quot;</span> + providers.size() + <span class="string">&quot;/&quot;</span> + copyInvokers.size()</span><br><span class="line">            + <span class="string">&quot;) from the registry &quot;</span> + directory.getUrl().getAddress()</span><br><span class="line">            + <span class="string">&quot; on the consumer &quot;</span> + NetUtils.getLocalHost() + <span class="string">&quot; using the dubbo version &quot;</span></span><br><span class="line">            + Version.getVersion() + <span class="string">&quot;. Last error is: &quot;</span></span><br><span class="line">            + le.getMessage(), le.getCause() != <span class="keyword">null</span> ? le.getCause() : le);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Provider处理请求"><a href="#Provider处理请求" class="headerlink" title="Provider处理请求"></a>Provider处理请求</h1><ul>
<li>服务端的NettyServer处理请求，最终会调用到DubboProtcol#reply</li>
<li>根据客户端的请求，从ExportedMap中选择对应的Invoker （ExportedMap key:serviceKey()）</li>
<li>调用Invoker具体业务类的方法<br>链式调用，入口 ProtocolFilterWrapper 会处理调用信息GenericFilter，上下文ContextFilter等<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://bb3e216f.onedrive-cf-index-ng-e34.pages.dev/api/raw?path=/Public/BlogImg/Dubbo/Dubbo%E5%9F%BA%E7%A1%80%E7%AF%87%20%E8%BF%9C%E7%A8%8B%E8%B0%83%E7%94%A8NettyService%E5%A4%84%E7%90%86%E6%B5%81%E7%A8%8B.png"
                      alt="Dubbo基础篇 远程调用NettyService处理流程.png"
                ><br>调用到AbstractProxyInvoker ，当前类调用_通过Javaassist封装成Wrapper类_最终调用到具体的实现类</li>
<li>返回处理结果</li>
</ul>
<h2 id="NettyServer的Handler处理请求"><a href="#NettyServer的Handler处理请求" class="headerlink" title="NettyServer的Handler处理请求"></a>NettyServer的Handler处理请求</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelConnected</span><span class="params">(ChannelHandlerContext ctx, ChannelStateEvent e)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    NettyChannel channel = NettyChannel.getOrAddChannel(ctx.getChannel(), url, handler);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (channel != <span class="keyword">null</span>) &#123;</span><br><span class="line">            channels.put(NetUtils.toAddressString((InetSocketAddress) ctx.getChannel().getRemoteAddress()), channel);</span><br><span class="line">        &#125;</span><br><span class="line">        handler.connected(channel);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        NettyChannel.removeChannelIfDisconnected(ctx.getChannel());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (logger.isInfoEnabled()) &#123;</span><br><span class="line">        logger.info(<span class="string">&quot;The connection between &quot;</span> + channel.getRemoteAddress() + <span class="string">&quot; and &quot;</span> + channel.getLocalAddress() + <span class="string">&quot; is established&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">connected</span><span class="params">(Channel channel)</span> <span class="keyword">throws</span> RemotingException </span>&#123;</span><br><span class="line">  ExecutorService executor = getExecutorService();</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">		<span class="comment">// 封装成ChannelEventRunnable，丢到线程中处理</span></span><br><span class="line">    executor.execute(<span class="keyword">new</span> ChannelEventRunnable(channel, handler, ChannelState.CONNECTED));</span><br><span class="line">  &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> ExecutionException(<span class="string">&quot;connect event&quot;</span>, channel, getClass() + <span class="string">&quot; error when process connected event .&quot;</span>, t);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">handleRequest</span><span class="params">(<span class="keyword">final</span> ExchangeChannel channel, Request req)</span> <span class="keyword">throws</span> RemotingException </span>&#123;</span><br><span class="line">    <span class="comment">// 通过请求id，构建一个Response</span></span><br><span class="line">    Response res = <span class="keyword">new</span> Response(req.getId(), req.getVersion());</span><br><span class="line">    <span class="keyword">if</span> (req.isBroken()) &#123;</span><br><span class="line">        <span class="comment">// 获取请求信息 方法名之类的</span></span><br><span class="line">        Object data = req.getData();</span><br><span class="line"></span><br><span class="line">        String msg;</span><br><span class="line">        <span class="keyword">if</span> (data == <span class="keyword">null</span>) &#123;</span><br><span class="line">            msg = <span class="keyword">null</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (data <span class="keyword">instanceof</span> Throwable) &#123;</span><br><span class="line">            msg = StringUtils.toString((Throwable) data);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            msg = data.toString();</span><br><span class="line">        &#125;</span><br><span class="line">        res.setErrorMessage(<span class="string">&quot;Fail to decode request due to: &quot;</span> + msg);</span><br><span class="line">        res.setStatus(Response.BAD_REQUEST);</span><br><span class="line"></span><br><span class="line">        channel.send(res);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// find handler by message class.</span></span><br><span class="line">    Object msg = req.getData();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 最终调用 DubboProtocol reply</span></span><br><span class="line">        CompletionStage&lt;Object&gt; future = handler.reply(channel, msg);</span><br><span class="line">        future.whenComplete((appResult, t) -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (t == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    res.setStatus(Response.OK);</span><br><span class="line">                    res.setResult(appResult);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    res.setStatus(Response.SERVICE_ERROR);</span><br><span class="line">                    res.setErrorMessage(StringUtils.toString(t));</span><br><span class="line">                &#125;</span><br><span class="line">                channel.send(res);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (RemotingException e) &#123;</span><br><span class="line">                logger.warn(<span class="string">&quot;Send result to consumer failed, channel is &quot;</span> + channel + <span class="string">&quot;, msg is &quot;</span> + e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">        res.setStatus(Response.SERVICE_ERROR);</span><br><span class="line">        res.setErrorMessage(StringUtils.toString(e));</span><br><span class="line">        channel.send(res);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>最终调用到 DubboProtocol</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> ExchangeHandler requestHandler = <span class="keyword">new</span> ExchangeHandlerAdapter() &#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> CompletableFuture&lt;Object&gt; <span class="title">reply</span><span class="params">(ExchangeChannel channel, Object message)</span> <span class="keyword">throws</span> RemotingException </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!(message <span class="keyword">instanceof</span> Invocation)) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RemotingException(channel, <span class="string">&quot;Unsupported request: &quot;</span></span><br><span class="line">                + (message == <span class="keyword">null</span> ? <span class="keyword">null</span> : (message.getClass().getName() + <span class="string">&quot;: &quot;</span> + message))</span><br><span class="line">                + <span class="string">&quot;, channel: consumer: &quot;</span> + channel.getRemoteAddress() + <span class="string">&quot; --&gt; provider: &quot;</span> + channel.getLocalAddress());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Invocation inv = (Invocation) message;</span><br><span class="line">    <span class="comment">// 根据inv获取Invoker   去exporterMap中找</span></span><br><span class="line">    Invoker&lt;?&gt; invoker = getInvoker(channel, inv);</span><br><span class="line">    <span class="comment">// need to consider backward-compatibility if it&#x27;s a callback</span></span><br><span class="line">    <span class="keyword">if</span> (Boolean.TRUE.toString().equals(inv.getObjectAttachments().get(IS_CALLBACK_SERVICE_INVOKE))) &#123;</span><br><span class="line">        String methodsStr = invoker.getUrl().getParameters().get(<span class="string">&quot;methods&quot;</span>);</span><br><span class="line">        <span class="keyword">boolean</span> hasMethod = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (methodsStr == <span class="keyword">null</span> || !methodsStr.contains(<span class="string">&quot;,&quot;</span>)) &#123;</span><br><span class="line">            hasMethod = inv.getMethodName().equals(methodsStr);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            String[] methods = methodsStr.split(<span class="string">&quot;,&quot;</span>);</span><br><span class="line">            <span class="keyword">for</span> (String method : methods) &#123;</span><br><span class="line">                <span class="keyword">if</span> (inv.getMethodName().equals(method)) &#123;</span><br><span class="line">                    hasMethod = <span class="keyword">true</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!hasMethod) &#123;</span><br><span class="line">            logger.warn(<span class="keyword">new</span> IllegalStateException(<span class="string">&quot;The methodName &quot;</span> + inv.getMethodName()</span><br><span class="line">                    + <span class="string">&quot; not found in callback service interface ,invoke will be ignored.&quot;</span></span><br><span class="line">                    + <span class="string">&quot; please update the api interface. url is:&quot;</span></span><br><span class="line">                    + invoker.getUrl()) + <span class="string">&quot; ,invocation is :&quot;</span> + inv);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    RpcContext.getContext().setRemoteAddress(channel.getRemoteAddress());</span><br><span class="line">    <span class="comment">// 调用对应的invoke方法（最终wrapper.invokeMethod，参考服务暴露文档）</span></span><br><span class="line">    Result result = invoker.invoke(inv);</span><br><span class="line">    <span class="keyword">return</span> result.thenApply(Function.identity());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="链式调用点-ProtocolFilterWrapper"><a href="#链式调用点-ProtocolFilterWrapper" class="headerlink" title="链式调用点 ProtocolFilterWrapper"></a>链式调用点 ProtocolFilterWrapper</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Result <span class="title">invoke</span><span class="params">(Invocation invocation)</span> <span class="keyword">throws</span> RpcException </span>&#123;</span><br><span class="line">    Result asyncResult;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        asyncResult = filter.invoke(next, invocation);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        <span class="keyword">if</span> (filter <span class="keyword">instanceof</span> ListenableFilter) &#123;</span><br><span class="line">            ListenableFilter listenableFilter = ((ListenableFilter) filter);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Filter.Listener listener = listenableFilter.listener(invocation);</span><br><span class="line">                <span class="keyword">if</span> (listener != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    listener.onError(e, invoker, invocation);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                listenableFilter.removeListener(invocation);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (filter <span class="keyword">instanceof</span> Filter.Listener) &#123;</span><br><span class="line">            Filter.Listener listener = (Filter.Listener) filter;</span><br><span class="line">            listener.onError(e, invoker, invocation);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">throw</span> e;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> asyncResult.whenCompleteWithContext((r, t) -&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span> (filter <span class="keyword">instanceof</span> ListenableFilter) &#123;</span><br><span class="line">            ListenableFilter listenableFilter = ((ListenableFilter) filter);</span><br><span class="line">            Filter.Listener listener = listenableFilter.listener(invocation);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (listener != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (t == <span class="keyword">null</span>) &#123;</span><br><span class="line">                        listener.onResponse(r, invoker, invocation);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        listener.onError(t, invoker, invocation);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                listenableFilter.removeListener(invocation);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (filter <span class="keyword">instanceof</span> Filter.Listener) &#123;</span><br><span class="line">            Filter.Listener listener = (Filter.Listener) filter;</span><br><span class="line">            <span class="keyword">if</span> (t == <span class="keyword">null</span>) &#123;</span><br><span class="line">                listener.onResponse(r, invoker, invocation);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                listener.onError(t, invoker, invocation);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最终调用到Wrapper#AbstractProxyInvoker</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Result <span class="title">invoke</span><span class="params">(Invocation invocation)</span> <span class="keyword">throws</span> RpcException </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Object value = doInvoke(proxy, invocation.getMethodName(), invocation.getParameterTypes(), invocation.getArguments());</span><br><span class="line">	CompletableFuture&lt;Object&gt; future = wrapWithFuture(value);</span><br><span class="line">        CompletableFuture&lt;AppResponse&gt; appResponseFuture = future.handle((obj, t) -&gt; &#123;</span><br><span class="line">            AppResponse result = <span class="keyword">new</span> AppResponse();</span><br><span class="line">            <span class="keyword">if</span> (t != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (t <span class="keyword">instanceof</span> CompletionException) &#123;</span><br><span class="line">                    result.setException(t.getCause());</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    result.setException(t);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                result.setValue(obj);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> AsyncRpcResult(appResponseFuture, invocation);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InvocationTargetException e) &#123;</span><br><span class="line">        <span class="keyword">if</span> (RpcContext.getContext().isAsyncStarted() &amp;&amp; !RpcContext.getContext().stopAsync()) &#123;</span><br><span class="line">            logger.error(<span class="string">&quot;Provider async started, but got an exception from the original method, cannot write the exception back to consumer because an async result may have returned the new thread.&quot;</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> AsyncRpcResult.newDefaultAsyncResult(<span class="keyword">null</span>, e.getTargetException(), invocation);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RpcException(<span class="string">&quot;Failed to invoke remote proxy method &quot;</span> + invocation.getMethodName() + <span class="string">&quot; to &quot;</span> + getUrl() + <span class="string">&quot;, cause: &quot;</span> + e.getMessage(), e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> Object <span class="title">doInvoke</span><span class="params">(T proxy, String methodName, Class&lt;?&gt;[] parameterTypes, Object[] arguments)</span> <span class="keyword">throws</span> Throwable</span>;</span><br></pre></td></tr></table></figure>
<h2 id="Javassist动态代理"><a href="#Javassist动态代理" class="headerlink" title="Javassist动态代理"></a>Javassist动态代理</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">Invoker&lt;T&gt; <span class="title">getInvoker</span><span class="params">(T proxy, Class&lt;T&gt; type, URL url)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// TODO Wrapper cannot handle this scenario correctly: the classname contains &#x27;$&#x27;</span></span><br><span class="line">    <span class="comment">// 通过Javaassist封装成Wrapper类（Dubbo服务启动时生成，所以在运行时不会产生开销），减少反射的调用</span></span><br><span class="line">    <span class="keyword">final</span> Wrapper wrapper = Wrapper.getWrapper(proxy.getClass().getName().indexOf(<span class="string">&#x27;$&#x27;</span>) &lt; <span class="number">0</span> ? proxy.getClass() : type);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> AbstractProxyInvoker&lt;T&gt;(proxy, type, url) &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="comment">// Wrapper最终调用最终调用服务提供者的接口实现类的方法</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> Object <span class="title">doInvoke</span><span class="params">(T proxy, String methodName,</span></span></span><br><span class="line"><span class="params"><span class="function">                                  Class&lt;?&gt;[] parameterTypes,</span></span></span><br><span class="line"><span class="params"><span class="function">                                  Object[] arguments)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> wrapper.invokeMethod(proxy, methodName, parameterTypes, arguments);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<div id="gitalk-container"></div>
<script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

		<script>
		var gitalkConfig = {"clientID":"26b8e6758f16d4524e69","clientSecret":"ecfd9e9a439bcb8a4c4fd21f4677fa102c68b352","repo":"beastmouth.github.io","owner":"beastmouth","admin":["beastmouth"],"distractionFreeMode":false,"createIssueManually":true};
	    gitalkConfig.id = md5(location.pathname);
		var gitalk = new Gitalk(gitalkConfig);
	    gitalk.render("gitalk-container");
	    </script>]]></content>
      <categories>
        <category>Dubbo</category>
      </categories>
  </entry>
  <entry>
    <title>FullGC引发的服务宕机问题</title>
    <url>/2022/10/02/FullGC%E5%BC%95%E5%8F%91%E7%9A%84%E6%9C%8D%E5%8A%A1%E5%AE%95%E6%9C%BA%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h1 id="现象"><a href="#现象" class="headerlink" title="现象"></a>现象</h1><p>测试环境频繁FullGC，导致整个服务停止对外提供服务。<br>同时使用arthas增强失败，无法attach服务</p>
<h1 id="排查过程"><a href="#排查过程" class="headerlink" title="排查过程"></a>排查过程</h1><ul>
<li><p>调用方/测试反映接口超时，无法正常调用</p>
</li>
<li><p>监控发现服务频繁发生fullgc，同时通过jstat命令发现fullgc频率极高，年轻代老年代使用都达到了100%</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">jstat -gcutil 1 1000</span><br></pre></td></tr></table></figure>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://bb3e216f.onedrive-cf-index-ng-e34.pages.dev/api/raw?path=/Public/BlogImg/JVM/FullGC%E5%BC%95%E5%8F%91%E7%9A%84%E9%97%AE%E9%A2%98-jstat.jpeg"
                      alt="FullGC引发的问题-jstat.png"
                ></p>
</li>
<li><p>利用jmap命令导出堆情况，并使用visualvm查看堆情况。发现char[]占用内存极其之高</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">jmap -dump:format=b,file=heapdump 1</span><br></pre></td></tr></table></figure>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://bb3e216f.onedrive-cf-index-ng-e34.pages.dev/api/raw?path=/Public/BlogImg/JVM/FullGC%E5%BC%95%E5%8F%91%E7%9A%84%E9%97%AE%E9%A2%98-heapdump.png"
                      alt="FullGC引发的问题-heapdump.png"
                ></p>
</li>
<li><p>一方面，发现有一个一口气查询了5000多条订单，另一方面发现还有一大堆小对象</p>
</li>
</ul>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://bb3e216f.onedrive-cf-index-ng-e34.pages.dev/api/raw?path=/Public/BlogImg/JVM/FullGC%E5%BC%95%E5%8F%91%E7%9A%84%E9%97%AE%E9%A2%98-heapdump2.png"
                      alt="FullGC引发的问题-heapdump2.png"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://bb3e216f.onedrive-cf-index-ng-e34.pages.dev/api/raw?path=/Public/BlogImg/JVM/FullGC%E5%BC%95%E5%8F%91%E7%9A%84%E9%97%AE%E9%A2%98-heapdump3.png"
                      alt="FullGC引发的问题-heapdump3.png"
                ></p>
<ul>
<li><p>根据日志与代码，发现了有一个场景下需要去查询用户所有有效的订单，并且会去查询关联的信息（如上图）</p>
</li>
<li><p>此时再去查看下当前JVM的基本信息（发现堆特别小）</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">/ # jinfo -flags 1</span><br><span class="line">Attaching to process ID 1, please wait...</span><br><span class="line">Debugger attached successfully.</span><br><span class="line">Server compiler detected.</span><br><span class="line">JVM version is 25.291-b10</span><br><span class="line">Non-default VM flags: -XX:CICompilerCount=2 -XX:InitialHeapSize=33554432 -XX:MaxHeapSize=536870912 -XX:MaxNewSize=178913280 -XX:MinHeapDeltaBytes=196608 -XX:NewSize=11141120 -XX:OldSize=22413312 -XX:+UseCompressedClassPointers -XX:+UseCompressedOops -XX:+UseFastUnorderedTimeStamps </span><br><span class="line">Command line:  -Dfile.encoding=UTF-8 -Dxmiast.ip=xxx.xxx.xxx.xxx -Dxmiast.port=9090 -Dxmiast.token=xxxxxxxx -Dxmiast.projectname=xxxxx -Dxmiast.nodename=xxxxxx -javaagent:/xxxxx.jar</span><br></pre></td></tr></table></figure>
<p>可以断定：<br>当前年轻代无法存下这么多小对象，小对象直接一口气放入了老年代。同时老年代也存不下这么多数据，于是需要进行fullgc。而fullgc是STW的，所以服务直接停止对外提供服务，造成上述问题</p>
<h1 id="解决思路"><a href="#解决思路" class="headerlink" title="解决思路"></a>解决思路</h1></li>
<li><p>一方面，因为业务场景原因，一个用户有效订单数理论上不超过20条，当前数据为压测时数据，可忽略。（手动删除非法数据）</p>
</li>
<li><p>另一方面，512m的jvm堆内存属实有些小，此处将整个堆内存提高</p>
<h1 id="后续一些优化的思考"><a href="#后续一些优化的思考" class="headerlink" title="后续一些优化的思考"></a>后续一些优化的思考</h1><p>因为是一个面向C端的系统，假如存在吞吐量问题，可以考虑将年轻代比例调高（C端应用特点：接口时间短但并发高）</p>
</li>
</ul>

<div id="gitalk-container"></div>
<script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

		<script>
		var gitalkConfig = {"clientID":"26b8e6758f16d4524e69","clientSecret":"ecfd9e9a439bcb8a4c4fd21f4677fa102c68b352","repo":"beastmouth.github.io","owner":"beastmouth","admin":["beastmouth"],"distractionFreeMode":false,"createIssueManually":true};
	    gitalkConfig.id = md5(location.pathname);
		var gitalk = new Gitalk(gitalkConfig);
	    gitalk.render("gitalk-container");
	    </script>]]></content>
      <categories>
        <category>开发问题</category>
      </categories>
  </entry>
  <entry>
    <title>I/O相关</title>
    <url>/2023/03/01/I-O%E7%9B%B8%E5%85%B3/</url>
    <content><![CDATA[<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://bb3e216f.onedrive-cf-index-ng-e34.pages.dev/api/raw?path=/Public/BlogImg/IO/IO.png"
                      alt="IO.png"
                ></p>
<h3 id="Linux是如何进行I-O操作的"><a href="#Linux是如何进行I-O操作的" class="headerlink" title="Linux是如何进行I/O操作的"></a>Linux是如何进行I/O操作的</h3><p>首先先明确一点：Linux内核将所有的外部设备都看做一个文件来操作</p>
<p>其次是涉及到I/O的两种场景（对应文件描述符的路径 /proc/xxx）</p>
<ul>
<li>对文件的读写操作会调用内核提供的系统命令，返回一个文件描述符（fd file descriptor）</li>
<li>对socket的读写也会有对应的描述符，socket描述符（socketfd）</li>
</ul>
<p>那么这里考虑到一个问题，为什么要通过描述符访问外部数据（四个方面）</p>
<ul>
<li>安全性：外部数据可能存在安全隐患，例如通过网络传输的数据可能会被黑客攻击或者恶意篡改。为了保证系统安全，操作系统需要对外部数据进行权限控制和安全验证。</li>
<li>简化编程：操作系统通过提供通用的描述符接口来屏蔽底层细节，使得用户进程可以更容易地访问和处理外部数据，同时还能够处理多种不同类型的数据源。</li>
<li>资源管理：操作系统需要对所有外部数据进行管理和调度，以确保外部数据的高效利用。如果用户进程直接访问外部数据，将会导致资源管理变得非常困难，并可能导致系统崩溃。</li>
<li>抽象层：操作系统通过提供通用的描述符接口来屏蔽底层细节，使得用户进程可以在不同的外部数据源之间移植代码。</li>
</ul>
<h3 id="几种I-O模型"><a href="#几种I-O模型" class="headerlink" title="几种I/O模型"></a>几种I/O模型</h3><h4 id="阻塞I-O模型（最常用）"><a href="#阻塞I-O模型（最常用）" class="headerlink" title="阻塞I/O模型（最常用）"></a>阻塞I/O模型（最常用）</h4><p>在用户空间中调用 recvfrom，用户的进程会一直阻塞到数据包被复制到应用进程缓冲区或发生错误时才结束</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://bb3e216f.onedrive-cf-index-ng-e34.pages.dev/api/raw?path=/Public/BlogImg/IO/%E9%98%BB%E5%A1%9EI_O%E6%A8%A1%E5%9E%8B.png"
                      alt="阻塞I_O模型.png"
                ></p>
<h4 id="非阻塞I-O模型"><a href="#非阻塞I-O模型" class="headerlink" title="非阻塞I/O模型"></a>非阻塞I/O模型</h4><p>recvfrom从应用层到内核时，如果缓冲区没有数据，就直接返回EWOULEBACK错误。用户程序一直轮询</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://bb3e216f.onedrive-cf-index-ng-e34.pages.dev/api/raw?path=/Public/BlogImg/IO/%E9%9D%9E%E9%98%BB%E5%A1%9EI_O%E6%A8%A1%E5%9E%8B.png"
                      alt="非阻塞I_O模型.png"
                ></p>
<h4 id="I-O复用模型"><a href="#I-O复用模型" class="headerlink" title="I/O复用模型"></a>I/O复用模型</h4><p>Linux提供了select或poll，进程通过将一个或多个fd传递给select或poll系统调用，阻塞在select操作上。select/poll是顺序扫描fd是否就绪，且支持的fd数量有限。Linux还提供了一个epoll系统调用，基于事件驱动方式代替顺序扫描，当有fd就绪时，立即回调函数rollback</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://bb3e216f.onedrive-cf-index-ng-e34.pages.dev/api/raw?path=/Public/BlogImg/IO/I_O%E5%A4%8D%E7%94%A8%E6%A8%A1%E5%9E%8B.png"
                      alt="I_O复用模型.png"
                ></p>
<h4 id="信号驱动I-O模型"><a href="#信号驱动I-O模型" class="headerlink" title="信号驱动I/O模型"></a>信号驱动I/O模型</h4><p>首先开启套接口信号驱动I/O功能，并通过系统调用sigaction执行一个信号处理函数（此系统调用立即返回，进程继续工作，它是非阻塞的）。当数据准备就绪，就为该进程生产一个SIGIO信号，通过信号回调通知应用程序调用recvfrom来读取数据，并通知主循环函数处理数据</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://bb3e216f.onedrive-cf-index-ng-e34.pages.dev/api/raw?path=/Public/BlogImg/IO/%E4%BF%A1%E5%8F%B7%E9%A9%B1%E5%8A%A8I_O%E6%A8%A1%E5%9E%8B.png"
                      alt="信号驱动I_O模型.png"
                ></p>
<h4 id="异步I-O模型"><a href="#异步I-O模型" class="headerlink" title="异步I/O模型"></a>异步I/O模型</h4><p>告诉内核启动某个操作，并让内核在整个操作完成后（包括将数据从内核复制到用户自己的缓冲区）通知我们</p>
<p>与信号驱动I/O模型的区别：</p>
<ul>
<li>信号驱动I/O模型：由内核通知我们何时可以开始一个I/O操作</li>
<li>异步I/O模型：由内核通知我们I/O操作何时已经完成</li>
</ul>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://bb3e216f.onedrive-cf-index-ng-e34.pages.dev/api/raw?path=/Public/BlogImg/IO/%E5%BC%82%E6%AD%A5I_O%E6%A8%A1%E5%9E%8B.png"
                      alt="异步I_O模型.png"
                ></p>
<h3 id="I-O多路复用技术"><a href="#I-O多路复用技术" class="headerlink" title="I/O多路复用技术"></a>I/O多路复用技术</h3><p>适用场景：需要同时处理多个客户端接入请求时，可以利用多线程或者I/O多路复用技术来处理</p>
<p>I/O多路复用技术：把多个I/O的阻塞复用到同一个select的阻塞上，使得系统在单线程的情况下可以处理多个客户端请求。不需要创建多线程/多进程，系统开销小</p>
<p>关于I/O多路复用，为什么要用epoll而不是用select/poll</p>
<ul>
<li>事件通知方式：epoll使用事件通知方式，只会通知发生了事件的文件描述符，而poll则需要轮询所有注册的文件描述符，效率较低。</li>
<li>可扩展性：epoll使用基于红黑树的数据结构来存储文件描述符，可以处理数以万计的并发连接，而poll只能处理数百个连接。</li>
<li>稳定性：epoll在注册和注销文件描述符时，不需要拷贝文件描述符列表，而poll需要拷贝文件描述符列表，可能会导致内核空间和用户空间数据同步问题。（mmap）</li>
<li>兼容性：epoll只能在Linux 2.6及以上版本中使用，而poll可以在所有Unix系统上使用。</li>
</ul>
<p>综上所述，epoll相较于poll有更好的性能和可扩展性，并且不会有数据同步问题，但是在兼容性方面有限制。选择使用哪种多路复用机制，需要根据具体的应用场景和操作系统版本来综合考虑。</p>

<div id="gitalk-container"></div>
<script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

		<script>
		var gitalkConfig = {"clientID":"26b8e6758f16d4524e69","clientSecret":"ecfd9e9a439bcb8a4c4fd21f4677fa102c68b352","repo":"beastmouth.github.io","owner":"beastmouth","admin":["beastmouth"],"distractionFreeMode":false,"createIssueManually":true};
	    gitalkConfig.id = md5(location.pathname);
		var gitalk = new Gitalk(gitalkConfig);
	    gitalk.render("gitalk-container");
	    </script>]]></content>
      <categories>
        <category>Linux</category>
      </categories>
  </entry>
  <entry>
    <title>Java实现多线程的两种方法</title>
    <url>/2021/12/30/Java%E5%AE%9E%E7%8E%B0%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9A%84%E4%B8%A4%E7%A7%8D%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<p>本文是学习悟空老师的视频教程<a class="link"   href="https://coding.imooc.com/learn/list/362.html" >线程八大核心基础<i class="fas fa-external-link-alt"></i></a>后所做的心得笔记，想更加具体了解其中知识的小伙伴可以前往慕课网悟空老师的课程中进行学习</p>
<h3 id="Java实现多线程的方法（2种）"><a href="#Java实现多线程的方法（2种）" class="headerlink" title="Java实现多线程的方法（2种）"></a>Java实现多线程的方法（2种）</h3><ol>
<li>实现Runnable接口</li>
<li>继承Thread类</li>
</ol>
<p>本质是两种，同时原理上两种本质是一样的</p>
<p>代码的实现n+</p>
<p>结论依据：参考Java官方文档</p>
<p>参考文档：<a class="link"   href="https://docs.oracle.com/javase/8/docs/api/java/lang/Thread.html" >https://docs.oracle.com/javase/8/docs/api/java/lang/Thread.html<i class="fas fa-external-link-alt"></i></a></p>
<p>两种实现方法示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hbj.learning.threadcoreknowledge.createthreads;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 用Runnable方式创建线程(使用该方法更好)</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> hbj</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2019/10/24 14:19</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RunnableStyle</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Thread thread = <span class="keyword">new</span> Thread(<span class="keyword">new</span> RunnableStyle());</span><br><span class="line">        thread.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;使用Runnable方法实现线程&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hbj.learning.threadcoreknowledge.createthreads;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 用Thread方式实现线程</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> hbj</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2019/10/24 14:22</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadStyle</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;使用Thread方式实现线程&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> ThreadStyle().start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>两种方法的对比/使用Thread创建线程方法的缺点：（优先使用Runnable方法创建线程）</p>
<ul>
<li>未解耦-Thread的创建方法和编程中的业务代码高耦合（代码架构角度 线程部分的代码+业务部分的代码 解耦 只需要考虑run方法里面的内容）</li>
<li>资源浪费-Thread方法每次创建都需要新建线程（创建，运行，销毁）一套完整的流程，而Runnable方法可以利用线程池等（反复利用创建的线程，资源消耗较小）</li>
<li>不能多继承-Java不能多继承，而该方法继承Thread方法后不能再继承其他类</li>
</ul>
<p>共同点：</p>
<ul>
<li>都是重写run函数</li>
<li>最终都是调用start方法来新建线程</li>
</ul>
<p>准确的描述：</p>
<p>创建线程的方法只有一个（即构造Thread类），而实现线程的执行单元（重写run函数）有两种方法</p>
<ol>
<li>实现Runnable接口的run方法，并将它作为target传给Thread（最终调用target.run方法）</li>
<li>重写Thread的run方法</li>
</ol>
<p>假如同时使用两种方法，会有什么结果？？</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hbj.learning.threadcoreknowledge.createthreads;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 同时使用Runnable和Thread方法创建线程</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> hbj</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2019/10/24 15:31</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BothRunnableThread</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="comment">// 传入Runnable对象</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;我来自Runnable&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;) &#123;</span><br><span class="line">            <span class="comment">// 重写了Thread类的run方法</span></span><br><span class="line">            <span class="comment">// 覆盖了原来的三行代码，导致上面的Runnable传参失效</span></span><br><span class="line">            <span class="comment">//    @Override</span></span><br><span class="line">            <span class="comment">//    public void run() &#123;</span></span><br><span class="line">            <span class="comment">//        if (target != null) &#123;</span></span><br><span class="line">            <span class="comment">//            target.run();</span></span><br><span class="line">            <span class="comment">//        &#125;</span></span><br><span class="line">            <span class="comment">//    &#125;</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;我来自Thread&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>执行结果：（原因：从面向对象的角度分析，具体见代码中的注释）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">我来自Thread</span><br></pre></td></tr></table></figure>



<ul>
<li>线程池创建线程不算是一种创建线程地方法</li>
<li>FutureTask和Callable创建线程不算是一种创建线程地方法</li>
</ul>
<p>所有类似的创建线程的方法，都只是包装了new Thread()，创建线程的方法仅有上面陈述的两个</p>

<div id="gitalk-container"></div>
<script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

		<script>
		var gitalkConfig = {"clientID":"26b8e6758f16d4524e69","clientSecret":"ecfd9e9a439bcb8a4c4fd21f4677fa102c68b352","repo":"beastmouth.github.io","owner":"beastmouth","admin":["beastmouth"],"distractionFreeMode":false,"createIssueManually":true};
	    gitalkConfig.id = md5(location.pathname);
		var gitalk = new Gitalk(gitalkConfig);
	    gitalk.render("gitalk-container");
	    </script>]]></content>
      <categories>
        <category>Thread</category>
      </categories>
  </entry>
  <entry>
    <title>MySQL-MVCC</title>
    <url>/2023/01/06/MySQL-MVCC/</url>
    <content><![CDATA[<h1 id="MVCC"><a href="#MVCC" class="headerlink" title="MVCC"></a>MVCC</h1><p>以下针对的是InnoDB引擎</p>
<h2 id="什么是可重复读"><a href="#什么是可重复读" class="headerlink" title="什么是可重复读"></a>什么是可重复读</h2><p>在可重复读的事务隔离级别下，当我们开启一个事务时，其他事务后续的改动，当前事务查询到的数据还是事务刚刚启动时候内容。这个实际上就是MySQL的MVCC做的事情。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 事务1</span></span><br><span class="line"><span class="keyword">begin</span>; <span class="comment">-- 执行顺序1</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> my_test <span class="keyword">where</span> id <span class="operator">=</span> <span class="number">1</span>; <span class="comment">-- 执行顺序2</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> my_test <span class="keyword">where</span> id <span class="operator">=</span> <span class="number">1</span>; <span class="comment">-- 执行顺序4</span></span><br><span class="line">update my_test <span class="keyword">set</span> b <span class="operator">=</span> <span class="string">&#x27;c&#x27;</span> <span class="keyword">where</span> id <span class="operator">=</span> <span class="number">1</span>;  <span class="comment">-- (更新数据是先读后写，是当前读，不基于快照读) 执行顺序5</span></span><br><span class="line"><span class="keyword">COMMIT</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 事务2</span></span><br><span class="line">update my_test <span class="keyword">set</span> b <span class="operator">=</span> <span class="string">&#x27;e&#x27;</span> <span class="keyword">where</span> id <span class="operator">=</span> <span class="number">1</span>; <span class="comment">-- 执行顺序3</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 按照上述的执行顺序，在第四步操作时，查询到的数据还是原来的数据，而不是事务2修改的内容</span></span><br></pre></td></tr></table></figure>

<p>那么，MySQL的MVCC是怎么做到这一切的呢？</p>
<p>实现MVCC依赖到了MySQL的一致性视图 consistent read view （支持RC 读提交和RR 可重复读）</p>
<p>关于这个一致性视图，它并不是我们之前使用到的查询时候建立的虚拟表（view），没有一个具体的物理结构，作用就是定义了事务执行时能看到什么样的数据。</p>
<p>然后，对于MySQL各个隔离级别使用这个一致性视图的情况如下：</p>
<ul>
<li>读未提交：直接返回记录上的最新值，不存在视图的概念</li>
<li>读提交：一致性视图是在每个SQL语句开始执行的时候创建的</li>
<li>可重复读：事务启动的时候创建的，整个事务存在期间都是用同一个视图</li>
<li>串行化：直接加锁来避免并行访问</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 这里补充一个查询事务隔离级别的命令</span></span><br><span class="line"><span class="keyword">show</span> variables <span class="keyword">like</span> <span class="string">&#x27;transaction_isolation&#x27;</span>;</span><br></pre></td></tr></table></figure>

<h2 id="可重复读历史数据版本实现原理"><a href="#可重复读历史数据版本实现原理" class="headerlink" title="可重复读历史数据版本实现原理"></a>可重复读历史数据版本实现原理</h2><p>首先明确一点：关于这个历史数据，并不是在事务开启时对历史数据进行一个快照版本备份（数据量大，成本太高），而是通过事务id和undolog来实现的</p>
<p>关于事务id</p>
<p>InnoDB里面每一个事务都有一个唯一的事务id（transaction id），它是事务开启的时候向InnoDB的事务系统申请的，根据申请顺序严格递增的。</p>
<p>然后对于每次更新操作，数据库是这样记录的</p>
<p>V1，V2，V3实际上是不存在，而是根据V4和undolog逆推实时计算出来的</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://bb3e216f.onedrive-cf-index-ng-e34.pages.dev/api/raw?path=/Public/BlogImg/MySQL/MYSQL-MVCC%E8%A1%8C%E8%AE%B0%E5%BD%95.png"
                      alt="MYSQL-MVCC行记录.png"
                ></p>
<p>那么，关于可重复读，MySQL是如何知道要逆推到哪个版本就可以结束了呢？</p>
<p>InnoDB为<strong>每个事务构建了一个数组</strong>，用来保存事务启动瞬间，当前正在活跃（启动但还没有提交）的所有事务id。</p>
<p>关于当前事务可以看到的数据版本，有以下几种可能</p>
<ul>
<li>如果trx_id落在绿色部分，说明是已经提交的事务或者是当前事务自己生成的，对当前事务是可见的</li>
<li>如果落在红色部分，说明是当前事务以后的事务生成的，不可见</li>
<li>如果落在黄色部分<ul>
<li>trx_id在数组中，说明这个版本的数据由未提交的事务生成，不可见</li>
<li>trx_id不在数组中，说明这个版本的数据是已经提交的事务生成，可见</li>
</ul>
</li>
</ul>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://bb3e216f.onedrive-cf-index-ng-e34.pages.dev/api/raw?path=/Public/BlogImg/MySQL/MySQL-MVCC%E9%AB%98%E4%BD%8E%E6%B0%B4%E4%BD%8D.png"
                      alt="MySQL-MVCC高低水位.png"
                ></p>

<div id="gitalk-container"></div>
<script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

		<script>
		var gitalkConfig = {"clientID":"26b8e6758f16d4524e69","clientSecret":"ecfd9e9a439bcb8a4c4fd21f4677fa102c68b352","repo":"beastmouth.github.io","owner":"beastmouth","admin":["beastmouth"],"distractionFreeMode":false,"createIssueManually":true};
	    gitalkConfig.id = md5(location.pathname);
		var gitalk = new Gitalk(gitalkConfig);
	    gitalk.render("gitalk-container");
	    </script>]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
  </entry>
  <entry>
    <title>MySQL刷脏页</title>
    <url>/2023/10/20/MySQL%E5%88%B7%E8%84%8F%E9%A1%B5/</url>
    <content><![CDATA[<h1 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h1><p>起因：由于MySQL的WAL机制，会导致内存和磁盘中的数据不一致的情况，此时这个不一致的数据，即是我们标题中提到脏页。</p>
<h1 id="刷脏页的几种场景"><a href="#刷脏页的几种场景" class="headerlink" title="刷脏页的几种场景"></a>刷脏页的几种场景</h1><ul>
<li>InnoDB 的 redo log 写满了。这时候系统会停止所有更新操作，把 checkpoint 往前推进，redo log 留出空间可以继续写</li>
<li>系统内存不足。当需要新的内存页，而内存不够用的时候，就要淘汰一些数据页，空出内存给别的数据页使用。如果淘汰的是“脏页”，就要先将脏页写到磁盘</li>
<li>MySQL 认为系统“空闲”的时候</li>
<li>MySQL 正常关闭的情况。这时候，MySQL 会把内存的脏页都 flush 到磁盘上</li>
</ul>
<p>此处需要考虑到性能的，主要是1，2两点</p>
<h1 id="内存页的几种状态"><a href="#内存页的几种状态" class="headerlink" title="内存页的几种状态"></a>内存页的几种状态</h1><ul>
<li>第一种是，还没有使用的【作为一个长久运行的系统，这种情况几乎很少】</li>
<li>第二种是，使用了并且是干净页</li>
<li>第三种是，使用了并且是脏页</li>
</ul>
<h1 id="如何控制刷脏页影响数据库性能"><a href="#如何控制刷脏页影响数据库性能" class="headerlink" title="如何控制刷脏页影响数据库性能"></a>如何控制刷脏页影响数据库性能</h1><ul>
<li><p>告诉MySQL所在主机的IO能力 innodb_io_capacity，该值建议设置成磁盘的IOPS。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 测试性能</span></span><br><span class="line">fio -filename=$filename -direct=1 -iodepth 1 -thread -rw=randrw -ioengine=psync -bs=16k -size=500M -numjobs=10 -runtime=10 -group_reporting -name=mytest </span><br></pre></td></tr></table></figure></li>
<li><p>控制脏页比例。innodb_max_dirty_pages_pct（默认75%）<br>InnoDB会根据脏页比例和磁盘写入速度来自动控制刷脏页速度</p>
</li>
<li><p>因为现在都是SSD，所以刷脏页不需要连坐（即把身边的脏页也刷新）。innodb_flush_neighbors = 0【不刷新身边的脏页】</p>
</li>
</ul>

<div id="gitalk-container"></div>
<script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

		<script>
		var gitalkConfig = {"clientID":"26b8e6758f16d4524e69","clientSecret":"ecfd9e9a439bcb8a4c4fd21f4677fa102c68b352","repo":"beastmouth.github.io","owner":"beastmouth","admin":["beastmouth"],"distractionFreeMode":false,"createIssueManually":true};
	    gitalkConfig.id = md5(location.pathname);
		var gitalk = new Gitalk(gitalkConfig);
	    gitalk.render("gitalk-container");
	    </script>]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
  </entry>
  <entry>
    <title>MySQL动态扩容-【其他文章收录】</title>
    <url>/2023/10/09/MySQL%E5%8A%A8%E6%80%81%E6%89%A9%E5%AE%B9-%E3%80%90%E5%85%B6%E4%BB%96%E6%96%87%E7%AB%A0%E6%94%B6%E5%BD%95%E3%80%91/</url>
    <content><![CDATA[<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://bb3e216f.onedrive-cf-index-ng-e34.pages.dev/api/raw?path=/Public/BlogImg/MySQL/MySQL%E5%8A%A8%E6%80%81%E6%89%A9%E5%AE%B9.png"
                      alt="MySQL动态扩容"
                ></p>

<div id="gitalk-container"></div>
<script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

		<script>
		var gitalkConfig = {"clientID":"26b8e6758f16d4524e69","clientSecret":"ecfd9e9a439bcb8a4c4fd21f4677fa102c68b352","repo":"beastmouth.github.io","owner":"beastmouth","admin":["beastmouth"],"distractionFreeMode":false,"createIssueManually":true};
	    gitalkConfig.id = md5(location.pathname);
		var gitalk = new Gitalk(gitalkConfig);
	    gitalk.render("gitalk-container");
	    </script>]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
  </entry>
  <entry>
    <title>MySQL锁事</title>
    <url>/2022/07/30/MySQL%E9%94%81%E4%BA%8B/</url>
    <content><![CDATA[<h1 id="SQL四种语言"><a href="#SQL四种语言" class="headerlink" title="SQL四种语言"></a>SQL四种语言</h1><p>先介绍下SQL的四种语言</p>
<ul>
<li>DDL：数据库定义语言 定义数据库结构，用于定义数据库的三级结构，包括外模式、概念模式、内模式及其相互之间的映像，定义数据的完整性、安全控制等约束。DDL不需要commit<ul>
<li>相关语句：CREATE，ALTER，DROP，TRUNCATE，COMMENT，RENAME</li>
</ul>
</li>
<li>DML：数据操控语言，由DBMS提供，用于让用户或程序员使用，实现对数据库中数据的操作。<ul>
<li>相关语句：SELECT，INSERT，UPDATE，DELETE，MERGE，CALL，EXPLAIN PLAN，LOCK TABLE</li>
</ul>
</li>
<li>DCL：数据库控制语言，用于授权， 角色控制等<ul>
<li>相关语句：GRANT，REVOKE</li>
</ul>
</li>
<li>TCL：事务控制语言<ul>
<li>相关语句：SAVEPOINT，ROLLBACK，SET TRANSACTION</li>
</ul>
</li>
</ul>
<h1 id="锁的粒度"><a href="#锁的粒度" class="headerlink" title="锁的粒度"></a>锁的粒度</h1><h2 id="全局锁"><a href="#全局锁" class="headerlink" title="全局锁"></a>全局锁</h2><p>顾名思义就是对整个数据库实例加锁，MySQL提供了一个全局读锁（命令：Flush tables with read lock）FTWRL。让整个数据库处于只读状态<br>效果：阻塞数据更新语句（数据的增删改），数据定义语句（创建/修改表结构），更新类事务的提交语句<br>使用场景：做全库备份（整个库每个表都select出来存成文本）<br>全库备份：当表的引擎支持一致性读（例如Innodb）就可以开启一个事务，来一致性读，做全表备份<br>风险：整个库陷入只读</p>
<h2 id="表级锁"><a href="#表级锁" class="headerlink" title="表级锁"></a>表级锁</h2><p>MySQL表级锁有两种</p>
<ul>
<li>表锁（数据库引擎不支持行锁时使用）</li>
<li>元数据锁（MDL）</li>
</ul>
<p>表锁：lock tables … read/write 释放锁的方法 unlock tables/客户端断开时自动释放<br>不仅限制其他线程操作，对当前线程的操作也会有影响（例如read也会影响当前线程对表的update）</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">begin</span>;</span><br><span class="line">lock tables t read;</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t <span class="keyword">where</span> id <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"><span class="comment">-- 在释放表锁之前，当前线程的更新操作会报错</span></span><br><span class="line"><span class="comment">-- 报 Table &#x27;t&#x27; was locked with a READ lock and can&#x27;t be updated</span></span><br><span class="line">update t <span class="keyword">set</span> a <span class="operator">=</span> <span class="number">2</span> <span class="keyword">where</span> id <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">unlock tables;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 而另一个线程的更新语句会被阻塞住（不报错）</span></span><br><span class="line">update t <span class="keyword">set</span> a <span class="operator">=</span> <span class="number">1</span> <span class="keyword">where</span> id <span class="operator">=</span> <span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<p>MDL锁。不需要显示声明，在访问表时会自动加上。作用是保证读写的正确性，不允许有线程访问表的时候，其他线程对表有结构变更<br>在MySQL5.5中引入，当对一个表进行增删改查操纵时，上MDL读锁，对表结构进行变更的时候，上MDL写锁<br>读锁不互斥，读写/写写互斥<br>关于读写锁引发的一个问题（查询语句频繁导致数据库线程被耗尽）<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://bb3e216f.onedrive-cf-index-ng-e34.pages.dev/api/raw?path=/Public/BlogImg/MySQL/MySQL%E9%94%81%E4%BA%8B%20demo.png"
                      alt="MySQL锁事 demo.png"
                ><br>为什么sessionc的写锁在没有获取到锁的时候，也会阻塞sessiond的读锁 <a class="link"   href="https://blog.csdn.net/q2878948/article/details/96430129" >参考链接<i class="fas fa-external-link-alt"></i></a><br>结论：申请MDL锁的操作会形成一个队列，队列中写锁获取优先级高于读锁。一旦出现写锁等待，不但当前操作会被阻塞，同时还会阻塞后续该表的所有操作。事务一旦申请到MDL锁后，直到事务执行完才会将锁释放。<br>既然锁表风险那么大，但是不锁表又不能搞定操作期间dml（数据库操作语句）语句的影响，那么有什么办法呢？<br>online ddl解决更新表期间导致dml阻塞的问题<br><strong>online ddl （</strong>1、2、4、5如果没有锁冲突，执行时间非常短。第3步占用了DDL绝大部分时间，这期间这个表可以正常读写数据，是因此称为“online ” 上面的例子在第一步就锁住了 <strong>)</strong></p>
<ol>
<li>拿MDL写锁</li>
<li>降级成MDL读锁</li>
<li>真正做DDL</li>
<li>升级成MDL写锁</li>
<li>释放MDL锁<br>或者ddl时，设置超时时间，当到了指定时间自动放弃，稍后重试<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- MariaDB整合了AliSQL的整个功能</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> tbl_name NOWAIT <span class="keyword">add</span> <span class="keyword">column</span> ...</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> tbl_name WAIT N <span class="keyword">add</span> <span class="keyword">column</span> ...</span><br></pre></td></tr></table></figure>
<a class="link"   href="https://blog.csdn.net/q2878948/article/details/96430129" >
<i class="fas fa-external-link-alt"></i></a><h2 id="行锁（存储引擎实现）"><a href="#行锁（存储引擎实现）" class="headerlink" title="行锁（存储引擎实现）"></a>行锁（存储引擎实现）</h2>此处讲 Innodb 的行锁<br>行锁两阶段协议：<strong>Innodb事务中，行锁在需要时才加上，等待事务结束时才释放</strong><h2 id="间隙锁（GapLock-防止幻读）"><a href="#间隙锁（GapLock-防止幻读）" class="headerlink" title="间隙锁（GapLock 防止幻读）"></a>间隙锁（GapLock 防止幻读）</h2>在可重复读隔离级别下生效</li>
</ol>
<p><strong>跟间隙锁存在冲突关系的，是“往这个间隙中插入一个记录”这个操作</strong>。间隙锁之间都不存在冲突关系<br>间隙锁+行锁合称为next-key lock 前开后闭的区间</p>
<h3 id="加锁的规则"><a href="#加锁的规则" class="headerlink" title="加锁的规则"></a>加锁的规则</h3><ul>
<li>原则 1：加锁的基本单位是 next-key lock。next-key lock 是前开后闭区间</li>
<li>原则2：查找过程中访问到的对象才会加锁</li>
<li>优化 1：索引上的等值查询，给唯一索引加锁的时候，next-key lock 退化为行锁。</li>
<li>优化 2：索引上的等值查询，向右遍历时且最后一个值不满足等值条件的时候，next-key lock 退化为间隙锁。</li>
<li>一个 bug：唯一索引上的范围查询会访问到不满足条件的第一个值为止。</li>
</ul>
<h3 id="日常使用的注意点"><a href="#日常使用的注意点" class="headerlink" title="日常使用的注意点"></a>日常使用的注意点</h3><p>select … lock in share mode; 要考虑到覆盖索引的情况，不回表，就不会对聚簇索引上间隙锁<br>select … for update; 系统会认为接下来会更新数据，就会顺便把聚簇索引也给锁上</p>
<h2 id="死锁与死锁检测"><a href="#死锁与死锁检测" class="headerlink" title="死锁与死锁检测"></a>死锁与死锁检测</h2><p>事务之间互相等待对方持有的锁，导致发生死锁。出现死锁两个解决的策略</p>
<ul>
<li>直接进入超时等待，直到超时。可以通过参数 innodb_lock_wait_time 来设置（默认50s）</li>
<li>发起死锁检测，主动回滚死锁链条中的某一个事务，让其他事务得以继续执行。 通过参数 innodb_deadlock_detect 为 on 来表示开启这个逻辑（将持有最少行级排他锁的事务进行回滚。</li>
</ul>
<p>第一个策略，太长业务不接受，太短容易把正常等待锁的操作误伤。通常还是要使用第二种策略（默认也是开启的）<br>但是死锁检测需要耗费大量CPU资源。每个并发线程都要判断一下会不会因为自己的加入而导致死锁（现象：CPU利用率高，但是执行不了几个事务）</p>
<h1 id="一些名词"><a href="#一些名词" class="headerlink" title="一些名词"></a>一些名词</h1><p>S锁：S 锁，英文为 Shared Lock，中文译作共享锁，有时候我们也称之为读锁，即 Read Lock。<br>X锁：X 锁，英文为 Exclusive Lock，中文译作排他锁，有时候我们也称之为写锁，即 Write Lock。如同它的名字，X 锁是具有排他性的，即一个写锁会阻塞其他的 X 锁和 S 锁。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 排他锁</span></span><br><span class="line"><span class="keyword">select</span> ... <span class="keyword">for</span> update;</span><br><span class="line"><span class="comment">-- 共享锁</span></span><br><span class="line"><span class="keyword">select</span> ... lock <span class="keyword">in</span> share mode;</span><br></pre></td></tr></table></figure>
<p>意向锁 I锁：在申请对应行锁之前，需要在表上申请表级意向锁。如果有了意向锁，只需要判断该意向锁与即将添加的表级锁是否兼容即可。因为意向锁的存在代表了，有行级锁的存在或者即将有行级锁的存在。因而无需遍历整个表，即可获取结果</p>
<ul>
<li><strong>IX，IS是表级锁，不会和行级的X，S锁发生冲突。只会和表级的X，S发生冲突</strong></li>
<li>行级别的X和S按照普通的共享、排他规则即可。所以之前的示例中第2步不会冲突，只要写操作不是同一行，就不会发生冲突。</li>
</ul>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://bb3e216f.onedrive-cf-index-ng-e34.pages.dev/api/raw?path=/Public/BlogImg/MySQL/MySQL%E9%94%81%E4%BA%8B%20%E6%84%8F%E5%90%91%E9%94%81%E7%9B%B8%E5%85%B3.png"
                      alt="MySQL锁事 意向锁相关.png"
                ><br>实际上表级的意向锁，做的目的是为了让我们的dml语句执行期间，不让ddl语句来影响表的结构，也不让用户手动声明的表级锁产生影响</p>
<hr>
<h1 id="一些操作"><a href="#一些操作" class="headerlink" title="一些操作"></a>一些操作</h1><h2 id="查看当前session持有锁的情况"><a href="#查看当前session持有锁的情况" class="headerlink" title="查看当前session持有锁的情况"></a>查看当前session持有锁的情况</h2><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 8.0.13版本 performance_schema.data_locks</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> data_locks;</span><br></pre></td></tr></table></figure>
<p>执行效果<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://bb3e216f.onedrive-cf-index-ng-e34.pages.dev/api/raw?path=/Public/BlogImg/MySQL/MySQL%E9%94%81%E4%BA%8B%20%E6%9F%A5%E7%9C%8B%E5%BD%93%E5%89%8Dsession%E6%98%AF%E5%90%A6%E6%8C%81%E6%9C%89%E9%94%81.png"
                      alt="MySQL锁事 查看当前session是否持有锁.png"
                ></p>
<h2 id="关于上锁"><a href="#关于上锁" class="headerlink" title="关于上锁"></a>关于上锁</h2><h2 id="插入一条记录（多条实际上也是逐条插入操作）"><a href="#插入一条记录（多条实际上也是逐条插入操作）" class="headerlink" title="插入一条记录（多条实际上也是逐条插入操作）"></a>插入一条记录（多条实际上也是逐条插入操作）</h2><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- </span></span><br><span class="line"><span class="keyword">begin</span>;</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> test_insert(id,`name`) <span class="keyword">VALUES</span> (<span class="number">8</span>,<span class="string">&#x27;a&#x27;</span>),(<span class="number">9</span>,<span class="string">&#x27;a&#x27;</span>);</span><br></pre></td></tr></table></figure>
<p>此时只上了一个表级的意向排他锁<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://bb3e216f.onedrive-cf-index-ng-e34.pages.dev/api/raw?path=/Public/BlogImg/MySQL/MySQL%E9%94%81%E4%BA%8B%20%E6%8F%92%E5%85%A5%E4%B8%80%E6%9D%A1%E8%AE%B0%E5%BD%95.png"
                      alt="MySQL锁事 插入一条记录.png"
                ></p>
<h2 id="在上面插入记录的前提下，在插入相同id的记录"><a href="#在上面插入记录的前提下，在插入相同id的记录" class="headerlink" title="在上面插入记录的前提下，在插入相同id的记录"></a>在上面插入记录的前提下，在插入相同id的记录</h2><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- session1 先执行</span></span><br><span class="line"><span class="keyword">begin</span>;</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> test_insert(id,`name`) <span class="keyword">VALUES</span> (<span class="number">8</span>,<span class="string">&#x27;a&#x27;</span>),(<span class="number">9</span>,<span class="string">&#x27;a&#x27;</span>);</span><br><span class="line"><span class="comment">-- session2 后执行</span></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> test_insert(id,`name`) <span class="keyword">VALUES</span> (<span class="number">8</span>,<span class="string">&#x27;a&#x27;</span>),(<span class="number">9</span>,<span class="string">&#x27;a&#x27;</span>);</span><br></pre></td></tr></table></figure>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://bb3e216f.onedrive-cf-index-ng-e34.pages.dev/api/raw?path=/Public/BlogImg/MySQL/MySQL%E9%94%81%E4%BA%8B%20%E6%8F%92%E5%85%A5%E7%9B%B8%E5%90%8C%E7%9A%84id.png"
                      alt="MySQL锁事 插入相同的id.png"
                ><br>会先给session1对应id=8的记录上排他锁，行锁。然后session2等待锁</p>
<h2 id="查询语句-for-update"><a href="#查询语句-for-update" class="headerlink" title="查询语句 for update"></a>查询语句 for update</h2><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> test_insert <span class="keyword">where</span> id <span class="keyword">in</span> (<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>) <span class="keyword">for</span> update;</span><br></pre></td></tr></table></figure>
<p>给表上意向排他锁，给行上排他锁与行锁<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://bb3e216f.onedrive-cf-index-ng-e34.pages.dev/api/raw?path=/Public/BlogImg/MySQL/MySQL%E9%94%81%E4%BA%8B%20selectforupdate.png"
                      alt="MySQL锁事 selectforupdate.png"
                ></p>
<h2 id="查询语句-lock-in-share-mode"><a href="#查询语句-lock-in-share-mode" class="headerlink" title="查询语句 lock in share mode"></a>查询语句 lock in share mode</h2><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> test_insert <span class="keyword">where</span> id <span class="keyword">in</span> (<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>) lock <span class="keyword">in</span> share mode;</span><br></pre></td></tr></table></figure>
<p>给表上意向共享锁，给行上共享锁与行锁<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://bb3e216f.onedrive-cf-index-ng-e34.pages.dev/api/raw?path=/Public/BlogImg/MySQL/MySQL%E9%94%81%E4%BA%8B%20selectlockinsharemode.png"
                      alt="MySQL锁事 selectlockinsharemode.png"
                ></p>
<h2 id="删除一个不存在的行"><a href="#删除一个不存在的行" class="headerlink" title="删除一个不存在的行"></a>删除一个不存在的行</h2><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">begin</span>;</span><br><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> test_insert <span class="keyword">where</span> id <span class="operator">=</span> <span class="number">110</span>;</span><br></pre></td></tr></table></figure>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://bb3e216f.onedrive-cf-index-ng-e34.pages.dev/api/raw?path=/Public/BlogImg/MySQL/MySQL%E9%94%81%E4%BA%8B%20%E5%88%A0%E9%99%A4%E4%B8%8D%E5%AD%98%E5%9C%A8%E7%9A%84%E6%95%B0%E6%8D%AE.png"
                      alt="MySQL锁事 删除不存在的数据.png"
                ><br>对表上了意向排他锁，然后对数据库最大的记录后上了间隙锁（supremum pseudo-record 相当于比数据库中所有的记录都大）<br>此时假如又有记录在插入，比最大的id大。则会阻塞<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://bb3e216f.onedrive-cf-index-ng-e34.pages.dev/api/raw?path=/Public/BlogImg/MySQL/MySQL%E9%94%81%E4%BA%8B%20%E5%88%A0%E9%99%A4%E4%B8%80%E4%B8%AA%E4%B8%8D%E5%AD%98%E5%9C%A8%E8%A1%8C%E6%97%B6%E6%8F%92%E5%85%A5%E4%B8%80%E6%9D%A1%E6%AF%94%E6%9C%80%E5%A4%A7id%E8%BF%98%E5%A4%A7%E7%9A%84%E6%95%B0%E6%8D%AE.png"
                      alt="MySQL锁事 删除一个不存在行时插入一条比最大id还大的数据.png"
                ></p>
<h2 id="删除一个存在的行"><a href="#删除一个存在的行" class="headerlink" title="删除一个存在的行"></a>删除一个存在的行</h2><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://bb3e216f.onedrive-cf-index-ng-e34.pages.dev/api/raw?path=/Public/BlogImg/MySQL/MySQL%E9%94%81%E4%BA%8B%20%E5%88%A0%E9%99%A4%E5%AD%98%E5%9C%A8%E7%9A%84%E6%95%B0%E6%8D%AE.png"
                      alt="MySQL锁事 删除存在的数据.png"
                ><br>表意向排他锁，行排他锁，行锁</p>
<hr>
<h1 id="一些锁上遇到的问题"><a href="#一些锁上遇到的问题" class="headerlink" title="一些锁上遇到的问题"></a>一些锁上遇到的问题</h1><h2 id="并发insert导致死锁的问题"><a href="#并发insert导致死锁的问题" class="headerlink" title="并发insert导致死锁的问题"></a>并发insert导致死锁的问题</h2><p>问题执行的sql：<br>先执行session1的begin与insert语句（第一环节），此时session2，session3执行插入语句（第二环节），session1回滚（第三环节）</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- session1</span></span><br><span class="line"><span class="keyword">begin</span>;</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> test_insert(id,`name`) <span class="keyword">VALUES</span> (<span class="number">1</span>,<span class="string">&#x27;a&#x27;</span>);</span><br><span class="line"><span class="keyword">rollback</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- session2</span></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> test_insert(id,`name`) <span class="keyword">VALUES</span> (<span class="number">1</span>,<span class="string">&#x27;a&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- session3</span></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> test_insert(id,`name`) <span class="keyword">VALUES</span> (<span class="number">1</span>,<span class="string">&#x27;a&#x27;</span>);</span><br></pre></td></tr></table></figure>
<p>第一环节：对表上意向排他锁<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://bb3e216f.onedrive-cf-index-ng-e34.pages.dev/api/raw?path=/Public/BlogImg/MySQL/MySQL%E9%94%81%E4%BA%8B%20%E9%97%AE%E9%A2%98%E5%9B%BE%E7%89%871-1.png"
                      alt="MySQL锁事 问题图片1-1.png"
                ><br>第二环节：<br>session1对表上意向排他锁（第一环节就已经完成），因为有锁竞争，还会对id=1的记录上排他锁和行锁<br>session2/session3对表上意向排他锁，对id=1的记录获取共享锁和行锁（获取不到共享锁和行锁，阻塞）<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://bb3e216f.onedrive-cf-index-ng-e34.pages.dev/api/raw?path=/Public/BlogImg/MySQL/MySQL%E9%94%81%E4%BA%8B%20%E9%97%AE%E9%A2%98%E5%9B%BE%E7%89%871-2.png"
                      alt="MySQL锁事 问题图片1-2.png"
                ><br>第三环节：<br>session1回滚，释放排他锁与行锁<br>session2/session3一个执行成功，另一个报死锁错误<br>查看死锁日志</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">show</span> engine innodb status;</span><br></pre></td></tr></table></figure>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://bb3e216f.onedrive-cf-index-ng-e34.pages.dev/api/raw?path=/Public/BlogImg/MySQL/MySQL%E9%94%81%E4%BA%8B%20%E9%97%AE%E9%A2%98%E5%9B%BE%E7%89%871-3.png"
                      alt="MySQL锁事 问题图片1-3.png"
                ><br>两个session都持有S锁，都想拿X锁，第一个session想拿X锁，发现第二个session持有S锁，等待…第二个也同理，于是就发生了死锁（升级成排他时发现有其他线程持有共享，等待。然后相互等待导致死锁)<br>mysql检测死锁，会回滚其中一个事务</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">------------------------</span></span><br><span class="line">LATEST DETECTED DEADLOCK</span><br><span class="line"><span class="comment">------------------------</span></span><br><span class="line"><span class="number">2022</span><span class="number">-07</span><span class="number">-26</span> <span class="number">15</span>:<span class="number">55</span>:<span class="number">02</span> <span class="number">140021836547840</span></span><br><span class="line"><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span> (<span class="number">1</span>) TRANSACTION:</span><br><span class="line">TRANSACTION <span class="number">1064326</span>, ACTIVE <span class="number">7</span> sec inserting</span><br><span class="line">mysql tables <span class="keyword">in</span> use <span class="number">1</span>, locked <span class="number">1</span></span><br><span class="line">LOCK WAIT <span class="number">4</span> lock struct(s), heap size <span class="number">1128</span>, <span class="number">2</span> <span class="type">row</span> lock(s)</span><br><span class="line">MySQL thread id <span class="number">11</span>, OS thread handle <span class="number">140022177969920</span>, query id <span class="number">1069</span> <span class="number">172.18</span><span class="number">.0</span><span class="number">.1</span> root update</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> test_insert(id,`name`) <span class="keyword">VALUES</span> (<span class="number">1</span>,<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span> (<span class="number">1</span>) HOLDS THE LOCK(S):</span><br><span class="line">RECORD LOCKS space id <span class="number">6</span> page <span class="keyword">no</span> <span class="number">4</span> n bits <span class="number">80</span> index <span class="keyword">PRIMARY</span> <span class="keyword">of</span> <span class="keyword">table</span> `test`.`test_insert` trx id <span class="number">1064326</span> lock mode S locks gap before rec</span><br><span class="line">Record lock, heap <span class="keyword">no</span> <span class="number">12</span> PHYSICAL RECORD: n_fields <span class="number">4</span>; compact format; info bits <span class="number">0</span></span><br><span class="line"> <span class="number">0</span>: len <span class="number">4</span>; hex <span class="number">80000002</span>; <span class="keyword">asc</span>     ;;</span><br><span class="line"> <span class="number">1</span>: len <span class="number">6</span>; hex <span class="number">000000103</span>b36; <span class="keyword">asc</span>     ;<span class="number">6</span>;;</span><br><span class="line"> <span class="number">2</span>: len <span class="number">7</span>; hex <span class="number">82000000870110</span>; <span class="keyword">asc</span>        ;;</span><br><span class="line"> <span class="number">3</span>: <span class="keyword">SQL</span> <span class="keyword">NULL</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span> (<span class="number">1</span>) WAITING <span class="keyword">FOR</span> THIS LOCK <span class="keyword">TO</span> BE GRANTED:</span><br><span class="line">RECORD LOCKS space id <span class="number">6</span> page <span class="keyword">no</span> <span class="number">4</span> n bits <span class="number">80</span> index <span class="keyword">PRIMARY</span> <span class="keyword">of</span> <span class="keyword">table</span> `test`.`test_insert` trx id <span class="number">1064326</span> lock_mode X locks gap before rec <span class="keyword">insert</span> intention waiting</span><br><span class="line">Record lock, heap <span class="keyword">no</span> <span class="number">12</span> PHYSICAL RECORD: n_fields <span class="number">4</span>; compact format; info bits <span class="number">0</span></span><br><span class="line"> <span class="number">0</span>: len <span class="number">4</span>; hex <span class="number">80000002</span>; <span class="keyword">asc</span>     ;;</span><br><span class="line"> <span class="number">1</span>: len <span class="number">6</span>; hex <span class="number">000000103</span>b36; <span class="keyword">asc</span>     ;<span class="number">6</span>;;</span><br><span class="line"> <span class="number">2</span>: len <span class="number">7</span>; hex <span class="number">82000000870110</span>; <span class="keyword">asc</span>        ;;</span><br><span class="line"> <span class="number">3</span>: <span class="keyword">SQL</span> <span class="keyword">NULL</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span> (<span class="number">2</span>) TRANSACTION:</span><br><span class="line">TRANSACTION <span class="number">1064327</span>, ACTIVE <span class="number">4</span> sec inserting</span><br><span class="line">mysql tables <span class="keyword">in</span> use <span class="number">1</span>, locked <span class="number">1</span></span><br><span class="line">LOCK WAIT <span class="number">4</span> lock struct(s), heap size <span class="number">1128</span>, <span class="number">2</span> <span class="type">row</span> lock(s)</span><br><span class="line">MySQL thread id <span class="number">13</span>, OS thread handle <span class="number">140022180951808</span>, query id <span class="number">1073</span> <span class="number">172.18</span><span class="number">.0</span><span class="number">.1</span> root update</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> test_insert(id,`name`) <span class="keyword">VALUES</span> (<span class="number">1</span>,<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span> (<span class="number">2</span>) HOLDS THE LOCK(S):</span><br><span class="line">RECORD LOCKS space id <span class="number">6</span> page <span class="keyword">no</span> <span class="number">4</span> n bits <span class="number">80</span> index <span class="keyword">PRIMARY</span> <span class="keyword">of</span> <span class="keyword">table</span> `test`.`test_insert` trx id <span class="number">1064327</span> lock mode S locks gap before rec</span><br><span class="line">Record lock, heap <span class="keyword">no</span> <span class="number">12</span> PHYSICAL RECORD: n_fields <span class="number">4</span>; compact format; info bits <span class="number">0</span></span><br><span class="line"> <span class="number">0</span>: len <span class="number">4</span>; hex <span class="number">80000002</span>; <span class="keyword">asc</span>     ;;</span><br><span class="line"> <span class="number">1</span>: len <span class="number">6</span>; hex <span class="number">000000103</span>b36; <span class="keyword">asc</span>     ;<span class="number">6</span>;;</span><br><span class="line"> <span class="number">2</span>: len <span class="number">7</span>; hex <span class="number">82000000870110</span>; <span class="keyword">asc</span>        ;;</span><br><span class="line"> <span class="number">3</span>: <span class="keyword">SQL</span> <span class="keyword">NULL</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span> (<span class="number">2</span>) WAITING <span class="keyword">FOR</span> THIS LOCK <span class="keyword">TO</span> BE GRANTED:</span><br><span class="line">RECORD LOCKS space id <span class="number">6</span> page <span class="keyword">no</span> <span class="number">4</span> n bits <span class="number">80</span> index <span class="keyword">PRIMARY</span> <span class="keyword">of</span> <span class="keyword">table</span> `test`.`test_insert` trx id <span class="number">1064327</span> lock_mode X locks gap before rec <span class="keyword">insert</span> intention waiting</span><br><span class="line">Record lock, heap <span class="keyword">no</span> <span class="number">12</span> PHYSICAL RECORD: n_fields <span class="number">4</span>; compact format; info bits <span class="number">0</span></span><br><span class="line"> <span class="number">0</span>: len <span class="number">4</span>; hex <span class="number">80000002</span>; <span class="keyword">asc</span>     ;;</span><br><span class="line"> <span class="number">1</span>: len <span class="number">6</span>; hex <span class="number">000000103</span>b36; <span class="keyword">asc</span>     ;<span class="number">6</span>;;</span><br><span class="line"> <span class="number">2</span>: len <span class="number">7</span>; hex <span class="number">82000000870110</span>; <span class="keyword">asc</span>        ;;</span><br><span class="line"> <span class="number">3</span>: <span class="keyword">SQL</span> <span class="keyword">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span> WE ROLL BACK TRANSACTION (<span class="number">2</span>)</span><br><span class="line"><span class="comment">------------</span></span><br><span class="line">TRANSACTIONS</span><br><span class="line"><span class="comment">------------</span></span><br><span class="line">Trx id counter <span class="number">1064328</span></span><br><span class="line">Purge done <span class="keyword">for</span> trx<span class="string">&#x27;s n:o &lt; 1064325 undo n:o &lt; 0 state: running but idle</span></span><br><span class="line"><span class="string">History list length 3</span></span><br><span class="line"><span class="string">LIST OF TRANSACTIONS FOR EACH SESSION:</span></span><br><span class="line"><span class="string">---TRANSACTION 421497208045512, not started</span></span><br><span class="line"><span class="string">0 lock struct(s), heap size 1128, 0 row lock(s)</span></span><br><span class="line"><span class="string">---TRANSACTION 421497208044704, not started</span></span><br><span class="line"><span class="string">0 lock struct(s), heap size 1128, 0 row lock(s)</span></span><br><span class="line"><span class="string">---TRANSACTION 421497208040664, not started</span></span><br><span class="line"><span class="string">0 lock struct(s), heap size 1128, 0 row lock(s)</span></span><br><span class="line"><span class="string">---TRANSACTION 421497208043896, not started</span></span><br><span class="line"><span class="string">0 lock struct(s), heap size 1128, 0 row lock(s)</span></span><br><span class="line"><span class="string">---TRANSACTION 421497208043088, not started</span></span><br><span class="line"><span class="string">0 lock struct(s), heap size 1128, 0 row lock(s)</span></span><br><span class="line"><span class="string">---TRANSACTION 421497208042280, not started</span></span><br><span class="line"><span class="string">0 lock struct(s), heap size 1128, 0 row lock(s)</span></span><br><span class="line"><span class="string">---TRANSACTION 421497208041472, not started</span></span><br><span class="line"><span class="string">0 lock struct(s), heap size 1128, 0 row lock(s)</span></span><br><span class="line"><span class="string">---TRANSACTION 421497208039856, not started</span></span><br><span class="line"><span class="string">0 lock struct(s), heap size 1128, 0 row lock(s)</span></span><br><span class="line"><span class="string">---TRANSACTION 421497208039048, not started</span></span><br><span class="line"><span class="string">0 lock struct(s), heap size 1128, 0 row lock(s)</span></span><br><span class="line"><span class="string">--------</span></span><br><span class="line"><span class="string">FILE I/O</span></span><br><span class="line"><span class="string">--------</span></span><br><span class="line"><span class="string">I/O thread 0 state: waiting for completed aio requests (insert buffer thread)</span></span><br><span class="line"><span class="string">I/O thread 1 state: waiting for completed aio requests (log thread)</span></span><br><span class="line"><span class="string">I/O thread 2 state: waiting for completed aio requests (read thread)</span></span><br><span class="line"><span class="string">I/O thread 3 state: waiting for completed aio requests (read thread)</span></span><br><span class="line"><span class="string">I/O thread 4 state: waiting for completed aio requests (read thread)</span></span><br><span class="line"><span class="string">I/O thread 5 state: waiting for completed aio requests (read thread)</span></span><br><span class="line"><span class="string">I/O thread 6 state: waiting for completed aio requests (write thread)</span></span><br><span class="line"><span class="string">I/O thread 7 state: waiting for completed aio requests (write thread)</span></span><br><span class="line"><span class="string">I/O thread 8 state: waiting for completed aio requests (write thread)</span></span><br><span class="line"><span class="string">I/O thread 9 state: waiting for completed aio requests (write thread)</span></span><br><span class="line"><span class="string">Pending normal aio reads: [0, 0, 0, 0] , aio writes: [0, 0, 0, 0] ,</span></span><br><span class="line"><span class="string"> ibuf aio reads:, log i/o&#x27;</span>s:, sync i<span class="operator">/</span>o<span class="string">&#x27;s:</span></span><br><span class="line"><span class="string">Pending flushes (fsync) log: 0; buffer pool: 0</span></span><br><span class="line"><span class="string">998 OS file reads, 1042 OS file writes, 750 OS fsyncs</span></span><br><span class="line"><span class="string">0.00 reads/s, 0 avg bytes/read, 0.83 writes/s, 0.77 fsyncs/s</span></span><br></pre></td></tr></table></figure>

<div id="gitalk-container"></div>
<script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

		<script>
		var gitalkConfig = {"clientID":"26b8e6758f16d4524e69","clientSecret":"ecfd9e9a439bcb8a4c4fd21f4677fa102c68b352","repo":"beastmouth.github.io","owner":"beastmouth","admin":["beastmouth"],"distractionFreeMode":false,"createIssueManually":true};
	    gitalkConfig.id = md5(location.pathname);
		var gitalk = new Gitalk(gitalkConfig);
	    gitalk.render("gitalk-container");
	    </script>]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
  </entry>
  <entry>
    <title>Redisson分布式锁</title>
    <url>/2022/08/19/Redisson%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/</url>
    <content><![CDATA[<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;T&gt; <span class="function">RFuture&lt;T&gt; <span class="title">tryLockInnerAsync</span><span class="params">(<span class="keyword">long</span> waitTime, <span class="keyword">long</span> leaseTime, TimeUnit unit, <span class="keyword">long</span> threadId, RedisStrictCommand&lt;T&gt; command)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> evalWriteAsync(getName(), LongCodec.INSTANCE, command,</span><br><span class="line">                          <span class="string">&quot;if (redis.call(&#x27;exists&#x27;, KEYS[1]) == 0) then &quot;</span> +</span><br><span class="line">                          <span class="string">&quot;redis.call(&#x27;hincrby&#x27;, KEYS[1], ARGV[2], 1); &quot;</span> +</span><br><span class="line">                          <span class="string">&quot;redis.call(&#x27;pexpire&#x27;, KEYS[1], ARGV[1]); &quot;</span> +</span><br><span class="line">                          <span class="string">&quot;return nil; &quot;</span> +</span><br><span class="line">                          <span class="string">&quot;end; &quot;</span> +</span><br><span class="line">                          <span class="string">&quot;if (redis.call(&#x27;hexists&#x27;, KEYS[1], ARGV[2]) == 1) then &quot;</span> +</span><br><span class="line">                          <span class="string">&quot;redis.call(&#x27;hincrby&#x27;, KEYS[1], ARGV[2], 1); &quot;</span> +</span><br><span class="line">                          <span class="string">&quot;redis.call(&#x27;pexpire&#x27;, KEYS[1], ARGV[1]); &quot;</span> +</span><br><span class="line">                          <span class="string">&quot;return nil; &quot;</span> +</span><br><span class="line">                          <span class="string">&quot;end; &quot;</span> +</span><br><span class="line">                          <span class="string">&quot;return redis.call(&#x27;pttl&#x27;, KEYS[1]);&quot;</span>,</span><br><span class="line">                          Collections.singletonList(getName()), unit.toMillis(leaseTime), getLockName(threadId));</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>此处的LockName<br>UUID是基于当前时间、计数器（counter）和硬件标识（通常为<a class="link"   href="https://baike.baidu.com/item/%E6%97%A0%E7%BA%BF%E7%BD%91%E5%8D%A1/292243" >无线网卡<i class="fas fa-external-link-alt"></i></a>的<a class="link"   href="https://baike.baidu.com/item/MAC%E5%9C%B0%E5%9D%80/1254181" >MAC地址<i class="fas fa-external-link-alt"></i></a>）等数据计算生成的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> String <span class="title">getLockName</span><span class="params">(<span class="keyword">long</span> threadId)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> id + <span class="string">&quot;:&quot;</span> + threadId;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">this</span>.id = commandExecutor.getConnectionManager().getId();</span><br><span class="line"></span><br><span class="line"><span class="comment">// debug 发现id是一个 uuid</span></span><br><span class="line"><span class="comment">// 所以不会出现不同服务相同线程id对redis分布式锁上锁成功的情况</span></span><br></pre></td></tr></table></figure>

<p>加锁流程图<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://bb3e216f.onedrive-cf-index-ng-e34.pages.dev/api/raw?path=/Public/BlogImg/Redis/Redisson%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%20%E5%8A%A0%E9%94%81%E6%B5%81%E7%A8%8B%E5%9B%BE.png"
                      alt="Redisson分布式锁 加锁流程图.png"
                ></p>
<p>Redisson Lock的效果<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://bb3e216f.onedrive-cf-index-ng-e34.pages.dev/api/raw?path=/Public/BlogImg/Redis/Redisson%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%20%E5%8A%A0%E9%94%81%E6%95%88%E6%9E%9C.png"
                      alt="Redisson分布式锁 加锁效果.png"
                ></p>
<p>watchdog 锁自动续期（默认每次续30s）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">renewExpiration</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ExpirationEntry ee = EXPIRATION_RENEWAL_MAP.get(getEntryName());</span><br><span class="line">    <span class="keyword">if</span> (ee == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Timeout task = commandExecutor.getConnectionManager().newTimeout(<span class="keyword">new</span> TimerTask() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">(Timeout timeout)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">            ExpirationEntry ent = EXPIRATION_RENEWAL_MAP.get(getEntryName());</span><br><span class="line">            <span class="keyword">if</span> (ent == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            Long threadId = ent.getFirstThreadId();</span><br><span class="line">            <span class="keyword">if</span> (threadId == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 锁续期</span></span><br><span class="line">            RFuture&lt;Boolean&gt; future = renewExpirationAsync(threadId);</span><br><span class="line">            future.onComplete((res, e) -&gt; &#123;</span><br><span class="line">                <span class="comment">// 异常</span></span><br><span class="line">                <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    log.error(<span class="string">&quot;Can&#x27;t update lock &quot;</span> + getName() + <span class="string">&quot; expiration&quot;</span>, e);</span><br><span class="line">                    EXPIRATION_RENEWAL_MAP.remove(getEntryName());</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (res) &#123;</span><br><span class="line">                    <span class="comment">// reschedule itself</span></span><br><span class="line">                    <span class="comment">// 续期成功，再提交一个任务</span></span><br><span class="line">                    renewExpiration();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, internalLockLeaseTime / <span class="number">3</span>, TimeUnit.MILLISECONDS);</span><br><span class="line"></span><br><span class="line">    ee.setTimeout(task);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 主要判断就是 这个锁是否在 redis 中存在，如果存在就进行 pexpire 延期</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> RFuture&lt;Boolean&gt; <span class="title">renewExpirationAsync</span><span class="params">(<span class="keyword">long</span> threadId)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> evalWriteAsync(getName(), LongCodec.INSTANCE, RedisCommands.EVAL_BOOLEAN,</span><br><span class="line">                          <span class="string">&quot;if (redis.call(&#x27;hexists&#x27;, KEYS[1], ARGV[2]) == 1) then &quot;</span> +</span><br><span class="line">                          <span class="string">&quot;redis.call(&#x27;pexpire&#x27;, KEYS[1], ARGV[1]); &quot;</span> +</span><br><span class="line">                          <span class="string">&quot;return 1; &quot;</span> +</span><br><span class="line">                          <span class="string">&quot;end; &quot;</span> +</span><br><span class="line">                          <span class="string">&quot;return 0;&quot;</span>,</span><br><span class="line">                          Collections.singletonList(getName()),</span><br><span class="line">                          internalLockLeaseTime, getLockName(threadId));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>Redisson分布式锁安全的原因：<br>首先锁的lockName是根据uuid+当前线程id组合生成，不可能存在重复<br>同时还有一个watch dog自动续期的机制</p>

<div id="gitalk-container"></div>
<script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

		<script>
		var gitalkConfig = {"clientID":"26b8e6758f16d4524e69","clientSecret":"ecfd9e9a439bcb8a4c4fd21f4677fa102c68b352","repo":"beastmouth.github.io","owner":"beastmouth","admin":["beastmouth"],"distractionFreeMode":false,"createIssueManually":true};
	    gitalkConfig.id = md5(location.pathname);
		var gitalk = new Gitalk(gitalkConfig);
	    gitalk.render("gitalk-container");
	    </script>]]></content>
      <categories>
        <category>Redis</category>
      </categories>
  </entry>
  <entry>
    <title>Redisson限流器（RateLimiter）</title>
    <url>/2022/12/26/Redisson%E9%99%90%E6%B5%81%E5%99%A8%EF%BC%88RateLimiter%EF%BC%89/</url>
    <content><![CDATA[<h3 id="尝试获取令牌lua脚本解析"><a href="#尝试获取令牌lua脚本解析" class="headerlink" title="尝试获取令牌lua脚本解析"></a>尝试获取令牌lua脚本解析</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">return</span> commandExecutor.evalWriteAsync(getName(), LongCodec.INSTANCE, command,</span><br><span class="line">    <span class="comment">// 获取缓存中的rate（令牌）</span></span><br><span class="line">    <span class="string">&quot;local rate = redis.call(&#x27;hget&#x27;, KEYS[1], &#x27;rate&#x27;);&quot;</span></span><br><span class="line">    <span class="comment">// 获取缓存中的interval（时间间隔）</span></span><br><span class="line">  + <span class="string">&quot;local interval = redis.call(&#x27;hget&#x27;, KEYS[1], &#x27;interval&#x27;);&quot;</span></span><br><span class="line">  <span class="comment">// 获取缓存中的type</span></span><br><span class="line">  + <span class="string">&quot;local type = redis.call(&#x27;hget&#x27;, KEYS[1], &#x27;type&#x27;);&quot;</span></span><br><span class="line">  + <span class="string">&quot;assert(rate ~= false and interval ~= false and type ~= false, &#x27;RateLimiter is not initialized&#x27;)&quot;</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">// &#123;lotus:sale:dashboard:exportRateLimiter&#125;:value</span></span><br><span class="line">  + <span class="string">&quot;local valueName = KEYS[2];&quot;</span></span><br><span class="line">  <span class="comment">// &#123;lotus:sale:dashboard:exportRateLimiter&#125;:permits</span></span><br><span class="line">  + <span class="string">&quot;local permitsName = KEYS[4];&quot;</span></span><br><span class="line">  <span class="comment">// 如果type=1，要加上对应客户端的后缀</span></span><br><span class="line">  + <span class="string">&quot;if type == &#x27;1&#x27; then &quot;</span></span><br><span class="line">      + <span class="string">&quot;valueName = KEYS[3];&quot;</span></span><br><span class="line">      + <span class="string">&quot;permitsName = KEYS[5];&quot;</span></span><br><span class="line">  + <span class="string">&quot;end;&quot;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 如果缓存中的令牌数量&gt;=用户要获取的令牌数量，才可以继续</span></span><br><span class="line">  + <span class="string">&quot;assert(tonumber(rate) &gt;= tonumber(ARGV[1]), &#x27;Requested permits amount could not exceed defined rate&#x27;); &quot;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 获取当前已经有的令牌数量</span></span><br><span class="line">  + <span class="string">&quot;local currentValue = redis.call(&#x27;get&#x27;, valueName); &quot;</span></span><br><span class="line">  <span class="comment">// 当前已经有的令牌数量存在</span></span><br><span class="line">  + <span class="string">&quot;if currentValue ~= false then &quot;</span></span><br><span class="line">         <span class="comment">// 从0到当前时间-时间范围 分支下的 数量（过期的数据）</span></span><br><span class="line">         + <span class="string">&quot;local expiredValues = redis.call(&#x27;zrangebyscore&#x27;, permitsName, 0, tonumber(ARGV[2]) - interval); &quot;</span></span><br><span class="line">         + <span class="string">&quot;local released = 0; &quot;</span></span><br><span class="line">         + <span class="string">&quot;for i, v in ipairs(expiredValues) do &quot;</span></span><br><span class="line">              <span class="comment">// 拆封，获取 随机数 和 需要归还的数量</span></span><br><span class="line">              + <span class="string">&quot;local random, permits = struct.unpack(&#x27;fI&#x27;, v);&quot;</span></span><br><span class="line">              + <span class="string">&quot;released = released + permits;&quot;</span></span><br><span class="line">         + <span class="string">&quot;end; &quot;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 说明有已经过期的数据，需要删除</span></span><br><span class="line">         + <span class="string">&quot;if released &gt; 0 then &quot;</span></span><br><span class="line">              + <span class="string">&quot;redis.call(&#x27;zremrangebyscore&#x27;, permitsName, 0, tonumber(ARGV[2]) - interval); &quot;</span></span><br><span class="line">              <span class="comment">// 增加当前可用的令牌数量</span></span><br><span class="line">              + <span class="string">&quot;currentValue = tonumber(currentValue) + released; &quot;</span></span><br><span class="line">              + <span class="string">&quot;redis.call(&#x27;set&#x27;, valueName, currentValue);&quot;</span></span><br><span class="line">         + <span class="string">&quot;end;&quot;</span></span><br><span class="line"></span><br><span class="line">         <span class="comment">// 当前可用的令牌数量 &lt; 要获取的数量</span></span><br><span class="line">         + <span class="string">&quot;if tonumber(currentValue) &lt; tonumber(ARGV[1]) then &quot;</span></span><br><span class="line">             <span class="comment">// 获取最近的要过期的信息</span></span><br><span class="line">             + <span class="string">&quot;local nearest = redis.call(&#x27;zrangebyscore&#x27;, permitsName, &#x27;(&#x27; .. (tonumber(ARGV[2]) - interval), &#x27;+inf&#x27;, &#x27;withscores&#x27;, &#x27;limit&#x27;, 0, 1); &quot;</span></span><br><span class="line">             + <span class="string">&quot;local random, permits = struct.unpack(&#x27;fI&#x27;, nearest[1]);&quot;</span></span><br><span class="line">             <span class="comment">// 返回多久后再来重试</span></span><br><span class="line">             + <span class="string">&quot;return tonumber(nearest[2]) - (tonumber(ARGV[2]) - interval);&quot;</span></span><br><span class="line">         <span class="comment">// 当前可用的令牌数量 &gt;= 要获取的数量</span></span><br><span class="line">         + <span class="string">&quot;else &quot;</span></span><br><span class="line">             <span class="comment">// 加入到 permits 获取成功的</span></span><br><span class="line">             + <span class="string">&quot;redis.call(&#x27;zadd&#x27;, permitsName, ARGV[2], struct.pack(&#x27;fI&#x27;, ARGV[3], ARGV[1])); &quot;</span></span><br><span class="line">             <span class="comment">// 减少可用的令牌数</span></span><br><span class="line">             + <span class="string">&quot;redis.call(&#x27;decrby&#x27;, valueName, ARGV[1]); &quot;</span></span><br><span class="line">             + <span class="string">&quot;return nil; &quot;</span></span><br><span class="line">         + <span class="string">&quot;end; &quot;</span></span><br><span class="line">    <span class="comment">// 当前已经有的令牌数量不存在</span></span><br><span class="line">  + <span class="string">&quot;else &quot;</span></span><br><span class="line">         + <span class="string">&quot;redis.call(&#x27;set&#x27;, valueName, rate); &quot;</span></span><br><span class="line">         <span class="comment">// struct.pack(&#x27;fI&#x27;, ARGV[3], ARGV[1]) 对参数进行包装</span></span><br><span class="line">         + <span class="string">&quot;redis.call(&#x27;zadd&#x27;, permitsName, ARGV[2], struct.pack(&#x27;fI&#x27;, ARGV[3], ARGV[1])); &quot;</span></span><br><span class="line">         + <span class="string">&quot;redis.call(&#x27;decrby&#x27;, valueName, ARGV[1]); &quot;</span></span><br><span class="line">         + <span class="string">&quot;return nil; &quot;</span></span><br><span class="line">  + <span class="string">&quot;end;&quot;</span>,</span><br><span class="line"><span class="comment">// 参数解析</span></span><br><span class="line"><span class="comment">// key &#123;key&#125;:value &#123;key&#125;:value:clientId &#123;key&#125;:permits &#123;key&#125;:permits:clientId</span></span><br><span class="line"><span class="comment">// 1 当前时间戳 随机数</span></span><br><span class="line">Arrays.asList(getName(), getValueName(), getClientValueName(), getPermitsName(), getClientPermitsName()),</span><br><span class="line">                value, System.currentTimeMillis(), ThreadLocalRandom.current().nextLong());</span><br></pre></td></tr></table></figure>

<p>令牌桶配置（每分钟产生一个令牌）</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://bb3e216f.onedrive-cf-index-ng-e34.pages.dev/api/raw?path=/Public/BlogImg/Redis/Redisson%E9%99%90%E6%B5%81%E5%99%A8%20%E9%99%90%E6%B5%81%E5%99%A8%E9%85%8D%E7%BD%AE.png"
                      alt="Redisson限流器 限流器配置.png"
                ></p>
<p>令牌桶占用情况</p>
<p>分值：当时的时间</p>
<p>元素：随机数+申请的数量，二进制内容</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://bb3e216f.onedrive-cf-index-ng-e34.pages.dev/api/raw?path=/Public/BlogImg/Redis/Redisson%E9%99%90%E6%B5%81%E5%99%A8%20%E4%BB%A4%E7%89%8C%E5%8D%A0%E7%94%A8%E6%83%85%E5%86%B5.png"
                      alt="Redisson限流器 令牌占用情况.png"
                ></p>
<p>剩余可用的令牌数</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://bb3e216f.onedrive-cf-index-ng-e34.pages.dev/api/raw?path=/Public/BlogImg/Redis/Redisson%E9%99%90%E6%B5%81%E5%99%A8%20%E5%BD%93%E5%89%8D%E5%8F%AF%E7%94%A8%E4%BB%A4%E7%89%8C.png"
                      alt="Redisson限流器 当前可用令牌.png"
                ></p>

<div id="gitalk-container"></div>
<script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

		<script>
		var gitalkConfig = {"clientID":"26b8e6758f16d4524e69","clientSecret":"ecfd9e9a439bcb8a4c4fd21f4677fa102c68b352","repo":"beastmouth.github.io","owner":"beastmouth","admin":["beastmouth"],"distractionFreeMode":false,"createIssueManually":true};
	    gitalkConfig.id = md5(location.pathname);
		var gitalk = new Gitalk(gitalkConfig);
	    gitalk.render("gitalk-container");
	    </script>]]></content>
      <categories>
        <category>Redis</category>
      </categories>
  </entry>
  <entry>
    <title>Redis缓存一致性设计</title>
    <url>/2021/12/30/Redis%E7%BC%93%E5%AD%98%E4%B8%80%E8%87%B4%E6%80%A7%E8%AE%BE%E8%AE%A1/</url>
    <content><![CDATA[<h1 id="一致性问题是如何产生的？"><a href="#一致性问题是如何产生的？" class="headerlink" title="一致性问题是如何产生的？"></a>一致性问题是如何产生的？</h1><p>首先先抽象我们日常的几个缓存和数据库CRUD的方法</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">getFromDB(key)</span><br><span class="line"></span><br><span class="line">getFromRedis(key)</span><br><span class="line"></span><br><span class="line">putToDB(key,value)</span><br><span class="line"></span><br><span class="line">putToRedis(key,value)</span><br><span class="line"></span><br><span class="line">deleteFromDB(key)</span><br><span class="line"></span><br><span class="line">deleteFromRedis(key)</span><br></pre></td></tr></table></figure>

<ol>
<li> 利用缓存读取数据原因，一般情况下，Redis的操作速度比数据库操作数据要快上很多（因为Redis是基于内存的）</li>
<li> 而数据最终要放到数据库中，是因为Redis并不适合作为落地存储的</li>
</ol>
<p>那么，假如我们既要持久化数据，又要快速的读数据。那么，就必须要将Redis和数据库一起使用起来</p>
<p>假如我们即要使用Redis，又要使用数据库，他们分别属于两个系统，那么我们就不能保证Redis的操作和数据库的操作和在一起是原子性的，那么就会存在<strong>数据一致性问题</strong></p>
<p>举个例子：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public void putValue(String key,String value)&#123;</span><br><span class="line"> 	putToRedis(key,value);</span><br><span class="line">    putToDB(key,value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>假如在往Redis放数据成功，往数据库放数据失败，造成回滚，此时无法回滚Redis的数据，就会出现数据不一致的问题</p>
<p>那么假如把Redis和数据库的操作反过来，能够解决这个问题吗？ 同样也是不能的</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public void putValue(String key,String value)&#123;</span><br><span class="line">    putToDB(key,value);</span><br><span class="line"> 	putToRedis(key,value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>假设一个并发场景</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://bb3e216f.onedrive-cf-index-ng-e34.pages.dev/api/raw?path=/Public/BlogImg/Redis/Redis%E7%BC%93%E5%AD%98%E4%B8%80%E8%87%B4%E6%80%A7%E8%AE%BE%E8%AE%A1%20redis1.jpeg"
                      alt="Redis缓存一致性设计 redis1.jpeg"
                ></p>
<p>此时，Redis数据理应为线程2操作后的数据，但是我们并不能控制这两个操作的先后执行顺序，导致Redis中的数据是线程1操作后的数据</p>
<p>那么，换一种思路，假如我们不更新缓存，而是删除缓存，在用户查询时，如果缓存中没有数据就去数据库中获取，这样会有问题吗</p>
<p>先删缓存，再更新数据库</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public void putValue(String key,String value)&#123;</span><br><span class="line">    deleteFromRedis(key);</span><br><span class="line">    putToDB(key,value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>就跟上一张图一样，在线程1删除缓存后，数据库还没有来得及更新，此时线程2进入，查询到数据库中的值，设置到缓存中。那么缓存中的数据永远都是不一致的数据</p>
<p>同时这样也会存在缓存击穿的问题，在线程2将数据设置到缓存之前，所有的请求都会被打到数据库中</p>
<p>那么再换一种思路，<strong>先更新数据库，再删缓存可以吗（前后双删同理）</strong></p>
<p>在并发不高的场景下，还是满足的</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public void putValue(String key,String value)&#123;</span><br><span class="line">    putToDB(key,value);    </span><br><span class="line">    deleteFromRedis(key);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是在高并发的情况下，举个例子（产生条件非常苛刻，在发生并发写的同时，还要并发读，一般业务到达不了这个量级）</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://bb3e216f.onedrive-cf-index-ng-e34.pages.dev/api/raw?path=/Public/BlogImg/Redis/Redis%E7%BC%93%E5%AD%98%E4%B8%80%E8%87%B4%E6%80%A7%E8%AE%BE%E8%AE%A1%20redis2.jpeg"
                      alt="Redis缓存一致性设计 redis2.jpeg"
                ></p>
<h1 id="高并发的不一致问题解决思路"><a href="#高并发的不一致问题解决思路" class="headerlink" title="高并发的不一致问题解决思路"></a>高并发的不一致问题解决思路</h1><h2 id="延时双删"><a href="#延时双删" class="headerlink" title="延时双删"></a>延时双删</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public void putValue(key,value) &#123;</span><br><span class="line">    putToDB(key,value);</span><br><span class="line">    deleteFromRedis(key);</span><br><span class="line"></span><br><span class="line">    ...deleteFromRedis(key,after5sec);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>删除选择的方式也有很多</p>
<ul>
<li>  放在DelayQueue中，但是有JVM宕机导致删除丢失的风险</li>
<li>  放在MQ中，增加编码的复杂性，且又加入了一个新系统，同样有三个系统的一致性问题（虽然可以通过事务消息解决）</li>
</ul>
<h2 id="闪电缓存"><a href="#闪电缓存" class="headerlink" title="闪电缓存"></a>闪电缓存</h2><p>缓存时间设置的非常短，存在缓存击穿的问题</p>
<h2 id="缓存击穿问题"><a href="#缓存击穿问题" class="headerlink" title="缓存击穿问题"></a>缓存击穿问题</h2><p>不管是延时双删，还是闪电缓存，其实他们都会存在一个缓存击穿的问题，那么怎么解决缓存击穿呢？</p>
<ul>
<li>  读操作互斥，使用锁/分布式锁控制</li>
<li>  更新集中，利用定时或者订阅binlog（例如canal）保持最终一致</li>
</ul>
<p>读互斥的思路</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">get(key) &#123;</span><br><span class="line"> 	res = getFromRedis(key);</span><br><span class="line">    if (null == res) &#123;</span><br><span class="line">        lock.lock(...);</span><br><span class="line">        try &#123;</span><br><span class="line">            // 再次读取缓存,即double check</span><br><span class="line">            res = getFromRedis(key);</span><br><span class="line">            if (res == null) &#123;</span><br><span class="line">                res = getFromDB(key);</span><br><span class="line">                if (null != res) &#123;</span><br><span class="line">                    // 设置redis</span><br><span class="line">                 	putToRedis(key, res);   </span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<div id="gitalk-container"></div>
<script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

		<script>
		var gitalkConfig = {"clientID":"26b8e6758f16d4524e69","clientSecret":"ecfd9e9a439bcb8a4c4fd21f4677fa102c68b352","repo":"beastmouth.github.io","owner":"beastmouth","admin":["beastmouth"],"distractionFreeMode":false,"createIssueManually":true};
	    gitalkConfig.id = md5(location.pathname);
		var gitalk = new Gitalk(gitalkConfig);
	    gitalk.render("gitalk-container");
	    </script>]]></content>
      <categories>
        <category>Redis</category>
      </categories>
  </entry>
  <entry>
    <title>Redis过期策略与内存淘汰</title>
    <url>/2023/03/01/Redis%E8%BF%87%E6%9C%9F%E7%AD%96%E7%95%A5%E4%B8%8E%E5%86%85%E5%AD%98%E6%B7%98%E6%B1%B0/</url>
    <content><![CDATA[<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://bb3e216f.onedrive-cf-index-ng-e34.pages.dev/api/raw?path=/Public/BlogImg/Redis/Redis-%E8%BF%87%E6%9C%9F%E7%AD%96%E7%95%A5%E4%B8%8E%E5%86%85%E5%AD%98%E6%B7%98%E6%B1%B0%E7%AD%96%E7%95%A5.png"
                      alt="Redis-过期策略与内存淘汰策略.png"
                ></p>
<h2 id="过期策略"><a href="#过期策略" class="headerlink" title="过期策略"></a>过期策略</h2><p>通常有以下三种：</p>
<p><strong>定时过期：</strong>每个设置过期时间的key都需要创建一个定时器，到过期时间就会立即清除。该策略可以立即清除过期的数据，对内存很友好；但是会占用大量的CPU资源去处理过期的数据，从而影响缓存的响应时间和吞吐量。</p>
<p><strong>惰性过期：</strong>只有当访问一个key时，才会判断该key是否已过期，过期则清除。该策略可以最大化地节省CPU资源，却对内存非常不友好。极端情况可能出现大量的过期key没有再次被访问，从而不会被清除，占用大量内存。</p>
<p><strong>定期过期：</strong>每隔一定的时间，会扫描一定数量的数据库的expires字典中一定数量的key，并清除其中已过期的key。该策略是前两者的一个折中方案。通过调整定时扫描的时间间隔和每次扫描的限定耗时，可以在不同情况下使得CPU和内存资源达到最优的平衡效果。(expires字典会保存所有设置了过期时间的key的过期时间数据，其中key是指向键空间中的某个键的指针，value是该键的毫秒精度的UNIX时间戳表示的过期时间。键空间是指该Redis集群中保存的所有键。)</p>
<p>Redis同时使用了<strong>惰性过期和定期过期两种过期策略</strong>。但是Redis定期删除是随机抽取机制，<strong>不可能扫描删除掉所有的过期Key</strong>。因此需要内存淘汰机制。</p>
<h2 id="内存淘汰策略"><a href="#内存淘汰策略" class="headerlink" title="内存淘汰策略"></a>内存淘汰策略</h2><h3 id="近似的LRU算法"><a href="#近似的LRU算法" class="headerlink" title="近似的LRU算法"></a>近似的LRU算法</h3><p>Redis的LRU算法并非完整的实现。这意味着Redis并没办法选择最佳候选来进行回收，也就是最久未被访问的键。相反它会尝试运行一个近似LRU的算法，通过对少量keys进行取样，然后回收其中一个最好的key（被访问时间较早的）。（每次取样构建一个队列）</p>
<p>不过从Redis 3.0算法已经改进为回收键的候选池子。这改善了算法的性能，使得更加近似真是的LRU算法的行为。（不构建队列）</p>
<h3 id="回收策略"><a href="#回收策略" class="headerlink" title="回收策略"></a>回收策略</h3><p><strong>no-eviction:</strong> 当内存不足以容纳新写入数据时，新写入操作会报错。<br><strong>allkeys-lru：</strong>当内存不足以容纳新写入数据时，在键空间（server.db[i].dict）中，移除最近最少使用的 key（这个是最常用的）。<br><strong>allkeys-random：</strong>当内存不足以容纳新写入数据时，在键空间（server.db[i].dict）中，随机移除某个 key。<br><strong>volatile-lru：</strong>当内存不足以容纳新写入数据时，在设置了过期时间的键空间（server.db[i].expires）中，移除最近最少使用的 key。<br><strong>volatile-random：</strong>当内存不足以容纳新写入数据时，在设置了过期时间的键空间（server.db[i].expires）中，随机移除某个 key。<br><strong>volatile-ttl：</strong>当内存不足以容纳新写入数据时，在设置了过期时间的键空间（server.db[i].expires）中，有更早过期时间的 key 优先移除。</p>
<p>4.0以后新增LFU<br>从 Redis 4.0 开始，提供了一种新的<a class="link"   href="http://antirez.com/news/109" >最不常用的驱逐模式<i class="fas fa-external-link-alt"></i></a>。这种模式在某些情况下可能会更好（提供更好的命中/未命中率），因为使用 LFU Redis 会尝试跟踪项目的访问频率，因此很少使用的会被驱逐，而经常使用的有更高的机会留在记忆中。<br>如果您认为在 LRU，最近访问但实际上几乎从未请求过的项目不会过期，因此风险是驱逐未来更有可能被请求的密钥。LFU没有这个问题，一般来说应该更好地适应不同的访问模式。<br>要配置 LFU 模式，可以使用以下策略：<br><strong>volatile-lfu：</strong>在具有过期集的键中使用近似的 LFU 驱逐。<br><strong>allkeys-lfu：</strong>使用近似的 LFU 驱逐任何密钥。<br>LFU 类似于 LRU：它使用一个概率计数器，称为<a class="link"   href="https://en.wikipedia.org/wiki/Approximate_counting_algorithm" >Morris 计数器<i class="fas fa-external-link-alt"></i></a>，以便使用每个对象仅使用几位来估计对象访问频率，并结合衰减周期，以便计数器随着时间的推移而减少</p>

<div id="gitalk-container"></div>
<script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

		<script>
		var gitalkConfig = {"clientID":"26b8e6758f16d4524e69","clientSecret":"ecfd9e9a439bcb8a4c4fd21f4677fa102c68b352","repo":"beastmouth.github.io","owner":"beastmouth","admin":["beastmouth"],"distractionFreeMode":false,"createIssueManually":true};
	    gitalkConfig.id = md5(location.pathname);
		var gitalk = new Gitalk(gitalkConfig);
	    gitalk.render("gitalk-container");
	    </script>]]></content>
      <categories>
        <category>Redis</category>
      </categories>
  </entry>
  <entry>
    <title>RocketMQ基础篇Broker存储消息</title>
    <url>/2022/08/05/RocketMQ%E5%9F%BA%E7%A1%80%E7%AF%87Broker%E5%AD%98%E5%82%A8%E6%B6%88%E6%81%AF/</url>
    <content><![CDATA[<p>Broker是如何存储消息的</p>
<h1 id="流程图"><a href="#流程图" class="headerlink" title="流程图"></a>流程图</h1><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://s2.loli.net/2022/08/05/vBGlLp89nDX4ubx.png"
                      alt="RocketMQ基础篇 Broker存储消息 流程图.png"
                ></p>
<h1 id="代码解释"><a href="#代码解释" class="headerlink" title="代码解释"></a>代码解释</h1><h2 id="写入CommitLog"><a href="#写入CommitLog" class="headerlink" title="写入CommitLog"></a>写入CommitLog</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> CompletableFuture&lt;PutMessageResult&gt; <span class="title">asyncPutMessage</span><span class="params">(<span class="keyword">final</span> MessageExtBrokerInner msg)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Set the storage time</span></span><br><span class="line">        msg.setStoreTimestamp(System.currentTimeMillis());</span><br><span class="line">        <span class="comment">// Set the message body BODY CRC (consider the most appropriate setting</span></span><br><span class="line">        <span class="comment">// on the client)</span></span><br><span class="line">        msg.setBodyCRC(UtilAll.crc32(msg.getBody()));</span><br><span class="line">        <span class="comment">// Back to Results</span></span><br><span class="line">        AppendMessageResult result = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        StoreStatsService storeStatsService = <span class="keyword">this</span>.defaultMessageStore.getStoreStatsService();</span><br><span class="line"></span><br><span class="line">        String topic = msg.getTopic();</span><br><span class="line">        <span class="keyword">int</span> queueId = msg.getQueueId();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> tranType = MessageSysFlag.getTransactionValue(msg.getSysFlag());</span><br><span class="line">        <span class="keyword">if</span> (tranType == MessageSysFlag.TRANSACTION_NOT_TYPE</span><br><span class="line">                || tranType == MessageSysFlag.TRANSACTION_COMMIT_TYPE) &#123;</span><br><span class="line">            <span class="comment">// Delay Delivery 延时等级 &gt; 0，替换原有的消费主题为 SCHEDULE_TOPIC_XXXX,队列id 为 延时的等级-1</span></span><br><span class="line">            <span class="keyword">if</span> (msg.getDelayTimeLevel() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (msg.getDelayTimeLevel() &gt; <span class="keyword">this</span>.defaultMessageStore.getScheduleMessageService().getMaxDelayLevel()) &#123;</span><br><span class="line">                    msg.setDelayTimeLevel(<span class="keyword">this</span>.defaultMessageStore.getScheduleMessageService().getMaxDelayLevel());</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                topic = TopicValidator.RMQ_SYS_SCHEDULE_TOPIC;</span><br><span class="line">                queueId = ScheduleMessageService.delayLevel2QueueId(msg.getDelayTimeLevel());</span><br><span class="line"></span><br><span class="line">                <span class="comment">// Backup real topic, queueId</span></span><br><span class="line">                MessageAccessor.putProperty(msg, MessageConst.PROPERTY_REAL_TOPIC, msg.getTopic());</span><br><span class="line">                MessageAccessor.putProperty(msg, MessageConst.PROPERTY_REAL_QUEUE_ID, String.valueOf(msg.getQueueId()));</span><br><span class="line">                msg.setPropertiesString(MessageDecoder.messageProperties2String(msg.getProperties()));</span><br><span class="line"></span><br><span class="line">                msg.setTopic(topic);</span><br><span class="line">                msg.setQueueId(queueId);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        InetSocketAddress bornSocketAddress = (InetSocketAddress) msg.getBornHost();</span><br><span class="line">        <span class="keyword">if</span> (bornSocketAddress.getAddress() <span class="keyword">instanceof</span> Inet6Address) &#123;</span><br><span class="line">            msg.setBornHostV6Flag();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        InetSocketAddress storeSocketAddress = (InetSocketAddress) msg.getStoreHost();</span><br><span class="line">        <span class="keyword">if</span> (storeSocketAddress.getAddress() <span class="keyword">instanceof</span> Inet6Address) &#123;</span><br><span class="line">            msg.setStoreHostAddressV6Flag();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        PutMessageThreadLocal putMessageThreadLocal = <span class="keyword">this</span>.putMessageThreadLocal.get();</span><br><span class="line">        PutMessageResult encodeResult = putMessageThreadLocal.getEncoder().encode(msg);</span><br><span class="line">        <span class="keyword">if</span> (encodeResult != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> CompletableFuture.completedFuture(encodeResult);</span><br><span class="line">        &#125;</span><br><span class="line">        msg.setEncodedBuff(putMessageThreadLocal.getEncoder().encoderBuffer);</span><br><span class="line">        PutMessageContext putMessageContext = <span class="keyword">new</span> PutMessageContext(generateKey(putMessageThreadLocal.getKeyBuilder(), msg));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">long</span> elapsedTimeInLock = <span class="number">0</span>;</span><br><span class="line">        MappedFile unlockMappedFile = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 申请 putMessageLock 锁 （将消息存储到CommitLog文件中是串行的）</span></span><br><span class="line">        putMessageLock.lock(); <span class="comment">//spin or ReentrantLock ,depending on store config</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 获取当前可以写入的CommitLog文件</span></span><br><span class="line">            <span class="comment">// CommitLog 存储地址：$&#123;ROCKET_HOME&#125;/store/commitlog 文件默认大小1g。一个文件写满后就再创建另一个文件</span></span><br><span class="line">            MappedFile mappedFile = <span class="keyword">this</span>.mappedFileQueue.getLastMappedFile();</span><br><span class="line">            <span class="keyword">long</span> beginLockTimestamp = <span class="keyword">this</span>.defaultMessageStore.getSystemClock().now();</span><br><span class="line">            <span class="keyword">this</span>.beginTimeInLock = beginLockTimestamp;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Here settings are stored timestamp, in order to ensure an orderly</span></span><br><span class="line">            <span class="comment">// global</span></span><br><span class="line">            msg.setStoreTimestamp(beginLockTimestamp);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//  $&#123;ROCKET_HOME&#125;/store/commitlog 目录下没有任何文件</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">null</span> == mappedFile || mappedFile.isFull()) &#123;</span><br><span class="line">                <span class="comment">// 以偏移量为0 创建commitLog文件</span></span><br><span class="line">                mappedFile = <span class="keyword">this</span>.mappedFileQueue.getLastMappedFile(<span class="number">0</span>); <span class="comment">// Mark: NewFile may be cause noise</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">null</span> == mappedFile) &#123;</span><br><span class="line">                log.error(<span class="string">&quot;create mapped file1 error, topic: &quot;</span> + msg.getTopic() + <span class="string">&quot; clientAddr: &quot;</span> + msg.getBornHostString());</span><br><span class="line">                beginTimeInLock = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">return</span> CompletableFuture.completedFuture(<span class="keyword">new</span> PutMessageResult(PutMessageStatus.CREATE_MAPEDFILE_FAILED, <span class="keyword">null</span>));</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            result = mappedFile.appendMessage(msg, <span class="keyword">this</span>.appendMessageCallback, putMessageContext);</span><br><span class="line">            <span class="keyword">switch</span> (result.getStatus()) &#123;</span><br><span class="line">                <span class="keyword">case</span> PUT_OK:</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> END_OF_FILE:</span><br><span class="line">                    unlockMappedFile = mappedFile;</span><br><span class="line">                    <span class="comment">// Create a new file, re-write the message</span></span><br><span class="line">                    mappedFile = <span class="keyword">this</span>.mappedFileQueue.getLastMappedFile(<span class="number">0</span>);</span><br><span class="line">                    <span class="keyword">if</span> (<span class="keyword">null</span> == mappedFile) &#123;</span><br><span class="line">                        <span class="comment">// <span class="doctag">XXX:</span> warn and notify me</span></span><br><span class="line">                        log.error(<span class="string">&quot;create mapped file2 error, topic: &quot;</span> + msg.getTopic() + <span class="string">&quot; clientAddr: &quot;</span> + msg.getBornHostString());</span><br><span class="line">                        beginTimeInLock = <span class="number">0</span>;</span><br><span class="line">                        <span class="keyword">return</span> CompletableFuture.completedFuture(<span class="keyword">new</span> PutMessageResult(PutMessageStatus.CREATE_MAPEDFILE_FAILED, result));</span><br><span class="line">                    &#125;</span><br><span class="line">                    result = mappedFile.appendMessage(msg, <span class="keyword">this</span>.appendMessageCallback, putMessageContext);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> MESSAGE_SIZE_EXCEEDED:</span><br><span class="line">                <span class="keyword">case</span> PROPERTIES_SIZE_EXCEEDED:</span><br><span class="line">                    beginTimeInLock = <span class="number">0</span>;</span><br><span class="line">                    <span class="keyword">return</span> CompletableFuture.completedFuture(<span class="keyword">new</span> PutMessageResult(PutMessageStatus.MESSAGE_ILLEGAL, result));</span><br><span class="line">                <span class="keyword">case</span> UNKNOWN_ERROR:</span><br><span class="line">                    beginTimeInLock = <span class="number">0</span>;</span><br><span class="line">                    <span class="keyword">return</span> CompletableFuture.completedFuture(<span class="keyword">new</span> PutMessageResult(PutMessageStatus.UNKNOWN_ERROR, result));</span><br><span class="line">                <span class="keyword">default</span>:</span><br><span class="line">                    beginTimeInLock = <span class="number">0</span>;</span><br><span class="line">                    <span class="keyword">return</span> CompletableFuture.completedFuture(<span class="keyword">new</span> PutMessageResult(PutMessageStatus.UNKNOWN_ERROR, result));</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            elapsedTimeInLock = <span class="keyword">this</span>.defaultMessageStore.getSystemClock().now() - beginLockTimestamp;</span><br><span class="line">            beginTimeInLock = <span class="number">0</span>;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// 处理完追加逻辑就会释放锁</span></span><br><span class="line">            putMessageLock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (elapsedTimeInLock &gt; <span class="number">500</span>) &#123;</span><br><span class="line">            log.warn(<span class="string">&quot;[NOTIFYME]putMessage in lock cost time(ms)=&#123;&#125;, bodyLength=&#123;&#125; AppendMessageResult=&#123;&#125;&quot;</span>, elapsedTimeInLock, msg.getBody().length, result);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> != unlockMappedFile &amp;&amp; <span class="keyword">this</span>.defaultMessageStore.getMessageStoreConfig().isWarmMapedFileEnable()) &#123;</span><br><span class="line">            <span class="keyword">this</span>.defaultMessageStore.unlockMappedFile(unlockMappedFile);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        PutMessageResult putMessageResult = <span class="keyword">new</span> PutMessageResult(PutMessageStatus.PUT_OK, result);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Statistics</span></span><br><span class="line">        storeStatsService.getSinglePutMessageTopicTimesTotal(msg.getTopic()).add(<span class="number">1</span>);</span><br><span class="line">        storeStatsService.getSinglePutMessageTopicSizeTotal(topic).add(result.getWroteBytes());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 刷盘</span></span><br><span class="line">        CompletableFuture&lt;PutMessageStatus&gt; flushResultFuture = submitFlushRequest(result, msg);</span><br><span class="line">        <span class="comment">// 此处会处理主从同步的结果（HA）</span></span><br><span class="line">        CompletableFuture&lt;PutMessageStatus&gt; replicaResultFuture = submitReplicaRequest(result, msg);</span><br><span class="line">        <span class="keyword">return</span> flushResultFuture.thenCombine(replicaResultFuture, (flushStatus, replicaStatus) -&gt; &#123;</span><br><span class="line">            <span class="keyword">if</span> (flushStatus != PutMessageStatus.PUT_OK) &#123;</span><br><span class="line">                putMessageResult.setPutMessageStatus(flushStatus);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (replicaStatus != PutMessageStatus.PUT_OK) &#123;</span><br><span class="line">                putMessageResult.setPutMessageStatus(replicaStatus);</span><br><span class="line">                <span class="keyword">if</span> (replicaStatus == PutMessageStatus.FLUSH_SLAVE_TIMEOUT) &#123;</span><br><span class="line">                    log.error(<span class="string">&quot;do sync transfer other node, wait return, but failed, topic: &#123;&#125; tags: &#123;&#125; client address: &#123;&#125;&quot;</span>,</span><br><span class="line">                            msg.getTopic(), msg.getTags(), msg.getBornHostNameString());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> putMessageResult;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>从代码中，我们可以看到写入CommitLog这个操作主要做了以下几件事情</p>
<ol>
<li>设置存储的消息的基本信息<ol>
<li>如果消息是延时消息，会将原有的消息topic替换为 SCHEDULE_TOPIC_XXXX，队列id为延迟等级</li>
</ol>
</li>
<li>申请putMessageLock（该操作确保了只会有一个线程去对CommitLog进行修改）</li>
<li>如果CommitLog不存在或者已经写满，需要创建新的CommitLog</li>
<li>往MappedFile中追加消息（追加消息的时候才会生成消息唯一ID）<ol>
<li>如果文件剩余空间不足，会创建新的文件 （消息长度 + END_FILE_MIN_BLANK_LENGTH &gt; CommitLog文件空闲空间，返回END_OF_FILE）</li>
<li>其他的一些异常</li>
</ol>
</li>
<li>追加完消息，释放锁</li>
</ol>
<p>那么，这边来解释下CommitLog和MappedFile的关系</p>
<h1 id="CommitLog和MappedFile的关系"><a href="#CommitLog和MappedFile的关系" class="headerlink" title="CommitLog和MappedFile的关系"></a>CommitLog和MappedFile的关系</h1><h2 id="CommitLog里面有什么"><a href="#CommitLog里面有什么" class="headerlink" title="CommitLog里面有什么"></a>CommitLog里面有什么</h2><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://s2.loli.net/2022/08/05/WKT8hoinbvclp1S.png"
                      alt="RocketMQ基础篇 Broker存储消息 CommitLog结构.png"
                ><br>CommitLog里面记录了<strong>消息的完整内容</strong>，我们在读取消息的时候，首先先通过前4个字节记录了当前消息的实际长度，然后再往后读对应的长度，就可以将消息完全读取出来<br>CommitLog文件在磁盘中的存储路径 ${ROCKET_HOME}/store/commitlog/</p>
<h2 id="CommitLog和MappedFile的关系-1"><a href="#CommitLog和MappedFile的关系-1" class="headerlink" title="CommitLog和MappedFile的关系"></a>CommitLog和MappedFile的关系</h2><p>RocketMQ<strong>采用内存映射文件的方式来提高IO访问性能</strong>，无论是CommitLog，ConsumeQueue还是IndexFile，单个文件都被设置为固定长度。然后<strong>RocketMQ使用MappedFile和MappedFileQueue来封装存储文件</strong>。具体对MappedFile和MappedFileQueue的概念我会在后面在具体介绍</p>
<h1 id="CommitLog与ConsumeQueue，IndexFile的关系"><a href="#CommitLog与ConsumeQueue，IndexFile的关系" class="headerlink" title="CommitLog与ConsumeQueue，IndexFile的关系"></a>CommitLog与ConsumeQueue，IndexFile的关系</h1><p>既然要探讨ConsumeQueue和IndexFile与CommitLog之间的关系，不如直接来讲一讲这两个文件是干什么用的，从他们的用处中我们也就能够得知<strong>为什么在已经有了CommitLog的情况下，RocketMQ还需要ConsumeQueue和IndexFile这两种文件</strong></p>
<h2 id="ConsumeQueue"><a href="#ConsumeQueue" class="headerlink" title="ConsumeQueue"></a>ConsumeQueue</h2><p>首先，我们来看看ConsumeQueue的结构</p>
<h3 id="ConsumeQueue的结构"><a href="#ConsumeQueue的结构" class="headerlink" title="ConsumeQueue的结构"></a>ConsumeQueue的结构</h3><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://s2.loli.net/2022/08/05/SRnOtWmPr3o8iC9.png"
                      alt="RocketMQ基础篇 Broker存储消息 ConsumeQueue目录结构.png"
                ><br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://s2.loli.net/2022/08/05/odsMgLr3hYliyHk.png"
                      alt="RocketMQ基础篇 Broker存储消息 ConsumeQueue结构.png"
                ><br>从图片中，我们不难看出，RocketMQ对ConsumeQueue的层级目录为<br>ConsumeQueue - 具体的Topic - 具体的某一个队列 - ConsumeQueue的单元 （记录了消息在CommitLog中的偏移量，消息的长度，消息的tags)</p>
<h3 id="为什么需要CommitLog和ConsumeQueue的映射关系"><a href="#为什么需要CommitLog和ConsumeQueue的映射关系" class="headerlink" title="为什么需要CommitLog和ConsumeQueue的映射关系"></a>为什么需要CommitLog和ConsumeQueue的映射关系</h3><p>那么为什么RocketMQ要设计这样的映射关系呢？主要要从两个方面来考虑，同时这两个方面最终的目的也是为了保证RocketMQ的性能</p>
<ul>
<li>写入消息：如果我们没有CommitLog，直接就用一个ConsumeQueue，那么在Producer生产消息给Broker的时候，不同的Topic和队列的消息我们要写到不同的ConsumeQueue文件中。那么就会存在随机写的问题，这样写入消息的效率就会变的非常的低</li>
<li>读取消息：如果为了保证消息的写入效率，我们将消息存放在CommitLog中，但是，在消费者拉取消息的时候，它肯定是要拉取自己感兴趣的Topic的消息。此时，我们去CommitLog中寻找对应的Topic和对应MessageQueue下对应偏移量的消息，挨个去遍历CommitLog一看就是一个效率非常低的操作。此时我们使用ConsumeQueue就可以快速定位到消息处于哪个CommitLog，他对应的偏移量是多少。这样读取消息的效率就会变得非常的高<h3 id="ConsumeQueue的tag-hashcode"><a href="#ConsumeQueue的tag-hashcode" class="headerlink" title="ConsumeQueue的tag hashcode"></a>ConsumeQueue的tag hashcode</h3>这边补充一点，关于ConsumeQueue中的tag hashcode。<br>在RocketMQ中，我们不仅可以监听我们感兴趣的Topic消息，同时我们还可以只监听Topic下部分的消息。这个操作就是通过消息的tag来实现的（一种实现方式，另外还有类过滤和SQL92过滤的方式）<strong>【RocketMQ服务端过滤根据tag的hashcode】</strong><br>在消费者拉取消息的时候，不仅消费者自己会对消息进行过滤，Broker也会根据消费者的情况对消息进行一次预过滤。此处我们就不展开讲述，具体可以消息消费 <a class="link"   href="https://www.yuque.com/huangbangjing/qfdni8/vu3u4d" >Consumer消费消息<i class="fas fa-external-link-alt"></i></a> 的文章</li>
</ul>
<h2 id="IndexFile"><a href="#IndexFile" class="headerlink" title="IndexFile"></a>IndexFile</h2><h3 id="IndexFile的结构"><a href="#IndexFile的结构" class="headerlink" title="IndexFile的结构"></a>IndexFile的结构</h3><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://bb3e216f.onedrive-cf-index-ng-e34.pages.dev/api/raw?path=/Public/BlogImg/RocketMQ/RocketMQ%E5%9F%BA%E7%A1%80%E7%AF%87%20Broker%E5%AD%98%E5%82%A8%E6%B6%88%E6%81%AF%20IndexFile%E7%BB%93%E6%9E%84.png"
                      alt="RocketMQ基础篇 Broker存储消息 IndexFile结构.png"
                ><br>他的目的是为了方便我们根据消息的key快速检索消息，快速检索主要是依靠文件头部的Hash槽。</p>
<h3 id="哈希冲突的解决"><a href="#哈希冲突的解决" class="headerlink" title="哈希冲突的解决"></a>哈希冲突的解决</h3><p>既然说到了hash，那么就一定会存在哈希冲突的情况。那么，IndexFile是如何解决哈希冲突的呢？<br>在我们写IndexFile的时候，假如IndexFile还有足够的空间，那么我们就会对当前这条消息的消息key进行一次哈希计算，假如对应的hash槽中没有记录对应的index条目偏移量，那么直接将偏移量记录到hash槽中。否则这是在Index条目中的pre index no记录原先的偏移量，然后再将这个条目的偏移量记录到hash槽中</p>
<h2 id="对于为什么要设计CommitLog，ConsumeQueue，IndexFile的总结"><a href="#对于为什么要设计CommitLog，ConsumeQueue，IndexFile的总结" class="headerlink" title="对于为什么要设计CommitLog，ConsumeQueue，IndexFile的总结"></a>对于为什么要设计CommitLog，ConsumeQueue，IndexFile的总结</h2><p>因为消费者消费消息的时候，是根据具体的Topic去进行消费的。所以为了加快消费者消费的速度，需要根据具体的Topic去存储消息（ConsumeQueue）。但是如果直接把消息存储在ConsumeQueue，会导致生产者发送的消息Topic不同，出现大量随机写的情况。所以为了提高消费者和生产者的速度。相同的，为了加快对消息key检索消息的速度，所以添加了IndexFile<br>RocketMQ首先先将生产者的消息写入到CommitLog中（顺序写），然后在通过一个异步线程将消息基本信息（偏移量等）写入到ConsumeQueue和IndexFile中</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ReputMessageService</span> <span class="keyword">extends</span> <span class="title">ServiceThread</span> </span>&#123;</span><br><span class="line">	<span class="comment">// ...省略其他代码</span></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	    DefaultMessageStore.log.info(<span class="keyword">this</span>.getServiceName() + <span class="string">&quot; service started&quot;</span>);</span><br><span class="line">	</span><br><span class="line">	    <span class="keyword">while</span> (!<span class="keyword">this</span>.isStopped()) &#123;</span><br><span class="line">	        <span class="keyword">try</span> &#123;</span><br><span class="line">	            <span class="comment">// 每执行一次任务推送休息1毫秒，就继续尝试推送消息到消息消费队列和索引文件</span></span><br><span class="line">	            Thread.sleep(<span class="number">1</span>);</span><br><span class="line">	            <span class="comment">// 消息消费转发核心方法</span></span><br><span class="line">	            <span class="keyword">this</span>.doReput();</span><br><span class="line">	        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">	            DefaultMessageStore.log.warn(<span class="keyword">this</span>.getServiceName() + <span class="string">&quot; service has exception. &quot;</span>, e);</span><br><span class="line">	        &#125;</span><br><span class="line">	    &#125;</span><br><span class="line">	</span><br><span class="line">	    DefaultMessageStore.log.info(<span class="keyword">this</span>.getServiceName() + <span class="string">&quot; service end&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// ...省略其他代码</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 最终调用到该方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doDispatch</span><span class="params">(DispatchRequest req)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// CommitLogDispatcher 有三个实现</span></span><br><span class="line">		<span class="comment">// 其中就有我们用到的 CommitLogDispatcherBuildConsumeQueue 写ConsumeQueue</span></span><br><span class="line">		<span class="comment">// CommitLogDispatcherBuildIndex 写IndexFile</span></span><br><span class="line">    <span class="keyword">for</span> (CommitLogDispatcher dispatcher : <span class="keyword">this</span>.dispatcherList) &#123;</span><br><span class="line">        dispatcher.dispatch(req);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="MappedFile和MappedFileQueue"><a href="#MappedFile和MappedFileQueue" class="headerlink" title="MappedFile和MappedFileQueue"></a>MappedFile和MappedFileQueue</h1><h2 id="MappedFile"><a href="#MappedFile" class="headerlink" title="MappedFile"></a>MappedFile</h2><h3 id="为什么需要MappedFile"><a href="#为什么需要MappedFile" class="headerlink" title="为什么需要MappedFile"></a>为什么需要MappedFile</h3><p>RocketMQ底层使用 mmap + write （零拷贝）的方式减少用户态和内存态的切换次数<br>具体内容参考 <a class="link"   href="https://www.yuque.com/huangbangjing/qfdni8/hurdcg" >mmap解释<i class="fas fa-external-link-alt"></i></a> 这篇文章<br>这里只简单介绍一下：<br>加入没有mmap，我们读取文件需要经历两次数据拷贝，一次是从磁盘拷贝到page cache中，一次从page cache拷贝到用户空间内存。<br>而有了mmap，就<strong>能够减少page cache到用户空间内存的拷贝</strong>，<strong>mmap对page cache和用户空间虚拟地址进行了直接的映射</strong>，<strong>操作虚拟地址就等同于操作page cache</strong></p>
<h2 id="MappedFileQueue"><a href="#MappedFileQueue" class="headerlink" title="MappedFileQueue"></a>MappedFileQueue</h2><p>MappedFileQueue是MappedFile的管理容器，它是对存储目录的封装<br>比如说在CommitLog文件存储目录下有好多个CommitLog文件，对应在内存中也会有好多个MappedFile对象，而MappedFileQueue就是来管理这些MappedFile对象的</p>
<h2 id="MappedFile刷盘操作"><a href="#MappedFile刷盘操作" class="headerlink" title="MappedFile刷盘操作"></a>MappedFile刷盘操作</h2><p>消息刷盘有两种：</p>
<ul>
<li>同步刷盘：只有在消息真正持久化至磁盘后RocketMQ的Broker端才会真正返回给Producer端一个成功的ACK响应。同步刷盘对MQ消息可靠性来说是一种不错的保障，但是性能上会有较大影响，一般适用于金融业务应用该模式较多。</li>
<li>异步刷盘：能够充分利用OS的PageCache的优势，只要消息写入PageCache即可将成功的ACK返回给Producer端。消息刷盘采用后台异步线程提交的方式进行，降低了读写延迟，提高了MQ的性能和吞吐量。</li>
</ul>
<h1 id="RocketMQ定期删除已经消费的消息文件"><a href="#RocketMQ定期删除已经消费的消息文件" class="headerlink" title="RocketMQ定期删除已经消费的消息文件"></a>RocketMQ定期删除已经消费的消息文件</h1><p>另外，RocketMQ会定时将已经消费的消息从存储文件中删除，以CommitLog为例，第一个CommitLog文件的偏移量不一定 00000000000000000000</p>
<h2 id="主干逻辑流程图"><a href="#主干逻辑流程图" class="headerlink" title="主干逻辑流程图"></a>主干逻辑流程图</h2><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://bb3e216f.onedrive-cf-index-ng-e34.pages.dev/api/raw?path=/Public/BlogImg/RocketMQ/RocketMQ%E5%9F%BA%E7%A1%80%E7%AF%87%20Broker%E5%AD%98%E5%82%A8%E6%B6%88%E6%81%AF%20%E5%AE%9A%E6%9C%9F%E5%88%A0%E9%99%A4CommitLog.png"
                      alt="RocketMQ基础篇 Broker存储消息 定期删除CommitLog.png"
                ></p>
<h2 id="对应源码和注释"><a href="#对应源码和注释" class="headerlink" title="对应源码和注释"></a>对应源码和注释</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 默认每个文件过期时间为72小时，通过Broker配置文件中设置fileReservedTime来改变</span></span><br><span class="line"><span class="comment">// 如果非当前写文件在一定时间间隔内没有再次被更新，则会被认为是过期文件，可以被删除（RocketMQ不会关注这个文件上的消息是否被全部消费）</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">deleteExpiredFiles</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> deleteCount = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 文件保留时间 72小时</span></span><br><span class="line">    <span class="keyword">long</span> fileReservedTime = DefaultMessageStore.<span class="keyword">this</span>.getMessageStoreConfig().getFileReservedTime();</span><br><span class="line">    <span class="comment">// 删除物理文件的间隔（在一次清除过程中，可能需要删除的文件不止一个，该值指定两次删除文件的时间间隔）</span></span><br><span class="line">    <span class="keyword">int</span> deletePhysicFilesInterval = DefaultMessageStore.<span class="keyword">this</span>.getMessageStoreConfig().getDeleteCommitLogFilesInterval();</span><br><span class="line">    <span class="comment">// 在清除过期文件时，如果该文件被其他线程所占用（引用次数大于0，比如读取消息），此时会阻止此次删除任务</span></span><br><span class="line">    <span class="comment">// 同时在第一次试图删除该文件时记录当前时间戳 destroyMapedFileIntervalForcibly 表示第一次拒绝删除之后能保留的最大时间</span></span><br><span class="line">    <span class="comment">// 在此时间内，同样可以被拒绝删除，同时会将引用减少1000个，超过该时间间隔后，文件将被强制删除</span></span><br><span class="line">    <span class="keyword">int</span> destroyMapedFileIntervalForcibly = DefaultMessageStore.<span class="keyword">this</span>.getMessageStoreConfig().getDestroyMapedFileIntervalForcibly();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 指定删除文件的时间点</span></span><br><span class="line">    <span class="keyword">boolean</span> timeup = <span class="keyword">this</span>.isTimeToDelete();</span><br><span class="line">    <span class="comment">// 磁盘空间满了</span></span><br><span class="line">    <span class="keyword">boolean</span> spacefull = <span class="keyword">this</span>.isSpaceToDelete();</span><br><span class="line">    <span class="keyword">boolean</span> manualDelete = <span class="keyword">this</span>.manualDeleteFileSeveralTimes &gt; <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (timeup || spacefull || manualDelete) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (manualDelete)</span><br><span class="line">            <span class="keyword">this</span>.manualDeleteFileSeveralTimes--;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">boolean</span> cleanAtOnce = DefaultMessageStore.<span class="keyword">this</span>.getMessageStoreConfig().isCleanFileForciblyEnable() &amp;&amp; <span class="keyword">this</span>.cleanImmediately;</span><br><span class="line"></span><br><span class="line">        log.info(<span class="string">&quot;begin to delete before &#123;&#125; hours file. timeup: &#123;&#125; spacefull: &#123;&#125; manualDeleteFileSeveralTimes: &#123;&#125; cleanAtOnce: &#123;&#125;&quot;</span>,</span><br><span class="line">                 fileReservedTime,</span><br><span class="line">                 timeup,</span><br><span class="line">                 spacefull,</span><br><span class="line">                 manualDeleteFileSeveralTimes,</span><br><span class="line">                 cleanAtOnce);</span><br><span class="line"></span><br><span class="line">        fileReservedTime *= <span class="number">60</span> * <span class="number">60</span> * <span class="number">1000</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 清除过期文件</span></span><br><span class="line">        deleteCount = DefaultMessageStore.<span class="keyword">this</span>.commitLog.deleteExpiredFile(fileReservedTime, deletePhysicFilesInterval,</span><br><span class="line">                                                                           destroyMapedFileIntervalForcibly, cleanAtOnce);</span><br><span class="line">        <span class="keyword">if</span> (deleteCount &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (spacefull) &#123;</span><br><span class="line">            log.warn(<span class="string">&quot;disk space will be full soon, but delete file failed.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">deleteExpiredFileByTime</span><span class="params">(<span class="keyword">final</span> <span class="keyword">long</span> expiredTime,</span></span></span><br><span class="line"><span class="params"><span class="function">                                   <span class="keyword">final</span> <span class="keyword">int</span> deleteFilesInterval,</span></span></span><br><span class="line"><span class="params"><span class="function">                                   <span class="keyword">final</span> <span class="keyword">long</span> intervalForcibly,</span></span></span><br><span class="line"><span class="params"><span class="function">                                   <span class="keyword">final</span> <span class="keyword">boolean</span> cleanImmediately)</span> </span>&#123;</span><br><span class="line">    Object[] mfs = <span class="keyword">this</span>.copyMappedFiles(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">null</span> == mfs)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从倒数第二个文件开始</span></span><br><span class="line">    <span class="keyword">int</span> mfsLength = mfs.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> deleteCount = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 通过MappedFile，没有磁盘i/o的情况</span></span><br><span class="line">    List&lt;MappedFile&gt; files = <span class="keyword">new</span> ArrayList&lt;MappedFile&gt;();</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">null</span> != mfs) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; mfsLength; i++) &#123;</span><br><span class="line">            MappedFile mappedFile = (MappedFile) mfs[i];</span><br><span class="line">            <span class="comment">// 文件最大存活时间=文件的最后一次更新时间+文件存活时间(默认72小时)</span></span><br><span class="line">            <span class="keyword">long</span> liveMaxTimestamp = mappedFile.getLastModifiedTimestamp() + expiredTime;</span><br><span class="line">            <span class="comment">// 当前时间&gt;=最大存活时间 或 需要立即删除</span></span><br><span class="line">            <span class="keyword">if</span> (System.currentTimeMillis() &gt;= liveMaxTimestamp || cleanImmediately) &#123;</span><br><span class="line">                <span class="comment">// 删除文件(将该文件加入到待删除文件列表中，然后统一执行File#delete方法将文件从物理磁盘中删除)</span></span><br><span class="line">                <span class="keyword">if</span> (mappedFile.destroy(intervalForcibly)) &#123;</span><br><span class="line">                    files.add(mappedFile);</span><br><span class="line">                    deleteCount++;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (files.size() &gt;= DELETE_FILES_BATCH_MAX) &#123;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (deleteFilesInterval &gt; <span class="number">0</span> &amp;&amp; (i + <span class="number">1</span>) &lt; mfsLength) &#123;</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            Thread.sleep(deleteFilesInterval);</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//avoid deleting files in the middle</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    deleteExpiredFile(files);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> deleteCount;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<div id="gitalk-container"></div>
<script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

		<script>
		var gitalkConfig = {"clientID":"26b8e6758f16d4524e69","clientSecret":"ecfd9e9a439bcb8a4c4fd21f4677fa102c68b352","repo":"beastmouth.github.io","owner":"beastmouth","admin":["beastmouth"],"distractionFreeMode":false,"createIssueManually":true};
	    gitalkConfig.id = md5(location.pathname);
		var gitalk = new Gitalk(gitalkConfig);
	    gitalk.render("gitalk-container");
	    </script>]]></content>
      <categories>
        <category>RocketMQ</category>
      </categories>
  </entry>
  <entry>
    <title>RocketMQ基础篇Consumer消费消息</title>
    <url>/2022/08/05/RocketMQ%E5%9F%BA%E7%A1%80%E7%AF%87Consumer%E6%B6%88%E8%B4%B9%E6%B6%88%E6%81%AF/</url>
    <content><![CDATA[<h1 id="消费消息逻辑"><a href="#消费消息逻辑" class="headerlink" title="消费消息逻辑"></a>消费消息逻辑</h1><p>消费消息逻辑主要分为三个模块</p>
<ul>
<li>Rebalance</li>
<li>拉取消息</li>
<li>消费消息<h1 id="Rebalance"><a href="#Rebalance" class="headerlink" title="Rebalance"></a>Rebalance</h1><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://bb3e216f.onedrive-cf-index-ng-e34.pages.dev/api/raw?path=/Public/BlogImg/RocketMQ/RocketMQ%E5%9F%BA%E7%A1%80%E7%AF%87%20Consumer%E6%B6%88%E8%B4%B9%E6%B6%88%E6%81%AF%20%E6%B5%81%E7%A8%8B%E5%9B%BE.png"
                      alt="RocketMQ基础篇 Consumer消费消息 流程图.png"
                ><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// RebalanceImpl</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doRebalance</span><span class="params">(<span class="keyword">final</span> <span class="keyword">boolean</span> isOrder)</span> </span>&#123;</span><br><span class="line">  Map&lt;String, SubscriptionData&gt; subTable = <span class="keyword">this</span>.getSubscriptionInner();</span><br><span class="line">  <span class="keyword">if</span> (subTable != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="comment">// 遍历每个主题的队列</span></span><br><span class="line">    <span class="comment">// subTable 会在 DefaultMQPushConsumerImpl 的 subscribe 和 unsubscribe 时修改</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">final</span> Map.Entry&lt;String, SubscriptionData&gt; entry : subTable.entrySet()) &#123;</span><br><span class="line">      <span class="keyword">final</span> String topic = entry.getKey();</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 对队列进行重新负载</span></span><br><span class="line">        <span class="keyword">this</span>.rebalanceByTopic(topic, isOrder);</span><br><span class="line">      &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!topic.startsWith(MixAll.RETRY_GROUP_TOPIC_PREFIX)) &#123;</span><br><span class="line">          log.warn(<span class="string">&quot;rebalanceByTopic Exception&quot;</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">this</span>.truncateMessageQueueNotMyTopic();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">rebalanceByTopic</span><span class="params">(<span class="keyword">final</span> String topic, <span class="keyword">final</span> <span class="keyword">boolean</span> isOrder)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">switch</span> (messageModel) &#123;</span><br><span class="line">    <span class="keyword">case</span> BROADCASTING: &#123;</span><br><span class="line">      Set&lt;MessageQueue&gt; mqSet = <span class="keyword">this</span>.topicSubscribeInfoTable.get(topic);</span><br><span class="line">      <span class="keyword">if</span> (mqSet != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">boolean</span> changed = <span class="keyword">this</span>.updateProcessQueueTableInRebalance(topic, mqSet, isOrder);</span><br><span class="line">        <span class="keyword">if</span> (changed) &#123;</span><br><span class="line">          <span class="keyword">this</span>.messageQueueChanged(topic, mqSet, mqSet);</span><br><span class="line">          log.info(<span class="string">&quot;messageQueueChanged &#123;&#125; &#123;&#125; &#123;&#125; &#123;&#125;&quot;</span>,</span><br><span class="line">                   consumerGroup,</span><br><span class="line">                   topic,</span><br><span class="line">                   mqSet,</span><br><span class="line">                   mqSet);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        log.warn(<span class="string">&quot;doRebalance, &#123;&#125;, but the topic[&#123;&#125;] not exist.&quot;</span>, consumerGroup, topic);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">case</span> CLUSTERING: &#123;</span><br><span class="line">      <span class="comment">// topicSubscribeInfoTable topic订阅信息缓存表</span></span><br><span class="line">      Set&lt;MessageQueue&gt; mqSet = <span class="keyword">this</span>.topicSubscribeInfoTable.get(topic);</span><br><span class="line">      <span class="comment">// 发送请求到broker获取topic下该消费组内当前所有的消费者客户端id</span></span><br><span class="line">      List&lt;String&gt; cidAll = <span class="keyword">this</span>.mQClientFactory.findConsumerIdList(topic, consumerGroup);</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">null</span> == mqSet) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!topic.startsWith(MixAll.RETRY_GROUP_TOPIC_PREFIX)) &#123;</span><br><span class="line">          log.warn(<span class="string">&quot;doRebalance, &#123;&#125;, but the topic[&#123;&#125;] not exist.&quot;</span>, consumerGroup, topic);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">null</span> == cidAll) &#123;</span><br><span class="line">        log.warn(<span class="string">&quot;doRebalance, &#123;&#125; &#123;&#125;, get consumer id list failed&quot;</span>, consumerGroup, topic);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (mqSet != <span class="keyword">null</span> &amp;&amp; cidAll != <span class="keyword">null</span>) &#123;</span><br><span class="line">        List&lt;MessageQueue&gt; mqAll = <span class="keyword">new</span> ArrayList&lt;MessageQueue&gt;();</span><br><span class="line">        mqAll.addAll(mqSet);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 排序保证了同一个消费组内消费者看到的视图保持一致，确保同一个消费队列不会被多个消费者分配</span></span><br><span class="line">        Collections.sort(mqAll);</span><br><span class="line">        Collections.sort(cidAll);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 分配算法 （尽量使用前两种）</span></span><br><span class="line">        <span class="comment">// 默认有5种 1）平均分配 2）平均轮询分配 3）一致性hash</span></span><br><span class="line">        <span class="comment">// 4）根据配置 为每一个消费者配置固定的消息队列 5）根据broker部署机房名，对每个消费者负责不同的broker上的队列</span></span><br><span class="line">        <span class="comment">// 但是如果消费者数目大于消息队列数量，则会有些消费者无法消费消息</span></span><br><span class="line">        AllocateMessageQueueStrategy strategy = <span class="keyword">this</span>.allocateMessageQueueStrategy;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 当前消费者分配到的队列</span></span><br><span class="line">        List&lt;MessageQueue&gt; allocateResult = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          allocateResult = strategy.allocate(</span><br><span class="line">            <span class="keyword">this</span>.consumerGroup,</span><br><span class="line">            <span class="keyword">this</span>.mQClientFactory.getClientId(),</span><br><span class="line">            mqAll,</span><br><span class="line">            cidAll);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">          log.error(<span class="string">&quot;AllocateMessageQueueStrategy.allocate Exception. allocateMessageQueueStrategyName=&#123;&#125;&quot;</span>, strategy.getName(),</span><br><span class="line">                    e);</span><br><span class="line">          <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Set&lt;MessageQueue&gt; allocateResultSet = <span class="keyword">new</span> HashSet&lt;MessageQueue&gt;();</span><br><span class="line">        <span class="keyword">if</span> (allocateResult != <span class="keyword">null</span>) &#123;</span><br><span class="line">          allocateResultSet.addAll(allocateResult);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 更新消息消费队列，如果是新增的消息消费队列，则会创建一个消息拉取请求并立即执行拉取</span></span><br><span class="line">        <span class="keyword">boolean</span> changed = <span class="keyword">this</span>.updateProcessQueueTableInRebalance(topic, allocateResultSet, isOrder);</span><br><span class="line">        <span class="keyword">if</span> (changed) &#123;</span><br><span class="line">          log.info(</span><br><span class="line">            <span class="string">&quot;rebalanced result changed. allocateMessageQueueStrategyName=&#123;&#125;, group=&#123;&#125;, topic=&#123;&#125;, clientId=&#123;&#125;, mqAllSize=&#123;&#125;, cidAllSize=&#123;&#125;, rebalanceResultSize=&#123;&#125;, rebalanceResultSet=&#123;&#125;&quot;</span>,</span><br><span class="line">            strategy.getName(), consumerGroup, topic, <span class="keyword">this</span>.mQClientFactory.getClientId(), mqSet.size(), cidAll.size(),</span><br><span class="line">            allocateResultSet.size(), allocateResultSet);</span><br><span class="line">          <span class="keyword">this</span>.messageQueueChanged(topic, mqSet, allocateResultSet);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">updateProcessQueueTableInRebalance</span><span class="params">(<span class="keyword">final</span> String topic, <span class="keyword">final</span> Set&lt;MessageQueue&gt; mqSet,</span></span></span><br><span class="line"><span class="params"><span class="function">                                                   <span class="keyword">final</span> <span class="keyword">boolean</span> isOrder)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">boolean</span> changed = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">  Iterator&lt;Entry&lt;MessageQueue, ProcessQueue&gt;&gt; it = <span class="keyword">this</span>.processQueueTable.entrySet().iterator();</span><br><span class="line">  <span class="keyword">while</span> (it.hasNext()) &#123;</span><br><span class="line">    Entry&lt;MessageQueue, ProcessQueue&gt; next = it.next();</span><br><span class="line">    MessageQueue mq = next.getKey();</span><br><span class="line">    ProcessQueue pq = next.getValue();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mq.getTopic().equals(topic)) &#123;</span><br><span class="line">      <span class="comment">// 当前分配到的队列中不包含原先的队列（说明当前队列被分配给了其他消费者）</span></span><br><span class="line">      <span class="keyword">if</span> (!mqSet.contains(mq)) &#123;</span><br><span class="line">        <span class="comment">// 丢弃 processQueue</span></span><br><span class="line">        pq.setDropped(<span class="keyword">true</span>);</span><br><span class="line">        <span class="comment">// 移除当前消息队列</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.removeUnnecessaryMessageQueue(mq, pq)) &#123;</span><br><span class="line">          it.remove();</span><br><span class="line">          changed = <span class="keyword">true</span>;</span><br><span class="line">          log.info(<span class="string">&quot;doRebalance, &#123;&#125;, remove unnecessary mq, &#123;&#125;&quot;</span>, consumerGroup, mq);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pq.isPullExpired()) &#123;</span><br><span class="line">        <span class="keyword">switch</span> (<span class="keyword">this</span>.consumeType()) &#123;</span><br><span class="line">          <span class="keyword">case</span> CONSUME_ACTIVELY:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">          <span class="keyword">case</span> CONSUME_PASSIVELY:</span><br><span class="line">            pq.setDropped(<span class="keyword">true</span>);</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.removeUnnecessaryMessageQueue(mq, pq)) &#123;</span><br><span class="line">              it.remove();</span><br><span class="line">              changed = <span class="keyword">true</span>;</span><br><span class="line">              log.error(<span class="string">&quot;[BUG]doRebalance, &#123;&#125;, remove unnecessary mq, &#123;&#125;, because pull is pause, so try to fixed it&quot;</span>,</span><br><span class="line">                        consumerGroup, mq);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">          <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  List&lt;PullRequest&gt; pullRequestList = <span class="keyword">new</span> ArrayList&lt;PullRequest&gt;();</span><br><span class="line">  <span class="keyword">for</span> (MessageQueue mq : mqSet) &#123;</span><br><span class="line">    <span class="comment">// 消息消费队列缓存中不存在当前队列 本次分配新增的队列</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">this</span>.processQueueTable.containsKey(mq)) &#123;</span><br><span class="line">      <span class="comment">// 向broker发起锁定队列请求 (向broker端请求锁定MessageQueue,同时在本地锁定对应的ProcessQueue)</span></span><br><span class="line">      <span class="keyword">if</span> (isOrder &amp;&amp; !<span class="keyword">this</span>.lock(mq)) &#123;</span><br><span class="line">        log.warn(<span class="string">&quot;doRebalance, &#123;&#125;, add a new mq failed, &#123;&#125;, because lock failed&quot;</span>, consumerGroup, mq);</span><br><span class="line">        <span class="comment">// 加锁失败，跳过，等待下一次队列重新负载时再尝试加锁</span></span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 从内存中移除该消息队列的消费进度</span></span><br><span class="line">      <span class="keyword">this</span>.removeDirtyOffset(mq);</span><br><span class="line">      ProcessQueue pq = <span class="keyword">new</span> ProcessQueue();</span><br><span class="line"></span><br><span class="line">      <span class="keyword">long</span> nextOffset = -<span class="number">1L</span>;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        nextOffset = <span class="keyword">this</span>.computePullFromWhereWithException(mq);</span><br><span class="line">      &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        log.info(<span class="string">&quot;doRebalance, &#123;&#125;, compute offset failed, &#123;&#125;&quot;</span>, consumerGroup, mq);</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (nextOffset &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        ProcessQueue pre = <span class="keyword">this</span>.processQueueTable.putIfAbsent(mq, pq);</span><br><span class="line">        <span class="keyword">if</span> (pre != <span class="keyword">null</span>) &#123;</span><br><span class="line">          log.info(<span class="string">&quot;doRebalance, &#123;&#125;, mq already exists, &#123;&#125;&quot;</span>, consumerGroup, mq);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="comment">// 首次添加，构建拉取消息的请求</span></span><br><span class="line">          log.info(<span class="string">&quot;doRebalance, &#123;&#125;, add a new mq, &#123;&#125;&quot;</span>, consumerGroup, mq);</span><br><span class="line">          PullRequest pullRequest = <span class="keyword">new</span> PullRequest();</span><br><span class="line">          pullRequest.setConsumerGroup(consumerGroup);</span><br><span class="line">          pullRequest.setNextOffset(nextOffset);</span><br><span class="line">          pullRequest.setMessageQueue(mq);</span><br><span class="line">          pullRequest.setProcessQueue(pq);</span><br><span class="line">          pullRequestList.add(pullRequest);</span><br><span class="line">          changed = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        log.warn(<span class="string">&quot;doRebalance, &#123;&#125;, add new mq failed, &#123;&#125;&quot;</span>, consumerGroup, mq);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 立即拉取消息(对新增的队列)</span></span><br><span class="line">  <span class="keyword">this</span>.dispatchPullRequest(pullRequestList);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> changed;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="集群模式下消息负载的步骤"><a href="#集群模式下消息负载的步骤" class="headerlink" title="集群模式下消息负载的步骤"></a>集群模式下消息负载的步骤</h2>由流程图和代码，我们可以得知，集群模式下消息负载主要有以下几个步骤：</li>
</ul>
<ol>
<li>从Broker获取订阅当前Topic的消费者列表</li>
<li>根据具体的策略进行负载均衡</li>
<li>对当前消费者分配到的队列进行处理<ol>
<li>原来有，现在没有：丢弃对应的消息处理队列（ProcessQueue）</li>
<li>原来没有，现在有：添加消息处理队列（ProcessQueue），如果是第一次新增，还会创建一个消息拉取请求<h2 id="Rebalance的策略"><a href="#Rebalance的策略" class="headerlink" title="Rebalance的策略"></a>Rebalance的策略</h2><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://bb3e216f.onedrive-cf-index-ng-e34.pages.dev/api/raw?path=/Public/BlogImg/RocketMQ/RocketMQ%E5%9F%BA%E7%A1%80%E7%AF%87%20Consumer%E6%B6%88%E8%B4%B9%E6%B6%88%E6%81%AF%20Rebalance%E7%AD%96%E7%95%A5.png"
                      alt="RocketMQ基础篇 Consumer消费消息 Rebalance策略.png"
                ><h1 id="拉取消息"><a href="#拉取消息" class="headerlink" title="拉取消息"></a>拉取消息</h1><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://bb3e216f.onedrive-cf-index-ng-e34.pages.dev/api/raw?path=/Public/BlogImg/RocketMQ/RocketMQ%E5%9F%BA%E7%A1%80%E7%AF%87%20Consumer%E6%B6%88%E8%B4%B9%E6%B6%88%E6%81%AF%20%E6%8B%89%E5%8F%96%E6%B6%88%E6%81%AF%E6%B5%81%E7%A8%8B%E5%9B%BE.png"
                      alt="RocketMQ基础篇 Consumer消费消息 拉取消息流程图.png"
                ><br>拉取消息的代码太多了，就不再这里贴出来了。</li>
</ol>
</li>
</ol>
<h2 id="拉取消息的大致流程"><a href="#拉取消息的大致流程" class="headerlink" title="拉取消息的大致流程"></a>拉取消息的大致流程</h2><p>这里说一下大致流程，然后有几个需要注意的地方<br>流程：在我们Rebalance第一次添加负责的队列和后续拉取消息后，都会再提交一个拉取请求到拉取请求队列（pullRequestQueue）中，然后有一个线程不停的去里面获取拉取请求，去执行拉取的操作<br>这里说一个RocketMQ消费者这边设计的一个亮点<br>它将拉取消息，消费消息通过两个任务队列的方式进行解耦，然后每一个模块仅需要负责它自己的功能。（虽然大佬们觉得很常见，但是当时我看的时候还是感觉妙呀～）<br>另外还有一点需要注意的是：<strong>拉取消息的时候broker和consumer都会对消息进行过滤，只不过broker是根据tag的hash进行过滤的，而consumer是根据具体的tag字符串匹配过滤的。这也是有的时候，明明拉取到了消息，但是却没有需要消费的消息产生的原因</strong><br>既然说到了消息过滤，这边先简单提一下RocketMQ消息过滤的几种方式</p>
<ul>
<li>表达式过滤<ul>
<li>tag</li>
<li>SQL92</li>
</ul>
</li>
<li>类过滤</li>
</ul>
<h1 id="消费消息"><a href="#消费消息" class="headerlink" title="消费消息"></a>消费消息</h1><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://bb3e216f.onedrive-cf-index-ng-e34.pages.dev/api/raw?path=/Public/BlogImg/RocketMQ/RocketMQ%E5%9F%BA%E7%A1%80%E7%AF%87%20Consumer%E6%B6%88%E8%B4%B9%E6%B6%88%E6%81%AF%20%E6%B6%88%E8%B4%B9%E6%B6%88%E6%81%AF%E6%B5%81%E7%A8%8B%E5%9B%BE.png"
                      alt="RocketMQ基础篇 Consumer消费消息 消费消息流程图.png"
                ><br>这边也先说几个注意点吧，后面再单独更新一篇文章。<br>（一）顺序消费和非顺序消费消费失败的处理<br>非顺序消费：直接丢入延时队列中，等待重试。顺序消息：本地重试<br>（二）消费失败偏移量的更新：只有当前这批消息全部消费成功后，才会将偏移量更新成为这批消息最后一条的偏移量<br>（三)广播消息失败不会重试，仅打印失败日志</p>
<h1 id="一些补充"><a href="#一些补充" class="headerlink" title="一些补充"></a>一些补充</h1><h2 id="为什么同一个消费组下消费者的订阅信息要相同"><a href="#为什么同一个消费组下消费者的订阅信息要相同" class="headerlink" title="为什么同一个消费组下消费者的订阅信息要相同"></a><strong>为什么同一个消费组下消费者的订阅信息要相同</strong></h2><p>首先，先说一下什么叫做同一个消费组下消费者的订阅信息要相同<br>即：在相同的GroupId下，每一个消费者他们的订阅内容（Topic+Tag）要保持一致，否则会导致消息无法被正常消费<br>参考文档：<a class="link"   href="https://help.aliyun.com/document_detail/43523.html?spm=a2c4g.11186623.6.777.1dba3635aj4Own" >阿里云:订阅关系一致<i class="fas fa-external-link-alt"></i></a><br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://bb3e216f.onedrive-cf-index-ng-e34.pages.dev/api/raw?path=/Public/BlogImg/RocketMQ/RocketMQ%E5%9F%BA%E7%A1%80%E7%AF%87%20Consumer%E6%B6%88%E8%B4%B9%E6%B6%88%E6%81%AF%20%E8%AE%A2%E9%98%85%E5%85%B3%E7%B3%BB%E4%B8%80%E8%87%B4%E8%AF%B4%E6%98%8E.png"
                      alt="RocketMQ基础篇 Consumer消费消息 订阅关系一致说明.png"
                ><br>我们在看待这个问题的时候，可以把它分为两类情况考虑</p>
<ul>
<li>topic不一致</li>
<li>tag不一致<h3 id="（一）topic不一致的问题"><a href="#（一）topic不一致的问题" class="headerlink" title="（一）topic不一致的问题"></a>（一）topic不一致的问题</h3>首先先说一个场景，消费者A监听了TopicA，消费者B监听了TopicB，但是消费者A和消费者B同属一个groupTest<br>在Rebalance阶段，消费者A对TopicA进行负载均衡时，会去查询groupTest下的所有消费者信息。获取到了消费者A和消费者B。此时就会将TopicA的队列对消费者A和消费者B进行负载均衡（例如消费者A分配到了1234四个队列，消费者B分配到了5678四个队列）。此时消费者B没有针对TopicA的处理逻辑，就会导致推送到5678这几个队列里面的消息没有办法得到处理。<br>偏移量不发生变化</li>
</ul>
<h3 id="（二）tag不一致的问题"><a href="#（二）tag不一致的问题" class="headerlink" title="（二）tag不一致的问题"></a>（二）tag不一致的问题</h3><p>随着消费者A，消费者B负载均衡的不断进行，会不断把最新的订阅信息（消息过滤规则）上报给broker。broker就会不断的覆盖更新，导致tag信息不停地变化，而tag的变化在消费者拉取消息时broker的过滤就会产生影响，会导致一些本来要被消费者拉取到的消息被broker过滤掉<br>过滤了，偏移量在消费后直接更新</p>
<h2 id="关于消息消费的推拉模式"><a href="#关于消息消费的推拉模式" class="headerlink" title="关于消息消费的推拉模式"></a>关于消息消费的推拉模式</h2><p>MQPushConsumer方式，consumer把轮询过程封装了，并注册MessageListener监听器，取到消息后，唤醒MessageListener的consumeMessage()来消费，对用户而言，感觉消息是被推送（push）过来的。主要用的也是这种方式。（我们日常开发时使用到的模式）<br>MQPullConsumer方式，取消息的过程需要用户自己写，首先通过打算消费的Topic拿到MessageQueue的集合，遍历MessageQueue集合，然后针对每个MessageQueue批量取消息，一次取完后，记录该队列下一次要取的开始offset，直到取完了，再换另一个MessageQueue。<br>总结：我们日常开发中使用到的是RocketMQ的推模式（虽然底层上的本质还是拉模式），但是不需要我们去处理拉取消息的动作触发等。如果我们要使用RocketMQ的拉模式，就需要我们自己实现从队列中拿拉取请求，然后显示调用拉消息的api，另外还要去往队列中放置拉取请求等操作。</p>
<h2 id="消费幂等控制"><a href="#消费幂等控制" class="headerlink" title="消费幂等控制"></a>消费幂等控制</h2><p>除了基于业务状态等操作控制幂等的基础上，还可以通过消息的唯一id进行判断当前消息是否消费过<br>下图是生产者生产消息时产生的唯一标识 **UNIQ_KEY **，消息重试发送，这个msgid是不会变化的<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://bb3e216f.onedrive-cf-index-ng-e34.pages.dev/api/raw?path=/Public/BlogImg/RocketMQ/RocketMQ%E5%9F%BA%E7%A1%80%E7%AF%87%20Consumer%E6%B6%88%E8%B4%B9%E6%B6%88%E6%81%AF%20%E9%80%9A%E8%BF%87msgid%E6%8E%A7%E5%88%B6%E6%B6%88%E8%B4%B9%E5%B9%82%E7%AD%89.png"
                      alt="RocketMQ基础篇 Consumer消费消息 通过msgid控制消费幂等.png"
                ><br>对应的消息内容</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ConsumeMessageThread_8 Receive New Messages: [MessageExt [brokerName=broker-a  , queueId=<span class="number">14</span>, storeSize=<span class="number">178</span>, queueOffset=<span class="number">3</span>, sysFlag=<span class="number">0</span>, bornTimestamp=<span class="number">1659604568508</span>, bornHost=/<span class="number">192.168</span><span class="number">.196</span><span class="number">.123</span>:<span class="number">50628</span>, storeTimestamp=<span class="number">1659604568547</span>, storeHost=/<span class="number">172.30</span><span class="number">.0</span><span class="number">.4</span>:<span class="number">10911</span>, msgId=AC1E000400002A9F0000000000002B12, commitLogOffset=<span class="number">11026</span>, bodyCRC=<span class="number">717801981</span>, reconsumeTimes=<span class="number">0</span>, preparedTransactionOffset=<span class="number">0</span>, toString()=Message&#123;topic=<span class="string">&#x27;TopicTest&#x27;</span>, flag=<span class="number">0</span>, properties=&#123;MIN_OFFSET=<span class="number">0</span>, MAX_OFFSET=<span class="number">6</span>, CONSUME_START_TIME=<span class="number">1659663419735</span>, UNIQ_KEY=0000010163E018B4AAC21327B1BC003E, WAIT=<span class="keyword">true</span>, TAGS=TagA&#125;, body=[<span class="number">72</span>, <span class="number">101</span>, <span class="number">108</span>, <span class="number">108</span>, <span class="number">111</span>, <span class="number">32</span>, <span class="number">82</span>, <span class="number">111</span>, <span class="number">99</span>, <span class="number">107</span>, <span class="number">101</span>, <span class="number">116</span>, <span class="number">77</span>, <span class="number">81</span>, <span class="number">32</span>, <span class="number">54</span>, <span class="number">50</span>], transactionId=<span class="string">&#x27;null&#x27;</span>&#125;]]</span><br></pre></td></tr></table></figure>
<h1 id="消费者总结"><a href="#消费者总结" class="headerlink" title="消费者总结"></a>消费者总结</h1><p>讲了这么多的消费者的内容，出现了好多名词，也把消费者的一些比较核心的内容逐个讲了一遍。<br>那么，在这里，我们将消费者这个模块里面的所有东西，在进行一个完整的串联。然后消费者这一方面的介绍就要告一段落了<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://bb3e216f.onedrive-cf-index-ng-e34.pages.dev/api/raw?path=/Public/BlogImg/RocketMQ/RocketMQ%E5%9F%BA%E7%A1%80%E7%AF%87%20Consumer%E6%B6%88%E8%B4%B9%E6%B6%88%E6%81%AF%20%E5%AE%8C%E6%95%B4%E6%B5%81%E7%A8%8B%E5%9B%BE2.png"
                      alt="RocketMQ基础篇 Consumer消费消息 完整流程图2.png"
                ><br>附一张丁威老师的流程图<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://bb3e216f.onedrive-cf-index-ng-e34.pages.dev/api/raw?path=/Public/BlogImg/RocketMQ/RocketMQ%E5%9F%BA%E7%A1%80%E7%AF%87%20Consumer%E6%B6%88%E8%B4%B9%E6%B6%88%E6%81%AF%20%E4%B8%81%E5%A8%81%E8%80%81%E5%B8%88%E6%B5%81%E7%A8%8B%E5%9B%BE.jpeg"
                      alt="RocketMQ基础篇 Consumer消费消息 丁威老师流程图.jpeg"
                ></p>

<div id="gitalk-container"></div>
<script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

		<script>
		var gitalkConfig = {"clientID":"26b8e6758f16d4524e69","clientSecret":"ecfd9e9a439bcb8a4c4fd21f4677fa102c68b352","repo":"beastmouth.github.io","owner":"beastmouth","admin":["beastmouth"],"distractionFreeMode":false,"createIssueManually":true};
	    gitalkConfig.id = md5(location.pathname);
		var gitalk = new Gitalk(gitalkConfig);
	    gitalk.render("gitalk-container");
	    </script>]]></content>
      <categories>
        <category>RocketMQ</category>
      </categories>
  </entry>
  <entry>
    <title>RocketMQ基础篇Producer发送消息</title>
    <url>/2022/08/05/RocketMQ%E5%9F%BA%E7%A1%80%E7%AF%87Producer%E5%8F%91%E9%80%81%E6%B6%88%E6%81%AF/</url>
    <content><![CDATA[<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://bb3e216f.onedrive-cf-index-ng-e34.pages.dev/api/raw?path=/Public/BlogImg/RocketMQ/RocketMQ%E5%9F%BA%E7%A1%80%E7%AF%87%20Producer%E5%8F%91%E9%80%81%E6%B6%88%E6%81%AF%20%E6%B5%81%E7%A8%8B%E5%9B%BE.png"
                      alt="RocketMQ基础篇 Producer发送消息 流程图.png"
                ><br>生产者发送消息的主要流程图如上图所示。具体的代码由于比较多，我就不在这边贴出来的。<br>主要讲一下我认为比较重要的点</p>
<h1 id="消息队列负载均衡"><a href="#消息队列负载均衡" class="headerlink" title="消息队列负载均衡"></a><strong>消息队列负载均衡</strong></h1><p>Producer会每隔30s从Namesrv获取最新的Topic路由信息，并缓存到本地</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">this</span>.scheduledExecutorService.scheduleAtFixedRate(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 每个30s从NameServer更新路由表信息</span></span><br><span class="line">            MQClientInstance.<span class="keyword">this</span>.updateTopicRouteInfoFromNameServer();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            log.error(<span class="string">&quot;ScheduledTask updateTopicRouteInfoFromNameServer exception&quot;</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;, <span class="number">10</span>, <span class="keyword">this</span>.clientConfig.getPollNameServerInterval(), TimeUnit.MILLISECONDS);</span><br></pre></td></tr></table></figure>
<p>路由信息就是用来发送时选择具体的Broker和队列的</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> SendResult <span class="title">sendSelectImpl</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    Message msg,</span></span></span><br><span class="line"><span class="params"><span class="function">    MessageQueueSelector selector,</span></span></span><br><span class="line"><span class="params"><span class="function">    Object arg,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">final</span> CommunicationMode communicationMode,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">final</span> SendCallback sendCallback, <span class="keyword">final</span> <span class="keyword">long</span> timeout</span></span></span><br><span class="line"><span class="params"><span class="function">    )</span> <span class="keyword">throws</span> MQClientException, RemotingException, MQBrokerException, InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> beginStartTime = System.currentTimeMillis();</span><br><span class="line">    <span class="keyword">this</span>.makeSureStateOK();</span><br><span class="line">    Validators.checkMessage(msg, <span class="keyword">this</span>.defaultMQProducer);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 获取Topic队列信息</span></span><br><span class="line">    <span class="comment">// 此处的流程:</span></span><br><span class="line">    <span class="comment">// 先从本地缓存中获取,获取到返回</span></span><br><span class="line">    <span class="comment">// 没有获取到.从NameSrv中获取,获取到返回</span></span><br><span class="line">    <span class="comment">// 没有获取到.如果能够自动创建Topic,会把消息放到TBW102.后续会有自动创建Topic的逻辑</span></span><br><span class="line">    TopicPublishInfo topicPublishInfo = <span class="keyword">this</span>.tryToFindTopicPublishInfo(msg.getTopic());</span><br><span class="line">    <span class="keyword">if</span> (topicPublishInfo != <span class="keyword">null</span> &amp;&amp; topicPublishInfo.ok()) &#123;</span><br><span class="line">        MessageQueue mq = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">        List&lt;MessageQueue&gt; messageQueueList =</span><br><span class="line">        mQClientFactory.getMQAdminImpl().parsePublishMessageQueues(topicPublishInfo.getMessageQueueList());</span><br><span class="line">        Message userMessage = MessageAccessor.cloneMessage(msg);</span><br><span class="line">        String userTopic = NamespaceUtil.withoutNamespace(userMessage.getTopic(), mQClientFactory.getClientConfig().getNamespace());</span><br><span class="line">        userMessage.setTopic(userTopic);</span><br><span class="line">    </span><br><span class="line">        mq = mQClientFactory.getClientConfig().queueWithNamespace(selector.select(messageQueueList, userMessage, arg));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> MQClientException(<span class="string">&quot;select message queue threw exception.&quot;</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 省略代码....</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 省略代码....</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此处流程可以总结为:</p>
<ul>
<li><p>尝试获取队列列表</p>
<ul>
<li>从本地缓存中获取，获取到返回</li>
<li>没有获取到。从NameSrv中获取，获取到返回</li>
<li>没有获取到。获取TBW102的队列，获取到返回。后续会有自动创建Topic的逻辑</li>
</ul>
</li>
<li><p>选择其中一个队列 selector 策略</p>
<h1 id="关于异步消息"><a href="#关于异步消息" class="headerlink" title="关于异步消息"></a><strong>关于异步消息</strong></h1><p>异步消息需要我们单独加一个回调方法，添加在发送消息成功/失败的一些处理。<br>因为异步消息没有对Broker回来的结果进行额外的处理，那么自然我们就不能像同步消息一样，对Broker返回回来的结果单独针对SendResult进行单独的重试操作。所以需要我们在失败的回调方法上进行额外的处理（例如重试消息发送）<br>具体的原因，我们可以看下消息发送的主干逻辑</p>
<h1 id="消息发送的主干逻辑"><a href="#消息发送的主干逻辑" class="headerlink" title="消息发送的主干逻辑"></a><strong>消息发送的主干逻辑</strong></h1><p>另外我在这里贴一下消息发送的主干代码（具体的代码和它们的注释可以看下我的github <a class="link"   href="https://github.com/beastmouth/rocketmq" >我是一个超链接<i class="fas fa-external-link-alt"></i></a>）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ... 省略部分代码</span></span><br><span class="line"><span class="comment">// 查找主题路由信息</span></span><br><span class="line">TopicPublishInfo topicPublishInfo = <span class="keyword">this</span>.tryToFindTopicPublishInfo(msg.getTopic());</span><br><span class="line"><span class="keyword">if</span> (topicPublishInfo != <span class="keyword">null</span> &amp;&amp; topicPublishInfo.ok()) &#123;</span><br><span class="line">    <span class="comment">// ... 省略部分代码</span></span><br><span class="line">    <span class="keyword">for</span> (; times &lt; timesTotal; times++) &#123;</span><br><span class="line">      <span class="comment">// 上次发送的broker名称</span></span><br><span class="line">      String lastBrokerName = <span class="keyword">null</span> == mq ? <span class="keyword">null</span> : mq.getBrokerName();</span><br><span class="line">      <span class="comment">// 选择一条messagequeue(轮询+失败规避)</span></span><br><span class="line">      MessageQueue mqSelected = <span class="keyword">this</span>.selectOneMessageQueue(topicPublishInfo, lastBrokerName);</span><br><span class="line">      <span class="keyword">if</span> (mqSelected != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// ... 省略部分代码</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="comment">// ... 省略部分代码</span></span><br><span class="line">          sendResult = <span class="keyword">this</span>.sendKernelImpl(msg, mq, communicationMode, sendCallback, topicPublishInfo, timeout - costTime);</span><br><span class="line">          endTimestamp = System.currentTimeMillis();</span><br><span class="line">          <span class="comment">// 失败规避</span></span><br><span class="line">          <span class="keyword">this</span>.updateFaultItem(mq.getBrokerName(), endTimestamp - beginTimestampPrev, <span class="keyword">false</span>);</span><br><span class="line">          <span class="keyword">switch</span> (communicationMode) &#123;</span><br><span class="line">            <span class="keyword">case</span> ASYNC:</span><br><span class="line">              <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">case</span> ONEWAY:</span><br><span class="line">              <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">case</span> SYNC:</span><br><span class="line">              <span class="keyword">if</span> (sendResult.getSendStatus() != SendStatus.SEND_OK) &#123;</span><br><span class="line">                <span class="comment">// 发送失败重试</span></span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">this</span>.defaultMQProducer.isRetryAnotherBrokerWhenNotStoreOK()) &#123;</span><br><span class="line">                  <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">              &#125;</span><br><span class="line"></span><br><span class="line">              <span class="keyword">return</span> sendResult;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">              <span class="keyword">break</span>;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (<span class="comment">/** 一系列异常处理 **/</span>) &#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>流程：</p>
</li>
<li><p>尝试获取Topic路由信息</p>
</li>
<li><p>选择一个队列（默认是轮询+失败规避）</p>
</li>
<li><p>发送消息，失败会重试</p>
<h1 id="失败规避"><a href="#失败规避" class="headerlink" title="失败规避"></a><strong>失败规避</strong></h1><p>上面提到了失败规避，到底什么是失败规避呢？<br>在我们一次消息发送过程中，消息有可能发送失败。在消息发送失败，重试时选择发送消息的队列时，就会规避上次MessageQueue所在的Broker。这样能够减少很多不必要的请求（因为Broker宕机后，很大情况下这个Broker短时间内依旧是无法使用的）<br>那么，为什么会有宕机的Broker在我们的内存中存在？<br>因为NameSrv是根据心跳检测来确定Broker是否可用的（有间隔 10s），且消息生产者更新路由信息也是有间隔的（30s）。且为了Namesrv设计的简单，Namesrv不会主动将Broker宕机的信息推给消息生产者，而是需要消息生产者定时更新的时候，才会感知到Broker宕机。<br>在这期间存在误差，所以我们是要一个机制（失败规避策略）来减少一些不必要的性能消耗</p>
</li>
</ul>
<p><strong>另外，失败规避默认是关闭的</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">boolean</span> sendLatencyFaultEnable = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">updateFaultItem</span><span class="params">(<span class="keyword">final</span> String brokerName, <span class="keyword">final</span> <span class="keyword">long</span> currentLatency, <span class="keyword">boolean</span> isolation)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.sendLatencyFaultEnable) &#123;</span><br><span class="line">        <span class="comment">// 默认以30s作为computeNotAvailableDuration的参数</span></span><br><span class="line">        <span class="keyword">long</span> duration = computeNotAvailableDuration(isolation ? <span class="number">30000</span> : currentLatency);</span><br><span class="line">        <span class="keyword">this</span>.latencyFaultTolerance.updateFaultItem(brokerName, currentLatency, duration);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="关于发送端消息的可靠性"><a href="#关于发送端消息的可靠性" class="headerlink" title="关于发送端消息的可靠性"></a><strong>关于发送端消息的可靠性</strong></h1><p>发送端消息的可靠性主要是靠消息发送重试<br>RocketMQ的架构中，可能会存在多个Broker为某个topic提供服务，这个topic的消息被存放在多个Broker下。（有点类似于Redis的Cluster）<br>当生产者往某个Broker发送消息失败时，会进行失败规避，选择其他提供服务的Broker，进行发送消息。确保消息能够被稳定的送到Broker中</p>
<h1 id="消息重新发送，消息的msgid会发生变化吗"><a href="#消息重新发送，消息的msgid会发生变化吗" class="headerlink" title="消息重新发送，消息的msgid会发生变化吗"></a>消息重新发送，消息的msgid会发生变化吗</h1><p>msgId，对于客户端来说msgId是由客户端producer实例端生成的，具体来说，调用方法MessageClientIDSetter.createUniqIDBuffer()生成唯一的Id；</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//for MessageBatch,ID has been set in the generating process</span></span><br><span class="line"><span class="keyword">if</span> (!(msg <span class="keyword">instanceof</span> MessageBatch)) &#123;</span><br><span class="line">    <span class="comment">// 为消息分配唯一的全局id</span></span><br><span class="line">    MessageClientIDSetter.setUniqID(msg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">setUniqID</span><span class="params">(<span class="keyword">final</span> Message msg)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 因为有了这个判读，所以我们重试的时候，消息id是不会发生变化的</span></span><br><span class="line">    <span class="keyword">if</span> (msg.getProperty(MessageConst.PROPERTY_UNIQ_CLIENT_MESSAGE_ID_KEYIDX) == <span class="keyword">null</span>) &#123;</span><br><span class="line">        msg.putProperty(MessageConst.PROPERTY_UNIQ_CLIENT_MESSAGE_ID_KEYIDX, createUniqID());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String PROPERTY_UNIQ_CLIENT_MESSAGE_ID_KEYIDX = <span class="string">&quot;UNIQ_KEY&quot;</span>;</span><br></pre></td></tr></table></figure>
<p>但是，offsetMsgId是会发生变化的<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://bb3e216f.onedrive-cf-index-ng-e34.pages.dev/api/raw?path=/Public/BlogImg/RocketMQ/RocketMQ%E5%9F%BA%E7%A1%80%E7%AF%87%20Producer%E5%8F%91%E9%80%81%E6%B6%88%E6%81%AF%20msgid.png"
                      alt="RocketMQ基础篇 Producer发送消息 msgid.png"
                ></p>
<ul>
<li>msgId，对于客户端来说msgId是由客户端producer实例端生成的，具体来说，调用方法<code>MessageClientIDSetter.createUniqIDBuffer()</code>生成唯一的Id；</li>
<li>offsetMsgId，offsetMsgId是由Broker服务端在写入消息时生成的（采用”IP地址+Port端口”与“CommitLog的物理偏移量地址”做了一个字符串拼接），其中offsetMsgId就是在RocketMQ控制台直接输入查询的那个messageId。<h1 id="消息发送的时候，如何自己选择消息推送的队列"><a href="#消息发送的时候，如何自己选择消息推送的队列" class="headerlink" title="消息发送的时候，如何自己选择消息推送的队列"></a>消息发送的时候，如何自己选择消息推送的队列</h1>发送消息的时候可以自定义一个MessageQueueSelector，就可以自己选推到那个队列，实现顺序消息的需求了<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">send</span><span class="params">(<span class="keyword">final</span> Message msg, <span class="keyword">final</span> MessageQueueSelector selector, <span class="keyword">final</span> Object arg,</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="keyword">final</span> SendCallback sendCallback)</span> <span class="keyword">throws</span> MQClientException, RemotingException,</span></span><br><span class="line"><span class="function">        InterruptedException</span>;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> SendResult <span class="title">sendSelectImpl</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        Message msg,</span></span></span><br><span class="line"><span class="params"><span class="function">        MessageQueueSelector selector,</span></span></span><br><span class="line"><span class="params"><span class="function">        Object arg,</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="keyword">final</span> CommunicationMode communicationMode,</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="keyword">final</span> SendCallback sendCallback, <span class="keyword">final</span> <span class="keyword">long</span> timeout</span></span></span><br><span class="line"><span class="params"><span class="function">    )</span> <span class="keyword">throws</span> MQClientException, RemotingException, MQBrokerException, InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> beginStartTime = System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">this</span>.makeSureStateOK();</span><br><span class="line">        Validators.checkMessage(msg, <span class="keyword">this</span>.defaultMQProducer);</span><br><span class="line"></span><br><span class="line">        TopicPublishInfo topicPublishInfo = <span class="keyword">this</span>.tryToFindTopicPublishInfo(msg.getTopic());</span><br><span class="line">        <span class="keyword">if</span> (topicPublishInfo != <span class="keyword">null</span> &amp;&amp; topicPublishInfo.ok()) &#123;</span><br><span class="line">            MessageQueue mq = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                List&lt;MessageQueue&gt; messageQueueList =</span><br><span class="line">                    mQClientFactory.getMQAdminImpl().parsePublishMessageQueues(topicPublishInfo.getMessageQueueList());</span><br><span class="line">                Message userMessage = MessageAccessor.cloneMessage(msg);</span><br><span class="line">                String userTopic = NamespaceUtil.withoutNamespace(userMessage.getTopic(), mQClientFactory.getClientConfig().getNamespace());</span><br><span class="line">                userMessage.setTopic(userTopic);</span><br><span class="line"></span><br><span class="line">                mq = mQClientFactory.getClientConfig().queueWithNamespace(selector.select(messageQueueList, userMessage, arg));</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> MQClientException(<span class="string">&quot;select message queue threw exception.&quot;</span>, e);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">long</span> costTime = System.currentTimeMillis() - beginStartTime;</span><br><span class="line">            <span class="keyword">if</span> (timeout &lt; costTime) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RemotingTooMuchRequestException(<span class="string">&quot;sendSelectImpl call timeout&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (mq != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">this</span>.sendKernelImpl(msg, mq, communicationMode, sendCallback, <span class="keyword">null</span>, timeout - costTime);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> MQClientException(<span class="string">&quot;select message queue return null.&quot;</span>, <span class="keyword">null</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        validateNameServerSetting();</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> MQClientException(<span class="string">&quot;No route info for this topic, &quot;</span> + msg.getTopic(), <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
有一个注意点：这种基于selector方式的，发送消息失败是不会重试的<br>原因：我的理解是我们自己自定义的selector，在没有规则策略的前提下，大概率还是选择到这个失败的队列里面。但是如果有规避策略的话，又和我们定义selector的本意违背了（例如我要实现顺序消息，结果失败重试把它丢到了其他队列，违背了顺序消息的本意）</li>
</ul>

<div id="gitalk-container"></div>
<script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

		<script>
		var gitalkConfig = {"clientID":"26b8e6758f16d4524e69","clientSecret":"ecfd9e9a439bcb8a4c4fd21f4677fa102c68b352","repo":"beastmouth.github.io","owner":"beastmouth","admin":["beastmouth"],"distractionFreeMode":false,"createIssueManually":true};
	    gitalkConfig.id = md5(location.pathname);
		var gitalk = new Gitalk(gitalkConfig);
	    gitalk.render("gitalk-container");
	    </script>]]></content>
      <categories>
        <category>RocketMQ</category>
      </categories>
  </entry>
  <entry>
    <title>RocketMQ流程</title>
    <url>/2023/04/06/RocketMQ%E6%B5%81%E7%A8%8B/</url>
    <content><![CDATA[<h1 id="Nameserver-启动流程"><a href="#Nameserver-启动流程" class="headerlink" title="Nameserver 启动流程"></a>Nameserver 启动流程</h1><h2 id="流程图"><a href="#流程图" class="headerlink" title="流程图"></a>流程图</h2><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://bb3e216f.onedrive-cf-index-ng-e34.pages.dev/api/raw?path=/Public/BlogImg/RocketMQ/NameServer%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B.png"
                      alt="NameServer启动流程.png"
                ><br>此处不做过多赘述，NameServer主要是维护了消息服务端和客户端的信息<br>但是这边提一个RocketMQ中比较优雅的写法（利用JVM的钩子函数）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> NamesrvController <span class="title">start</span><span class="params">(<span class="keyword">final</span> NamesrvController controller)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="comment">// 利用JVM的钩子函数，在停机时进行一下流的关闭，线程池的停机</span></span><br><span class="line">	Runtime.getRuntime().addShutdownHook(<span class="keyword">new</span> ShutdownHookThread(log, <span class="keyword">new</span> Callable&lt;Void&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Void <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">            controller.shutdown();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;));</span><br><span class="line">    controller.start();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.remotingServer.start();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.fileWatchService != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.fileWatchService.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">shutdown</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.remotingServer.shutdown();</span><br><span class="line">    <span class="keyword">this</span>.remotingExecutor.shutdown();</span><br><span class="line">    <span class="keyword">this</span>.scheduledExecutorService.shutdown();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.fileWatchService != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.fileWatchService.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="Broker-启动"><a href="#Broker-启动" class="headerlink" title="Broker 启动"></a>Broker 启动</h1><h2 id="主要内容"><a href="#主要内容" class="headerlink" title="主要内容"></a>主要内容</h2><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://bb3e216f.onedrive-cf-index-ng-e34.pages.dev/api/raw?path=/Public/BlogImg/RocketMQ/Broker%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B.png"
                      alt="Broker启动流程.png"
                ><br>这边我们主要知道Broker启动流程都做了哪些事情，具体这些事情是怎么做的，将在后续的模块中进行介绍</p>
<h1 id="客户端启动-Producer-Consumer"><a href="#客户端启动-Producer-Consumer" class="headerlink" title="客户端启动 Producer/Consumer"></a>客户端启动 Producer/Consumer</h1><h2 id="流程图-1"><a href="#流程图-1" class="headerlink" title="流程图"></a>流程图</h2><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://bb3e216f.onedrive-cf-index-ng-e34.pages.dev/api/raw?path=/Public/BlogImg/RocketMQ/ClientInstance%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B.png"
                      alt="ClientInstance启动流程.png"
                ></p>
<h2 id="关键代码"><a href="#关键代码" class="headerlink" title="关键代码"></a>关键代码</h2><h3 id="Producer"><a href="#Producer" class="headerlink" title="Producer"></a>Producer</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">(<span class="keyword">final</span> <span class="keyword">boolean</span> startFactory)</span> <span class="keyword">throws</span> MQClientException </span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (<span class="keyword">this</span>.serviceState) &#123;</span><br><span class="line">        <span class="keyword">case</span> CREATE_JUST:</span><br><span class="line">            <span class="keyword">this</span>.serviceState = ServiceState.START_FAILED;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 校验producerGroup是否符合要求</span></span><br><span class="line">            <span class="keyword">this</span>.checkConfig();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (!<span class="keyword">this</span>.defaultMQProducer.getProducerGroup().equals(MixAll.CLIENT_INNER_PRODUCER_GROUP)) &#123;</span><br><span class="line">                <span class="comment">// 更改生产者id为进程id</span></span><br><span class="line">                <span class="keyword">this</span>.defaultMQProducer.changeInstanceNameToPID();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 创建实例</span></span><br><span class="line">            <span class="keyword">this</span>.mQClientFactory = MQClientManager.getInstance().getOrCreateMQClientInstance(<span class="keyword">this</span>.defaultMQProducer, rpcHook);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 向MQClientInstance注册实例（将当前实体加入MQClientInstance管理）方便后续调用网络请求、心跳检测等</span></span><br><span class="line">            <span class="keyword">boolean</span> registerOK = mQClientFactory.registerProducer(<span class="keyword">this</span>.defaultMQProducer.getProducerGroup(), <span class="keyword">this</span>);</span><br><span class="line">            <span class="keyword">if</span> (!registerOK) &#123;</span><br><span class="line">                <span class="keyword">this</span>.serviceState = ServiceState.CREATE_JUST;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> MQClientException(<span class="string">&quot;The producer group[&quot;</span> + <span class="keyword">this</span>.defaultMQProducer.getProducerGroup()</span><br><span class="line">                    + <span class="string">&quot;] has been created before, specify another name please.&quot;</span> + FAQUrl.suggestTodo(FAQUrl.GROUP_NAME_DUPLICATE_URL),</span><br><span class="line">                    <span class="keyword">null</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">this</span>.topicPublishInfoTable.put(<span class="keyword">this</span>.defaultMQProducer.getCreateTopicKey(), <span class="keyword">new</span> TopicPublishInfo());</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 如果MQClientInstance已经启动，本次启动不会真正执行</span></span><br><span class="line">            <span class="keyword">if</span> (startFactory) &#123;</span><br><span class="line">                <span class="comment">// 没有启动，启动MQClientInstance</span></span><br><span class="line">                mQClientFactory.start();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            log.info(<span class="string">&quot;the producer [&#123;&#125;] start OK. sendMessageWithVIPChannel=&#123;&#125;&quot;</span>, <span class="keyword">this</span>.defaultMQProducer.getProducerGroup(),</span><br><span class="line">                <span class="keyword">this</span>.defaultMQProducer.isSendMessageWithVIPChannel());</span><br><span class="line">            <span class="keyword">this</span>.serviceState = ServiceState.RUNNING;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> RUNNING:</span><br><span class="line">        <span class="keyword">case</span> START_FAILED:</span><br><span class="line">        <span class="keyword">case</span> SHUTDOWN_ALREADY:</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> MQClientException(<span class="string">&quot;The producer service state not OK, maybe started once, &quot;</span></span><br><span class="line">                + <span class="keyword">this</span>.serviceState</span><br><span class="line">                + FAQUrl.suggestTodo(FAQUrl.CLIENT_SERVICE_NOT_OK),</span><br><span class="line">                <span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.mQClientFactory.sendHeartbeatToAllBrokerWithLock();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.timer.scheduleAtFixedRate(<span class="keyword">new</span> TimerTask() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                RequestFutureTable.scanExpiredRequest();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">                log.error(<span class="string">&quot;scan RequestFutureTable exception&quot;</span>, e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, <span class="number">1000</span> * <span class="number">3</span>, <span class="number">1000</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="Consumer"><a href="#Consumer" class="headerlink" title="Consumer"></a>Consumer</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> <span class="keyword">throws</span> MQClientException </span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (<span class="keyword">this</span>.serviceState) &#123;</span><br><span class="line">        <span class="keyword">case</span> CREATE_JUST:</span><br><span class="line">            log.info(<span class="string">&quot;the consumer [&#123;&#125;] start beginning. messageModel=&#123;&#125;, isUnitMode=&#123;&#125;&quot;</span>, <span class="keyword">this</span>.defaultMQPushConsumer.getConsumerGroup(),</span><br><span class="line">                <span class="keyword">this</span>.defaultMQPushConsumer.getMessageModel(), <span class="keyword">this</span>.defaultMQPushConsumer.isUnitMode());</span><br><span class="line">            <span class="keyword">this</span>.serviceState = ServiceState.START_FAILED;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">this</span>.checkConfig();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 构建订阅信息并加入到RebalanceImpl的订阅消息中</span></span><br><span class="line">            <span class="keyword">this</span>.copySubscription();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.defaultMQPushConsumer.getMessageModel() == MessageModel.CLUSTERING) &#123;</span><br><span class="line">                <span class="keyword">this</span>.defaultMQPushConsumer.changeInstanceNameToPID();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 初始化MQClientInstance</span></span><br><span class="line">            <span class="keyword">this</span>.mQClientFactory = MQClientManager.getInstance().getOrCreateMQClientInstance(<span class="keyword">this</span>.defaultMQPushConsumer, <span class="keyword">this</span>.rpcHook);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 初始化RebalanceImpl</span></span><br><span class="line">            <span class="keyword">this</span>.rebalanceImpl.setConsumerGroup(<span class="keyword">this</span>.defaultMQPushConsumer.getConsumerGroup());</span><br><span class="line">            <span class="keyword">this</span>.rebalanceImpl.setMessageModel(<span class="keyword">this</span>.defaultMQPushConsumer.getMessageModel());</span><br><span class="line">            <span class="keyword">this</span>.rebalanceImpl.setAllocateMessageQueueStrategy(<span class="keyword">this</span>.defaultMQPushConsumer.getAllocateMessageQueueStrategy());</span><br><span class="line">            <span class="keyword">this</span>.rebalanceImpl.setmQClientFactory(<span class="keyword">this</span>.mQClientFactory);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">this</span>.pullAPIWrapper = <span class="keyword">new</span> PullAPIWrapper(</span><br><span class="line">                mQClientFactory,</span><br><span class="line">                <span class="keyword">this</span>.defaultMQPushConsumer.getConsumerGroup(), isUnitMode());</span><br><span class="line">            <span class="keyword">this</span>.pullAPIWrapper.registerFilterMessageHook(filterMessageHookList);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 初始化消息进度</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.defaultMQPushConsumer.getOffsetStore() != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">this</span>.offsetStore = <span class="keyword">this</span>.defaultMQPushConsumer.getOffsetStore();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">switch</span> (<span class="keyword">this</span>.defaultMQPushConsumer.getMessageModel()) &#123;</span><br><span class="line">                    <span class="keyword">case</span> BROADCASTING:</span><br><span class="line">                        <span class="comment">// 广播模式，进度存在消费端</span></span><br><span class="line">                        <span class="keyword">this</span>.offsetStore = <span class="keyword">new</span> LocalFileOffsetStore(<span class="keyword">this</span>.mQClientFactory, <span class="keyword">this</span>.defaultMQPushConsumer.getConsumerGroup());</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> CLUSTERING:</span><br><span class="line">                        <span class="comment">// 集群模式，进度存在Broker</span></span><br><span class="line">                        <span class="keyword">this</span>.offsetStore = <span class="keyword">new</span> RemoteBrokerOffsetStore(<span class="keyword">this</span>.mQClientFactory, <span class="keyword">this</span>.defaultMQPushConsumer.getConsumerGroup());</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">default</span>:</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">this</span>.defaultMQPushConsumer.setOffsetStore(<span class="keyword">this</span>.offsetStore);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">this</span>.offsetStore.load();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.getMessageListenerInner() <span class="keyword">instanceof</span> MessageListenerOrderly) &#123;</span><br><span class="line">                <span class="comment">// 顺序消费</span></span><br><span class="line">                <span class="keyword">this</span>.consumeOrderly = <span class="keyword">true</span>;</span><br><span class="line">                <span class="keyword">this</span>.consumeMessageService =</span><br><span class="line">                    <span class="keyword">new</span> ConsumeMessageOrderlyService(<span class="keyword">this</span>, (MessageListenerOrderly) <span class="keyword">this</span>.getMessageListenerInner());</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">this</span>.getMessageListenerInner() <span class="keyword">instanceof</span> MessageListenerConcurrently) &#123;</span><br><span class="line">                <span class="keyword">this</span>.consumeOrderly = <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">this</span>.consumeMessageService =</span><br><span class="line">                    <span class="keyword">new</span> ConsumeMessageConcurrentlyService(<span class="keyword">this</span>, (MessageListenerConcurrently) <span class="keyword">this</span>.getMessageListenerInner());</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">this</span>.consumeMessageService.start();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 向MQClientInstance注册消费者</span></span><br><span class="line">            <span class="keyword">boolean</span> registerOK = mQClientFactory.registerConsumer(<span class="keyword">this</span>.defaultMQPushConsumer.getConsumerGroup(), <span class="keyword">this</span>);</span><br><span class="line">            <span class="keyword">if</span> (!registerOK) &#123;</span><br><span class="line">                <span class="keyword">this</span>.serviceState = ServiceState.CREATE_JUST;</span><br><span class="line">                <span class="keyword">this</span>.consumeMessageService.shutdown();</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> MQClientException(<span class="string">&quot;The consumer group[&quot;</span> + <span class="keyword">this</span>.defaultMQPushConsumer.getConsumerGroup()</span><br><span class="line">                    + <span class="string">&quot;] has been created before, specify another name please.&quot;</span> + FAQUrl.suggestTodo(FAQUrl.GROUP_NAME_DUPLICATE_URL),</span><br><span class="line">                    <span class="keyword">null</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 启动MQClientInstance（统一JVM中的所有的消费者生产者共用同一个MQClientInstance，且MQClientInstance只会启动一次）</span></span><br><span class="line">            mQClientFactory.start();</span><br><span class="line">            log.info(<span class="string">&quot;the consumer [&#123;&#125;] start OK.&quot;</span>, <span class="keyword">this</span>.defaultMQPushConsumer.getConsumerGroup());</span><br><span class="line">            <span class="keyword">this</span>.serviceState = ServiceState.RUNNING;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> RUNNING:</span><br><span class="line">        <span class="keyword">case</span> START_FAILED:</span><br><span class="line">        <span class="keyword">case</span> SHUTDOWN_ALREADY:</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> MQClientException(<span class="string">&quot;The PushConsumer service state not OK, maybe started once, &quot;</span></span><br><span class="line">                + <span class="keyword">this</span>.serviceState</span><br><span class="line">                + FAQUrl.suggestTodo(FAQUrl.CLIENT_SERVICE_NOT_OK),</span><br><span class="line">                <span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.updateTopicSubscribeInfoWhenSubscriptionChanged();</span><br><span class="line">    <span class="keyword">this</span>.mQClientFactory.checkClientInBroker();</span><br><span class="line">    <span class="keyword">this</span>.mQClientFactory.sendHeartbeatToAllBrokerWithLock();</span><br><span class="line">    <span class="keyword">this</span>.mQClientFactory.rebalanceImmediately();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="公共部分"><a href="#公共部分" class="headerlink" title="公共部分"></a>公共部分</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获取实例</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> MQClientInstance <span class="title">getOrCreateMQClientInstance</span><span class="params">(<span class="keyword">final</span> ClientConfig clientConfig, RPCHook rpcHook)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ip + instance + unitname (关于同一个机器的问题，instance是上一步修改的进程id，但是同一个jvm的消费者和生产者，client是同一个)</span></span><br><span class="line">    String clientId = clientConfig.buildMQClientId();</span><br><span class="line">    MQClientInstance instance = <span class="keyword">this</span>.factoryTable.get(clientId);</span><br><span class="line">    <span class="comment">// 同一个clientId只会有一个实例</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">null</span> == instance) &#123;</span><br><span class="line">        instance =</span><br><span class="line">            <span class="comment">// 封装了RocketMQ网络处理的API =》 客户端与NameServer，Broker交互的网络通道</span></span><br><span class="line">            <span class="keyword">new</span> MQClientInstance(clientConfig.cloneClientConfig(),</span><br><span class="line">                <span class="keyword">this</span>.factoryIndexGenerator.getAndIncrement(), clientId, rpcHook);</span><br><span class="line">        MQClientInstance prev = <span class="keyword">this</span>.factoryTable.putIfAbsent(clientId, instance);</span><br><span class="line">        <span class="keyword">if</span> (prev != <span class="keyword">null</span>) &#123;</span><br><span class="line">            instance = prev;</span><br><span class="line">            log.warn(<span class="string">&quot;Returned Previous MQClientInstance for clientId:[&#123;&#125;]&quot;</span>, clientId);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            log.info(<span class="string">&quot;Created new MQClientInstance for clientId:[&#123;&#125;]&quot;</span>, clientId);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> instance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> <span class="keyword">throws</span> MQClientException </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">        <span class="keyword">switch</span> (<span class="keyword">this</span>.serviceState) &#123;</span><br><span class="line">            <span class="keyword">case</span> CREATE_JUST:</span><br><span class="line">                <span class="keyword">this</span>.serviceState = ServiceState.START_FAILED;</span><br><span class="line">                <span class="comment">// If not specified,looking address from name server</span></span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">null</span> == <span class="keyword">this</span>.clientConfig.getNamesrvAddr()) &#123;</span><br><span class="line">                    <span class="keyword">this</span>.mQClientAPIImpl.fetchNameServerAddr();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// Start request-response channel</span></span><br><span class="line">                <span class="keyword">this</span>.mQClientAPIImpl.start();</span><br><span class="line">                <span class="comment">// Start various schedule tasks</span></span><br><span class="line">                <span class="keyword">this</span>.startScheduledTask();</span><br><span class="line">                <span class="comment">// Start pull service</span></span><br><span class="line">                <span class="comment">// 拉取消息</span></span><br><span class="line">                <span class="keyword">this</span>.pullMessageService.start();</span><br><span class="line">                <span class="comment">// Start rebalance service</span></span><br><span class="line">                <span class="keyword">this</span>.rebalanceService.start();</span><br><span class="line">                <span class="comment">// Start push service</span></span><br><span class="line">                <span class="keyword">this</span>.defaultMQProducer.getDefaultMQProducerImpl().start(<span class="keyword">false</span>);</span><br><span class="line">                log.info(<span class="string">&quot;the client factory [&#123;&#125;] start OK&quot;</span>, <span class="keyword">this</span>.clientId);</span><br><span class="line">                <span class="keyword">this</span>.serviceState = ServiceState.RUNNING;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> START_FAILED:</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> MQClientException(<span class="string">&quot;The Factory object[&quot;</span> + <span class="keyword">this</span>.getClientId() + <span class="string">&quot;] has been created before, and failed.&quot;</span>, <span class="keyword">null</span>);</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="备注"><a href="#备注" class="headerlink" title="备注"></a>备注</h3><p>其中，关于消费者的ReblanceImpl流程，加载消费进度之类的，在后续消费者模块会详细介绍。此处就不做过多的介绍</p>
<h1 id="消息发送流程"><a href="#消息发送流程" class="headerlink" title="消息发送流程"></a>消息发送流程</h1><h2 id="Produer-发送消息"><a href="#Produer-发送消息" class="headerlink" title="Produer 发送消息"></a>Produer 发送消息</h2><h3 id="流程图-2"><a href="#流程图-2" class="headerlink" title="流程图"></a>流程图</h3><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://bb3e216f.onedrive-cf-index-ng-e34.pages.dev/api/raw?path=/Public/BlogImg/RocketMQ/Producer%E6%B6%88%E6%81%AF%E5%8F%91%E9%80%81%E6%B5%81%E7%A8%8B.png"
                      alt="Producer消息发送流程.png"
                ></p>
<h3 id="关键代码-1"><a href="#关键代码-1" class="headerlink" title="关键代码"></a>关键代码</h3><h4 id="发送消息主干流程"><a href="#发送消息主干流程" class="headerlink" title="发送消息主干流程"></a>发送消息主干流程</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> SendResult <span class="title">sendDefaultImpl</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    Message msg,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">final</span> CommunicationMode communicationMode,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">final</span> SendCallback sendCallback,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">final</span> <span class="keyword">long</span> timeout</span></span></span><br><span class="line"><span class="params"><span class="function">)</span> <span class="keyword">throws</span> MQClientException, RemotingException, MQBrokerException, InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.makeSureStateOK();</span><br><span class="line">    <span class="comment">// 校验消息topic，内容，长度等</span></span><br><span class="line">    Validators.checkMessage(msg, <span class="keyword">this</span>.defaultMQProducer);</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">long</span> invokeID = random.nextLong();</span><br><span class="line">    <span class="keyword">long</span> beginTimestampFirst = System.currentTimeMillis();</span><br><span class="line">    <span class="keyword">long</span> beginTimestampPrev = beginTimestampFirst;</span><br><span class="line">    <span class="keyword">long</span> endTimestamp = beginTimestampFirst;</span><br><span class="line">    <span class="comment">// 获取主题路由信息</span></span><br><span class="line">    TopicPublishInfo topicPublishInfo = <span class="keyword">this</span>.tryToFindTopicPublishInfo(msg.getTopic());</span><br><span class="line">    <span class="keyword">if</span> (topicPublishInfo != <span class="keyword">null</span> &amp;&amp; topicPublishInfo.ok()) &#123;</span><br><span class="line">        <span class="keyword">boolean</span> callTimeout = <span class="keyword">false</span>;</span><br><span class="line">        MessageQueue mq = <span class="keyword">null</span>;</span><br><span class="line">        Exception exception = <span class="keyword">null</span>;</span><br><span class="line">        SendResult sendResult = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">// 重试次数（异步才重试）</span></span><br><span class="line">        <span class="keyword">int</span> timesTotal = communicationMode == CommunicationMode.SYNC ? <span class="number">1</span> + <span class="keyword">this</span>.defaultMQProducer.getRetryTimesWhenSendFailed() : <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> times = <span class="number">0</span>;</span><br><span class="line">        String[] brokersSent = <span class="keyword">new</span> String[timesTotal];</span><br><span class="line">        <span class="keyword">for</span> (; times &lt; timesTotal; times++) &#123;</span><br><span class="line">            String lastBrokerName = <span class="keyword">null</span> == mq ? <span class="keyword">null</span> : mq.getBrokerName();</span><br><span class="line">            <span class="comment">// 获取的队列</span></span><br><span class="line">            MessageQueue mqSelected = <span class="keyword">this</span>.selectOneMessageQueue(topicPublishInfo, lastBrokerName);</span><br><span class="line">            <span class="keyword">if</span> (mqSelected != <span class="keyword">null</span>) &#123;</span><br><span class="line">                mq = mqSelected;</span><br><span class="line">                brokersSent[times] = mq.getBrokerName();</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    beginTimestampPrev = System.currentTimeMillis();</span><br><span class="line">                    <span class="keyword">if</span> (times &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="comment">//Reset topic with namespace during resend.</span></span><br><span class="line">                        msg.setTopic(<span class="keyword">this</span>.defaultMQProducer.withNamespace(msg.getTopic()));</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">long</span> costTime = beginTimestampPrev - beginTimestampFirst;</span><br><span class="line">                    <span class="keyword">if</span> (timeout &lt; costTime) &#123;</span><br><span class="line">                        callTimeout = <span class="keyword">true</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 发送消息</span></span><br><span class="line">                    sendResult = <span class="keyword">this</span>.sendKernelImpl(msg, mq, communicationMode, sendCallback, topicPublishInfo, timeout - costTime);</span><br><span class="line">                    endTimestamp = System.currentTimeMillis();</span><br><span class="line">                    <span class="comment">// 假如要规避的话，根据具体的消息发送耗时来决定规避</span></span><br><span class="line">                    <span class="keyword">this</span>.updateFaultItem(mq.getBrokerName(), endTimestamp - beginTimestampPrev, <span class="keyword">false</span>);</span><br><span class="line">                    <span class="keyword">switch</span> (communicationMode) &#123;</span><br><span class="line">                        <span class="keyword">case</span> ASYNC:</span><br><span class="line">                            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">                        <span class="keyword">case</span> ONEWAY:</span><br><span class="line">                            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">                        <span class="keyword">case</span> SYNC:</span><br><span class="line">                            <span class="keyword">if</span> (sendResult.getSendStatus() != SendStatus.SEND_OK) &#123;</span><br><span class="line">                                <span class="keyword">if</span> (<span class="keyword">this</span>.defaultMQProducer.isRetryAnotherBrokerWhenNotStoreOK()) &#123;</span><br><span class="line">                                    <span class="keyword">continue</span>;</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;</span><br><span class="line"></span><br><span class="line">                            <span class="keyword">return</span> sendResult;</span><br><span class="line">                        <span class="keyword">default</span>:</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (RemotingException e) &#123;</span><br><span class="line">                    endTimestamp = System.currentTimeMillis();</span><br><span class="line">                    <span class="comment">// 假如要规避的话，isolation = true，直接30s失败规避</span></span><br><span class="line">                    <span class="keyword">this</span>.updateFaultItem(mq.getBrokerName(), endTimestamp - beginTimestampPrev, <span class="keyword">true</span>);</span><br><span class="line">                    log.warn(String.format(<span class="string">&quot;sendKernelImpl exception, resend at once, InvokeID: %s, RT: %sms, Broker: %s&quot;</span>, invokeID, endTimestamp - beginTimestampPrev, mq), e);</span><br><span class="line">                    log.warn(msg.toString());</span><br><span class="line">                    exception = e;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (MQClientException e) &#123;</span><br><span class="line">                    endTimestamp = System.currentTimeMillis();</span><br><span class="line">                    <span class="keyword">this</span>.updateFaultItem(mq.getBrokerName(), endTimestamp - beginTimestampPrev, <span class="keyword">true</span>);</span><br><span class="line">                    log.warn(String.format(<span class="string">&quot;sendKernelImpl exception, resend at once, InvokeID: %s, RT: %sms, Broker: %s&quot;</span>, invokeID, endTimestamp - beginTimestampPrev, mq), e);</span><br><span class="line">                    log.warn(msg.toString());</span><br><span class="line">                    exception = e;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (MQBrokerException e) &#123;</span><br><span class="line">                    endTimestamp = System.currentTimeMillis();</span><br><span class="line">                    <span class="keyword">this</span>.updateFaultItem(mq.getBrokerName(), endTimestamp - beginTimestampPrev, <span class="keyword">true</span>);</span><br><span class="line">                    log.warn(String.format(<span class="string">&quot;sendKernelImpl exception, resend at once, InvokeID: %s, RT: %sms, Broker: %s&quot;</span>, invokeID, endTimestamp - beginTimestampPrev, mq), e);</span><br><span class="line">                    log.warn(msg.toString());</span><br><span class="line">                    exception = e;</span><br><span class="line">                    <span class="keyword">switch</span> (e.getResponseCode()) &#123;</span><br><span class="line">                        <span class="keyword">case</span> ResponseCode.TOPIC_NOT_EXIST:</span><br><span class="line">                        <span class="keyword">case</span> ResponseCode.SERVICE_NOT_AVAILABLE:</span><br><span class="line">                        <span class="keyword">case</span> ResponseCode.SYSTEM_ERROR:</span><br><span class="line">                        <span class="keyword">case</span> ResponseCode.NO_PERMISSION:</span><br><span class="line">                        <span class="keyword">case</span> ResponseCode.NO_BUYER_ID:</span><br><span class="line">                        <span class="keyword">case</span> ResponseCode.NOT_IN_CURRENT_UNIT:</span><br><span class="line">                            <span class="keyword">continue</span>;</span><br><span class="line">                        <span class="keyword">default</span>:</span><br><span class="line">                            <span class="keyword">if</span> (sendResult != <span class="keyword">null</span>) &#123;</span><br><span class="line">                                <span class="keyword">return</span> sendResult;</span><br><span class="line">                            &#125;</span><br><span class="line"></span><br><span class="line">                            <span class="keyword">throw</span> e;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    endTimestamp = System.currentTimeMillis();</span><br><span class="line">                    <span class="keyword">this</span>.updateFaultItem(mq.getBrokerName(), endTimestamp - beginTimestampPrev, <span class="keyword">false</span>);</span><br><span class="line">                    log.warn(String.format(<span class="string">&quot;sendKernelImpl exception, throw exception, InvokeID: %s, RT: %sms, Broker: %s&quot;</span>, invokeID, endTimestamp - beginTimestampPrev, mq), e);</span><br><span class="line">                    log.warn(msg.toString());</span><br><span class="line"></span><br><span class="line">                    log.warn(<span class="string">&quot;sendKernelImpl exception&quot;</span>, e);</span><br><span class="line">                    log.warn(msg.toString());</span><br><span class="line">                    <span class="keyword">throw</span> e;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (sendResult != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> sendResult;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        String info = String.format(<span class="string">&quot;Send [%d] times, still failed, cost [%d]ms, Topic: %s, BrokersSent: %s&quot;</span>,</span><br><span class="line">            times,</span><br><span class="line">            System.currentTimeMillis() - beginTimestampFirst,</span><br><span class="line">            msg.getTopic(),</span><br><span class="line">            Arrays.toString(brokersSent));</span><br><span class="line"></span><br><span class="line">        info += FAQUrl.suggestTodo(FAQUrl.SEND_MSG_FAILED);</span><br><span class="line"></span><br><span class="line">        MQClientException mqClientException = <span class="keyword">new</span> MQClientException(info, exception);</span><br><span class="line">        <span class="keyword">if</span> (callTimeout) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RemotingTooMuchRequestException(<span class="string">&quot;sendDefaultImpl call timeout&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (exception <span class="keyword">instanceof</span> MQBrokerException) &#123;</span><br><span class="line">            mqClientException.setResponseCode(((MQBrokerException) exception).getResponseCode());</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (exception <span class="keyword">instanceof</span> RemotingConnectException) &#123;</span><br><span class="line">            mqClientException.setResponseCode(ClientErrorCode.CONNECT_BROKER_EXCEPTION);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (exception <span class="keyword">instanceof</span> RemotingTimeoutException) &#123;</span><br><span class="line">            mqClientException.setResponseCode(ClientErrorCode.ACCESS_BROKER_TIMEOUT);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (exception <span class="keyword">instanceof</span> MQClientException) &#123;</span><br><span class="line">            mqClientException.setResponseCode(ClientErrorCode.BROKER_NOT_EXIST_EXCEPTION);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">throw</span> mqClientException;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    validateNameServerSetting();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> MQClientException(<span class="string">&quot;No route info of this topic: &quot;</span> + msg.getTopic() + FAQUrl.suggestTodo(FAQUrl.NO_TOPIC_ROUTE_INFO),</span><br><span class="line">        <span class="keyword">null</span>).setResponseCode(ClientErrorCode.NOT_FOUND_TOPIC_EXCEPTION);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="失败规避"><a href="#失败规避" class="headerlink" title="失败规避"></a>失败规避</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="comment">// 开不开启失败规避的区别：</span></span><br><span class="line"><span class="comment">// 开启的话：只要失败一次，就悲观的认为失败的Broker不可用，在接下来一段时间内就不会再发送消息</span></span><br><span class="line"><span class="comment">// 不开启的话：只是在本次消息发送过程中规避该Broker，下次消息发送还是会继续尝试</span></span><br><span class="line"><span class="comment">// 之所以需要失败规避，是因为Broker变动NameServer不会主动推送，而是客户端每隔30s定时去拉取</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> MessageQueue <span class="title">selectOneMessageQueue</span><span class="params">(<span class="keyword">final</span> TopicPublishInfo tpInfo, <span class="keyword">final</span> String lastBrokerName)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 为true代表开启故障延迟机制</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.sendLatencyFaultEnable) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> index = tpInfo.getSendWhichQueue().getAndIncrement();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tpInfo.getMessageQueueList().size(); i++) &#123;</span><br><span class="line">                <span class="keyword">int</span> pos = Math.abs(index++) % tpInfo.getMessageQueueList().size();</span><br><span class="line">                <span class="keyword">if</span> (pos &lt; <span class="number">0</span>)</span><br><span class="line">                    pos = <span class="number">0</span>;</span><br><span class="line">                MessageQueue mq = tpInfo.getMessageQueueList().get(pos);</span><br><span class="line">                <span class="comment">// 当前broker是否可用</span></span><br><span class="line">                <span class="keyword">if</span> (latencyFaultTolerance.isAvailable(mq.getBrokerName())) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (<span class="keyword">null</span> == lastBrokerName || mq.getBrokerName().equals(lastBrokerName))</span><br><span class="line">                        <span class="keyword">return</span> mq;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 没有可用的broker, 从之前的失败规避列表中选出一个broker</span></span><br><span class="line">            <span class="keyword">final</span> String notBestBroker = latencyFaultTolerance.pickOneAtLeast();</span><br><span class="line">            <span class="keyword">int</span> writeQueueNums = tpInfo.getQueueIdByBroker(notBestBroker);</span><br><span class="line">            <span class="keyword">if</span> (writeQueueNums &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">final</span> MessageQueue mq = tpInfo.selectOneMessageQueue();</span><br><span class="line">                <span class="keyword">if</span> (notBestBroker != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    mq.setBrokerName(notBestBroker);</span><br><span class="line">                    mq.setQueueId(tpInfo.getSendWhichQueue().getAndIncrement() % writeQueueNums);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> mq;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                latencyFaultTolerance.remove(notBestBroker);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            log.error(<span class="string">&quot;Error occurred when selecting message queue&quot;</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> tpInfo.selectOneMessageQueue();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> tpInfo.selectOneMessageQueue(lastBrokerName);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">updateFaultItem</span><span class="params">(<span class="keyword">final</span> String brokerName, <span class="keyword">final</span> <span class="keyword">long</span> currentLatency, <span class="keyword">boolean</span> isolation)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// currentLatency 发送消息消耗时间</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.sendLatencyFaultEnable) &#123;</span><br><span class="line">        <span class="keyword">long</span> duration = computeNotAvailableDuration(isolation ? <span class="number">30000</span> : currentLatency);</span><br><span class="line">        <span class="keyword">this</span>.latencyFaultTolerance.updateFaultItem(brokerName, currentLatency, duration);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ConcurrentHashMap&lt;String, FaultItem&gt; faultItemTable = <span class="keyword">new</span> ConcurrentHashMap&lt;String, FaultItem&gt;(<span class="number">16</span>);</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isAvailable</span><span class="params">(<span class="keyword">final</span> String name)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> FaultItem faultItem = <span class="keyword">this</span>.faultItemTable.get(name);</span><br><span class="line">    <span class="keyword">if</span> (faultItem != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> faultItem.isAvailable();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="消息发送具体逻辑"><a href="#消息发送具体逻辑" class="headerlink" title="消息发送具体逻辑"></a>消息发送具体逻辑</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> SendResult <span class="title">sendKernelImpl</span><span class="params">(<span class="keyword">final</span> Message msg,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">final</span> MessageQueue mq,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">final</span> CommunicationMode communicationMode,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">final</span> SendCallback sendCallback,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">final</span> TopicPublishInfo topicPublishInfo,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">final</span> <span class="keyword">long</span> timeout)</span> <span class="keyword">throws</span> MQClientException, RemotingException, MQBrokerException, InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> beginStartTime = System.currentTimeMillis();</span><br><span class="line">    <span class="comment">// 获取broker地址</span></span><br><span class="line">    String brokerAddr = <span class="keyword">this</span>.mQClientFactory.findBrokerAddressInPublish(mq.getBrokerName());</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">null</span> == brokerAddr) &#123;</span><br><span class="line">        <span class="comment">// 从NameServer主动更新topic路由信息</span></span><br><span class="line">        tryToFindTopicPublishInfo(mq.getTopic());</span><br><span class="line">        brokerAddr = <span class="keyword">this</span>.mQClientFactory.findBrokerAddressInPublish(mq.getBrokerName());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    SendMessageContext context = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (brokerAddr != <span class="keyword">null</span>) &#123;</span><br><span class="line">        brokerAddr = MixAll.brokerVIPChannel(<span class="keyword">this</span>.defaultMQProducer.isSendMessageWithVIPChannel(), brokerAddr);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">byte</span>[] prevBody = msg.getBody();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//for MessageBatch,ID has been set in the generating process</span></span><br><span class="line">            <span class="keyword">if</span> (!(msg <span class="keyword">instanceof</span> MessageBatch)) &#123;</span><br><span class="line">                <span class="comment">// 批量发送消息，在生成过程中已设置id</span></span><br><span class="line">                <span class="comment">// 此处针对单挑发送消息的情况，分配全局唯一id</span></span><br><span class="line">                MessageClientIDSetter.setUniqID(msg);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">boolean</span> topicWithNamespace = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">null</span> != <span class="keyword">this</span>.mQClientFactory.getClientConfig().getNamespace()) &#123;</span><br><span class="line">                msg.setInstanceId(<span class="keyword">this</span>.mQClientFactory.getClientConfig().getNamespace());</span><br><span class="line">                topicWithNamespace = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> sysFlag = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">boolean</span> msgBodyCompressed = <span class="keyword">false</span>;</span><br><span class="line">            <span class="comment">// 消息大小默认超过4kb，zip压缩消息</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.tryToCompressMessage(msg)) &#123;</span><br><span class="line">                sysFlag |= MessageSysFlag.COMPRESSED_FLAG;</span><br><span class="line">                msgBodyCompressed = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 如果是事务消息，对sysFlag打上事务消息的标记</span></span><br><span class="line">            <span class="keyword">final</span> String tranMsg = msg.getProperty(MessageConst.PROPERTY_TRANSACTION_PREPARED);</span><br><span class="line">            <span class="keyword">if</span> (tranMsg != <span class="keyword">null</span> &amp;&amp; Boolean.parseBoolean(tranMsg)) &#123;</span><br><span class="line">                sysFlag |= MessageSysFlag.TRANSACTION_PREPARED_TYPE;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (hasCheckForbiddenHook()) &#123;</span><br><span class="line">                CheckForbiddenContext checkForbiddenContext = <span class="keyword">new</span> CheckForbiddenContext();</span><br><span class="line">                checkForbiddenContext.setNameSrvAddr(<span class="keyword">this</span>.defaultMQProducer.getNamesrvAddr());</span><br><span class="line">                checkForbiddenContext.setGroup(<span class="keyword">this</span>.defaultMQProducer.getProducerGroup());</span><br><span class="line">                checkForbiddenContext.setCommunicationMode(communicationMode);</span><br><span class="line">                checkForbiddenContext.setBrokerAddr(brokerAddr);</span><br><span class="line">                checkForbiddenContext.setMessage(msg);</span><br><span class="line">                checkForbiddenContext.setMq(mq);</span><br><span class="line">                checkForbiddenContext.setUnitMode(<span class="keyword">this</span>.isUnitMode());</span><br><span class="line">                <span class="keyword">this</span>.executeCheckForbiddenHook(checkForbiddenContext);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 如果注册了消息钩子函数</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.hasSendMessageHook()) &#123;</span><br><span class="line">                <span class="comment">// 对消息进行增强（发送前后）</span></span><br><span class="line">                context = <span class="keyword">new</span> SendMessageContext();</span><br><span class="line">                context.setProducer(<span class="keyword">this</span>);</span><br><span class="line">                context.setProducerGroup(<span class="keyword">this</span>.defaultMQProducer.getProducerGroup());</span><br><span class="line">                context.setCommunicationMode(communicationMode);</span><br><span class="line">                context.setBornHost(<span class="keyword">this</span>.defaultMQProducer.getClientIP());</span><br><span class="line">                context.setBrokerAddr(brokerAddr);</span><br><span class="line">                context.setMessage(msg);</span><br><span class="line">                context.setMq(mq);</span><br><span class="line">                context.setNamespace(<span class="keyword">this</span>.defaultMQProducer.getNamespace());</span><br><span class="line">                String isTrans = msg.getProperty(MessageConst.PROPERTY_TRANSACTION_PREPARED);</span><br><span class="line">                <span class="keyword">if</span> (isTrans != <span class="keyword">null</span> &amp;&amp; isTrans.equals(<span class="string">&quot;true&quot;</span>)) &#123;</span><br><span class="line">                    context.setMsgType(MessageType.Trans_Msg_Half);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (msg.getProperty(<span class="string">&quot;__STARTDELIVERTIME&quot;</span>) != <span class="keyword">null</span> || msg.getProperty(MessageConst.PROPERTY_DELAY_TIME_LEVEL) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    context.setMsgType(MessageType.Delay_Msg);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">this</span>.executeSendMessageHookBefore(context);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 构建消息发送请求包</span></span><br><span class="line">            SendMessageRequestHeader requestHeader = <span class="keyword">new</span> SendMessageRequestHeader();</span><br><span class="line">            requestHeader.setProducerGroup(<span class="keyword">this</span>.defaultMQProducer.getProducerGroup());</span><br><span class="line">            requestHeader.setTopic(msg.getTopic());</span><br><span class="line">            requestHeader.setDefaultTopic(<span class="keyword">this</span>.defaultMQProducer.getCreateTopicKey());</span><br><span class="line">            requestHeader.setDefaultTopicQueueNums(<span class="keyword">this</span>.defaultMQProducer.getDefaultTopicQueueNums());</span><br><span class="line">            requestHeader.setQueueId(mq.getQueueId());</span><br><span class="line">            requestHeader.setSysFlag(sysFlag);</span><br><span class="line">            requestHeader.setBornTimestamp(System.currentTimeMillis());</span><br><span class="line">            requestHeader.setFlag(msg.getFlag());</span><br><span class="line">            requestHeader.setProperties(MessageDecoder.messageProperties2String(msg.getProperties()));</span><br><span class="line">            requestHeader.setReconsumeTimes(<span class="number">0</span>);</span><br><span class="line">            requestHeader.setUnitMode(<span class="keyword">this</span>.isUnitMode());</span><br><span class="line">            requestHeader.setBatch(msg <span class="keyword">instanceof</span> MessageBatch);</span><br><span class="line">            <span class="keyword">if</span> (requestHeader.getTopic().startsWith(MixAll.RETRY_GROUP_TOPIC_PREFIX)) &#123;</span><br><span class="line">                String reconsumeTimes = MessageAccessor.getReconsumeTime(msg);</span><br><span class="line">                <span class="keyword">if</span> (reconsumeTimes != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    requestHeader.setReconsumeTimes(Integer.valueOf(reconsumeTimes));</span><br><span class="line">                    MessageAccessor.clearProperty(msg, MessageConst.PROPERTY_RECONSUME_TIME);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                String maxReconsumeTimes = MessageAccessor.getMaxReconsumeTimes(msg);</span><br><span class="line">                <span class="keyword">if</span> (maxReconsumeTimes != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    requestHeader.setMaxReconsumeTimes(Integer.valueOf(maxReconsumeTimes));</span><br><span class="line">                    MessageAccessor.clearProperty(msg, MessageConst.PROPERTY_MAX_RECONSUME_TIMES);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            SendResult sendResult = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">switch</span> (communicationMode) &#123;</span><br><span class="line">                <span class="keyword">case</span> ASYNC:</span><br><span class="line">                    Message tmpMessage = msg;</span><br><span class="line">                    <span class="keyword">boolean</span> messageCloned = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="keyword">if</span> (msgBodyCompressed) &#123;</span><br><span class="line">                        <span class="comment">//If msg body was compressed, msgbody should be reset using prevBody.</span></span><br><span class="line">                        <span class="comment">//Clone new message using commpressed message body and recover origin massage.</span></span><br><span class="line">                        <span class="comment">//Fix bug:https://github.com/apache/rocketmq-externals/issues/66</span></span><br><span class="line">                        tmpMessage = MessageAccessor.cloneMessage(msg);</span><br><span class="line">                        messageCloned = <span class="keyword">true</span>;</span><br><span class="line">                        msg.setBody(prevBody);</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (topicWithNamespace) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (!messageCloned) &#123;</span><br><span class="line">                            tmpMessage = MessageAccessor.cloneMessage(msg);</span><br><span class="line">                            messageCloned = <span class="keyword">true</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        msg.setTopic(NamespaceUtil.withoutNamespace(msg.getTopic(), <span class="keyword">this</span>.defaultMQProducer.getNamespace()));</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">long</span> costTimeAsync = System.currentTimeMillis() - beginStartTime;</span><br><span class="line">                    <span class="keyword">if</span> (timeout &lt; costTimeAsync) &#123;</span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> RemotingTooMuchRequestException(<span class="string">&quot;sendKernelImpl call timeout&quot;</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                    sendResult = <span class="keyword">this</span>.mQClientFactory.getMQClientAPIImpl().sendMessage(</span><br><span class="line">                        brokerAddr,</span><br><span class="line">                        mq.getBrokerName(),</span><br><span class="line">                        tmpMessage,</span><br><span class="line">                        requestHeader,</span><br><span class="line">                        timeout - costTimeAsync,</span><br><span class="line">                        communicationMode,</span><br><span class="line">                        sendCallback,</span><br><span class="line">                        topicPublishInfo,</span><br><span class="line">                        <span class="keyword">this</span>.mQClientFactory,</span><br><span class="line">                        <span class="keyword">this</span>.defaultMQProducer.getRetryTimesWhenSendAsyncFailed(),</span><br><span class="line">                        context,</span><br><span class="line">                        <span class="keyword">this</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> ONEWAY:</span><br><span class="line">                <span class="keyword">case</span> SYNC:</span><br><span class="line">                    <span class="keyword">long</span> costTimeSync = System.currentTimeMillis() - beginStartTime;</span><br><span class="line">                    <span class="keyword">if</span> (timeout &lt; costTimeSync) &#123;</span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> RemotingTooMuchRequestException(<span class="string">&quot;sendKernelImpl call timeout&quot;</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                    sendResult = <span class="keyword">this</span>.mQClientFactory.getMQClientAPIImpl().sendMessage(</span><br><span class="line">                        brokerAddr,</span><br><span class="line">                        mq.getBrokerName(),</span><br><span class="line">                        msg,</span><br><span class="line">                        requestHeader,</span><br><span class="line">                        timeout - costTimeSync,</span><br><span class="line">                        communicationMode,</span><br><span class="line">                        context,</span><br><span class="line">                        <span class="keyword">this</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">default</span>:</span><br><span class="line">                    <span class="keyword">assert</span> <span class="keyword">false</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.hasSendMessageHook()) &#123;</span><br><span class="line">                context.setSendResult(sendResult);</span><br><span class="line">                <span class="keyword">this</span>.executeSendMessageHookAfter(context);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> sendResult;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RemotingException e) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.hasSendMessageHook()) &#123;</span><br><span class="line">                context.setException(e);</span><br><span class="line">                <span class="keyword">this</span>.executeSendMessageHookAfter(context);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">throw</span> e;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (MQBrokerException e) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.hasSendMessageHook()) &#123;</span><br><span class="line">                context.setException(e);</span><br><span class="line">                <span class="keyword">this</span>.executeSendMessageHookAfter(context);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">throw</span> e;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.hasSendMessageHook()) &#123;</span><br><span class="line">                context.setException(e);</span><br><span class="line">                <span class="keyword">this</span>.executeSendMessageHookAfter(context);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">throw</span> e;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            msg.setBody(prevBody);</span><br><span class="line">            msg.setTopic(NamespaceUtil.withoutNamespace(msg.getTopic(), <span class="keyword">this</span>.defaultMQProducer.getNamespace()));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> MQClientException(<span class="string">&quot;The broker[&quot;</span> + mq.getBrokerName() + <span class="string">&quot;] not exist&quot;</span>, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Broker-接收消息"><a href="#Broker-接收消息" class="headerlink" title="Broker 接收消息"></a>Broker 接收消息</h2><h3 id="流程图-3"><a href="#流程图-3" class="headerlink" title="流程图"></a>流程图</h3><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://bb3e216f.onedrive-cf-index-ng-e34.pages.dev/api/raw?path=/Public/BlogImg/RocketMQ/Broker%E6%B6%88%E6%81%AF%E5%8F%91%E9%80%81%E6%B5%81%E7%A8%8B.png"
                      alt="Broker消息发送流程.png"
                ></p>
<h3 id="关键代码-2"><a href="#关键代码-2" class="headerlink" title="关键代码"></a>关键代码</h3><h4 id="主干流程"><a href="#主干流程" class="headerlink" title="主干流程"></a>主干流程</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> RemotingCommand <span class="title">sendMessage</span><span class="params">(<span class="keyword">final</span> ChannelHandlerContext ctx,</span></span></span><br><span class="line"><span class="params"><span class="function">                                    <span class="keyword">final</span> RemotingCommand request,</span></span></span><br><span class="line"><span class="params"><span class="function">                                    <span class="keyword">final</span> SendMessageContext sendMessageContext,</span></span></span><br><span class="line"><span class="params"><span class="function">                                    <span class="keyword">final</span> SendMessageRequestHeader requestHeader)</span> <span class="keyword">throws</span> RemotingCommandException </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> RemotingCommand response = RemotingCommand.createResponseCommand(SendMessageResponseHeader.class);</span><br><span class="line">    <span class="keyword">final</span> SendMessageResponseHeader responseHeader = (SendMessageResponseHeader)response.readCustomHeader();</span><br><span class="line"></span><br><span class="line">    response.setOpaque(request.getOpaque());</span><br><span class="line"></span><br><span class="line">    response.addExtField(MessageConst.PROPERTY_MSG_REGION, <span class="keyword">this</span>.brokerController.getBrokerConfig().getRegionId());</span><br><span class="line">    response.addExtField(MessageConst.PROPERTY_TRACE_SWITCH, String.valueOf(<span class="keyword">this</span>.brokerController.getBrokerConfig().isTraceOn()));</span><br><span class="line"></span><br><span class="line">    log.debug(<span class="string">&quot;receive SendMessage request command, &#123;&#125;&quot;</span>, request);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">long</span> startTimstamp = <span class="keyword">this</span>.brokerController.getBrokerConfig().getStartAcceptSendRequestTimeStamp();</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.brokerController.getMessageStore().now() &lt; startTimstamp) &#123;</span><br><span class="line">        response.setCode(ResponseCode.SYSTEM_ERROR);</span><br><span class="line">        response.setRemark(String.format(<span class="string">&quot;broker unable to service, until %s&quot;</span>, UtilAll.timeMillisToHumanString2(startTimstamp)));</span><br><span class="line">        <span class="keyword">return</span> response;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    response.setCode(-<span class="number">1</span>);</span><br><span class="line">    <span class="comment">// 消息校验</span></span><br><span class="line">    <span class="keyword">super</span>.msgCheck(ctx, requestHeader, response);</span><br><span class="line">    <span class="keyword">if</span> (response.getCode() != -<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> response;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">byte</span>[] body = request.getBody();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> queueIdInt = requestHeader.getQueueId();</span><br><span class="line">    TopicConfig topicConfig = <span class="keyword">this</span>.brokerController.getTopicConfigManager().selectTopicConfig(requestHeader.getTopic());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (queueIdInt &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        queueIdInt = Math.abs(<span class="keyword">this</span>.random.nextInt() % <span class="number">99999999</span>) % topicConfig.getWriteQueueNums();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    MessageExtBrokerInner msgInner = <span class="keyword">new</span> MessageExtBrokerInner();</span><br><span class="line">    msgInner.setTopic(requestHeader.getTopic());</span><br><span class="line">    msgInner.setQueueId(queueIdInt);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 校验重试次数是否超过最大次数，超过则丢入死信队列</span></span><br><span class="line">    <span class="comment">// %DLQ%+消费组名</span></span><br><span class="line">    <span class="keyword">if</span> (!handleRetryAndDLQ(requestHeader, response, request, msgInner, topicConfig)) &#123;</span><br><span class="line">        <span class="keyword">return</span> response;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    msgInner.setBody(body);</span><br><span class="line">    msgInner.setFlag(requestHeader.getFlag());</span><br><span class="line">    MessageAccessor.setProperties(msgInner, MessageDecoder.string2messageProperties(requestHeader.getProperties()));</span><br><span class="line">    msgInner.setBornTimestamp(requestHeader.getBornTimestamp());</span><br><span class="line">    msgInner.setBornHost(ctx.channel().remoteAddress());</span><br><span class="line">    msgInner.setStoreHost(<span class="keyword">this</span>.getStoreHost());</span><br><span class="line">    msgInner.setReconsumeTimes(requestHeader.getReconsumeTimes() == <span class="keyword">null</span> ? <span class="number">0</span> : requestHeader.getReconsumeTimes());</span><br><span class="line">    String clusterName = <span class="keyword">this</span>.brokerController.getBrokerConfig().getBrokerClusterName();</span><br><span class="line">    MessageAccessor.putProperty(msgInner, MessageConst.PROPERTY_CLUSTER, clusterName);</span><br><span class="line">    msgInner.setPropertiesString(MessageDecoder.messageProperties2String(msgInner.getProperties()));</span><br><span class="line">    PutMessageResult putMessageResult = <span class="keyword">null</span>;</span><br><span class="line">    Map&lt;String, String&gt; oriProps = MessageDecoder.string2messageProperties(requestHeader.getProperties());</span><br><span class="line">    String traFlag = oriProps.get(MessageConst.PROPERTY_TRANSACTION_PREPARED);</span><br><span class="line">    <span class="keyword">if</span> (traFlag != <span class="keyword">null</span> &amp;&amp; Boolean.parseBoolean(traFlag)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.brokerController.getBrokerConfig().isRejectTransactionMessage()) &#123;</span><br><span class="line">            response.setCode(ResponseCode.NO_PERMISSION);</span><br><span class="line">            response.setRemark(</span><br><span class="line">                <span class="string">&quot;the broker[&quot;</span> + <span class="keyword">this</span>.brokerController.getBrokerConfig().getBrokerIP1()</span><br><span class="line">                    + <span class="string">&quot;] sending transaction message is forbidden&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> response;</span><br><span class="line">        &#125;</span><br><span class="line">        putMessageResult = <span class="keyword">this</span>.brokerController.getTransactionalMessageService().prepareMessage(msgInner);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 存储消息</span></span><br><span class="line">        putMessageResult = <span class="keyword">this</span>.brokerController.getMessageStore().putMessage(msgInner);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> handlePutMessageResult(putMessageResult, response, request, msgInner, responseHeader, sendMessageContext, ctx, queueIdInt);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="校验消息"><a href="#校验消息" class="headerlink" title="校验消息"></a>校验消息</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">protected</span> RemotingCommand <span class="title">msgCheck</span><span class="params">(<span class="keyword">final</span> ChannelHandlerContext ctx,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">final</span> SendMessageRequestHeader requestHeader, <span class="keyword">final</span> RemotingCommand response)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 校验broker是否有写的权限</span></span><br><span class="line">    <span class="keyword">if</span> (!PermName.isWriteable(<span class="keyword">this</span>.brokerController.getBrokerConfig().getBrokerPermission())</span><br><span class="line">        &amp;&amp; <span class="keyword">this</span>.brokerController.getTopicConfigManager().isOrderTopic(requestHeader.getTopic())) &#123;</span><br><span class="line">        response.setCode(ResponseCode.NO_PERMISSION);</span><br><span class="line">        response.setRemark(<span class="string">&quot;the broker[&quot;</span> + <span class="keyword">this</span>.brokerController.getBrokerConfig().getBrokerIP1()</span><br><span class="line">            + <span class="string">&quot;] sending message is forbidden&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> response;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 检查topic是否可以进行消息发送，主要针对默认主题，默认主题不能发送消息，仅供路由查找</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">this</span>.brokerController.getTopicConfigManager().isTopicCanSendMessage(requestHeader.getTopic())) &#123;</span><br><span class="line">        String errorMsg = <span class="string">&quot;the topic[&quot;</span> + requestHeader.getTopic() + <span class="string">&quot;] is conflict with system reserved words.&quot;</span>;</span><br><span class="line">        log.warn(errorMsg);</span><br><span class="line">        response.setCode(ResponseCode.SYSTEM_ERROR);</span><br><span class="line">        response.setRemark(errorMsg);</span><br><span class="line">        <span class="keyword">return</span> response;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取topic信息</span></span><br><span class="line">    TopicConfig topicConfig =</span><br><span class="line">        <span class="keyword">this</span>.brokerController.getTopicConfigManager().selectTopicConfig(requestHeader.getTopic());</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">null</span> == topicConfig) &#123;</span><br><span class="line">        <span class="keyword">int</span> topicSysFlag = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (requestHeader.isUnitMode()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (requestHeader.getTopic().startsWith(MixAll.RETRY_GROUP_TOPIC_PREFIX)) &#123;</span><br><span class="line">                topicSysFlag = TopicSysFlag.buildSysFlag(<span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                topicSysFlag = TopicSysFlag.buildSysFlag(<span class="keyword">true</span>, <span class="keyword">false</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        log.warn(<span class="string">&quot;the topic &#123;&#125; not exist, producer: &#123;&#125;&quot;</span>, requestHeader.getTopic(), ctx.channel().remoteAddress());</span><br><span class="line">        topicConfig = <span class="keyword">this</span>.brokerController.getTopicConfigManager().createTopicInSendMessageMethod(</span><br><span class="line">            requestHeader.getTopic(),</span><br><span class="line">            requestHeader.getDefaultTopic(),</span><br><span class="line">            RemotingHelper.parseChannelRemoteAddr(ctx.channel()),</span><br><span class="line">            requestHeader.getDefaultTopicQueueNums(), topicSysFlag);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> == topicConfig) &#123;</span><br><span class="line">            <span class="keyword">if</span> (requestHeader.getTopic().startsWith(MixAll.RETRY_GROUP_TOPIC_PREFIX)) &#123;</span><br><span class="line">                topicConfig =</span><br><span class="line">                    <span class="keyword">this</span>.brokerController.getTopicConfigManager().createTopicInSendMessageBackMethod(</span><br><span class="line">                        requestHeader.getTopic(), <span class="number">1</span>, PermName.PERM_WRITE | PermName.PERM_READ,</span><br><span class="line">                        topicSysFlag);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> == topicConfig) &#123;</span><br><span class="line">            response.setCode(ResponseCode.TOPIC_NOT_EXIST);</span><br><span class="line">            response.setRemark(<span class="string">&quot;topic[&quot;</span> + requestHeader.getTopic() + <span class="string">&quot;] not exist, apply first please!&quot;</span></span><br><span class="line">                + FAQUrl.suggestTodo(FAQUrl.APPLY_TOPIC_URL));</span><br><span class="line">            <span class="keyword">return</span> response;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查队列id是否有效</span></span><br><span class="line">    <span class="keyword">int</span> queueIdInt = requestHeader.getQueueId();</span><br><span class="line">    <span class="keyword">int</span> idValid = Math.max(topicConfig.getWriteQueueNums(), topicConfig.getReadQueueNums());</span><br><span class="line">    <span class="keyword">if</span> (queueIdInt &gt;= idValid) &#123;</span><br><span class="line">        String errorInfo = String.format(<span class="string">&quot;request queueId[%d] is illegal, %s Producer: %s&quot;</span>,</span><br><span class="line">            queueIdInt,</span><br><span class="line">            topicConfig.toString(),</span><br><span class="line">            RemotingHelper.parseChannelRemoteAddr(ctx.channel()));</span><br><span class="line"></span><br><span class="line">        log.warn(errorInfo);</span><br><span class="line">        response.setCode(ResponseCode.SYSTEM_ERROR);</span><br><span class="line">        response.setRemark(errorInfo);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> response;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> response;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Broker接收到消息之后，就涉及到了消息的存储与刷盘</p>
<h1 id="消息存储流程"><a href="#消息存储流程" class="headerlink" title="消息存储流程"></a>消息存储流程</h1><h2 id="消息存储"><a href="#消息存储" class="headerlink" title="消息存储"></a>消息存储</h2><h3 id="流程图-4"><a href="#流程图-4" class="headerlink" title="流程图"></a>流程图</h3><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://bb3e216f.onedrive-cf-index-ng-e34.pages.dev/api/raw?path=/Public/BlogImg/RocketMQ/Broker%E5%AD%98%E5%82%A8%E6%B6%88%E6%81%AF%E6%B5%81%E7%A8%8B.png"
                      alt="Broker存储消息流程.png"
                ></p>
<h3 id="关键代码-3"><a href="#关键代码-3" class="headerlink" title="关键代码"></a>关键代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> PutMessageResult <span class="title">putMessage</span><span class="params">(MessageExtBrokerInner msg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.shutdown) &#123;</span><br><span class="line">        log.warn(<span class="string">&quot;message store has shutdown, so putMessage is forbidden&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> PutMessageResult(PutMessageStatus.SERVICE_NOT_AVAILABLE, <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (BrokerRole.SLAVE == <span class="keyword">this</span>.messageStoreConfig.getBrokerRole()) &#123;</span><br><span class="line">        <span class="keyword">long</span> value = <span class="keyword">this</span>.printTimes.getAndIncrement();</span><br><span class="line">        <span class="keyword">if</span> ((value % <span class="number">50000</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">            log.warn(<span class="string">&quot;message store is slave mode, so putMessage is forbidden &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> PutMessageResult(PutMessageStatus.SERVICE_NOT_AVAILABLE, <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 磁盘空间不足</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">this</span>.runningFlags.isWriteable()) &#123;</span><br><span class="line">        <span class="keyword">long</span> value = <span class="keyword">this</span>.printTimes.getAndIncrement();</span><br><span class="line">        <span class="keyword">if</span> ((value % <span class="number">50000</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">            log.warn(<span class="string">&quot;message store is not writeable, so putMessage is forbidden &quot;</span> + <span class="keyword">this</span>.runningFlags.getFlagBits());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> PutMessageResult(PutMessageStatus.SERVICE_NOT_AVAILABLE, <span class="keyword">null</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.printTimes.set(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 消息topic长度不能超过127个字符</span></span><br><span class="line">    <span class="keyword">if</span> (msg.getTopic().length() &gt; Byte.MAX_VALUE) &#123;</span><br><span class="line">        log.warn(<span class="string">&quot;putMessage message topic length too long &quot;</span> + msg.getTopic().length());</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> PutMessageResult(PutMessageStatus.MESSAGE_ILLEGAL, <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 消息属性长度不能超过32767</span></span><br><span class="line">    <span class="keyword">if</span> (msg.getPropertiesString() != <span class="keyword">null</span> &amp;&amp; msg.getPropertiesString().length() &gt; Short.MAX_VALUE) &#123;</span><br><span class="line">        log.warn(<span class="string">&quot;putMessage message properties length too long &quot;</span> + msg.getPropertiesString().length());</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> PutMessageResult(PutMessageStatus.PROPERTIES_SIZE_EXCEEDED, <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.isOSPageCacheBusy()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> PutMessageResult(PutMessageStatus.OS_PAGECACHE_BUSY, <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">long</span> beginTime = <span class="keyword">this</span>.getSystemClock().now();</span><br><span class="line">    PutMessageResult result = <span class="keyword">this</span>.commitLog.putMessage(msg);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">long</span> elapsedTime = <span class="keyword">this</span>.getSystemClock().now() - beginTime;</span><br><span class="line">    <span class="keyword">if</span> (elapsedTime &gt; <span class="number">500</span>) &#123;</span><br><span class="line">        log.warn(<span class="string">&quot;putMessage not in lock elapsed time(ms)=&#123;&#125;, bodyLength=&#123;&#125;&quot;</span>, elapsedTime, msg.getBody().length);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.storeStatsService.setPutMessageEntireTimeMax(elapsedTime);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">null</span> == result || !result.isOk()) &#123;</span><br><span class="line">        <span class="keyword">this</span>.storeStatsService.getPutMessageFailedTimes().incrementAndGet();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> PutMessageResult <span class="title">putMessage</span><span class="params">(<span class="keyword">final</span> MessageExtBrokerInner msg)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Set the storage time</span></span><br><span class="line">    msg.setStoreTimestamp(System.currentTimeMillis());</span><br><span class="line">    <span class="comment">// Set the message body BODY CRC (consider the most appropriate setting</span></span><br><span class="line">    <span class="comment">// on the client)</span></span><br><span class="line">    msg.setBodyCRC(UtilAll.crc32(msg.getBody()));</span><br><span class="line">    <span class="comment">// Back to Results</span></span><br><span class="line">    AppendMessageResult result = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    StoreStatsService storeStatsService = <span class="keyword">this</span>.defaultMessageStore.getStoreStatsService();</span><br><span class="line"></span><br><span class="line">    String topic = msg.getTopic();</span><br><span class="line">    <span class="keyword">int</span> queueId = msg.getQueueId();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 事务消息逻辑</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> tranType = MessageSysFlag.getTransactionValue(msg.getSysFlag());</span><br><span class="line">    <span class="comment">// 非事务消息 或 事务已经提交</span></span><br><span class="line">    <span class="keyword">if</span> (tranType == MessageSysFlag.TRANSACTION_NOT_TYPE</span><br><span class="line">        || tranType == MessageSysFlag.TRANSACTION_COMMIT_TYPE) &#123;</span><br><span class="line">        <span class="comment">// Delay Delivery</span></span><br><span class="line">        <span class="keyword">if</span> (msg.getDelayTimeLevel() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 设置延时等级</span></span><br><span class="line">            <span class="keyword">if</span> (msg.getDelayTimeLevel() &gt; <span class="keyword">this</span>.defaultMessageStore.getScheduleMessageService().getMaxDelayLevel()) &#123;</span><br><span class="line">                msg.setDelayTimeLevel(<span class="keyword">this</span>.defaultMessageStore.getScheduleMessageService().getMaxDelayLevel());</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 替换topic为 SCHEDULE_TOPIC_XXXX , 延时消息的topic</span></span><br><span class="line">            topic = ScheduleMessageService.SCHEDULE_TOPIC;</span><br><span class="line">            <span class="comment">// 计算要丢到哪个队列中 根据延时等级计算队列id</span></span><br><span class="line">            queueId = ScheduleMessageService.delayLevel2QueueId(msg.getDelayTimeLevel());</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Backup real topic, queueId</span></span><br><span class="line">            MessageAccessor.putProperty(msg, MessageConst.PROPERTY_REAL_TOPIC, msg.getTopic());</span><br><span class="line">            MessageAccessor.putProperty(msg, MessageConst.PROPERTY_REAL_QUEUE_ID, String.valueOf(msg.getQueueId()));</span><br><span class="line">            msg.setPropertiesString(MessageDecoder.messageProperties2String(msg.getProperties()));</span><br><span class="line"></span><br><span class="line">            msg.setTopic(topic);</span><br><span class="line">            msg.setQueueId(queueId);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    InetSocketAddress bornSocketAddress = (InetSocketAddress) msg.getBornHost();</span><br><span class="line">    <span class="keyword">if</span> (bornSocketAddress.getAddress() <span class="keyword">instanceof</span> Inet6Address) &#123;</span><br><span class="line">        msg.setBornHostV6Flag();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    InetSocketAddress storeSocketAddress = (InetSocketAddress) msg.getStoreHost();</span><br><span class="line">    <span class="keyword">if</span> (storeSocketAddress.getAddress() <span class="keyword">instanceof</span> Inet6Address) &#123;</span><br><span class="line">        msg.setStoreHostAddressV6Flag();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">long</span> eclipsedTimeInLock = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取mappedFile</span></span><br><span class="line">    MappedFile unlockMappedFile = <span class="keyword">null</span>;</span><br><span class="line">    MappedFile mappedFile = <span class="keyword">this</span>.mappedFileQueue.getLastMappedFile();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 申请锁</span></span><br><span class="line">    putMessageLock.lock(); <span class="comment">//spin or ReentrantLock ,depending on store config</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">long</span> beginLockTimestamp = <span class="keyword">this</span>.defaultMessageStore.getSystemClock().now();</span><br><span class="line">        <span class="keyword">this</span>.beginTimeInLock = beginLockTimestamp;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Here settings are stored timestamp, in order to ensure an orderly</span></span><br><span class="line">        <span class="comment">// global</span></span><br><span class="line">        msg.setStoreTimestamp(beginLockTimestamp);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 代表第一次写入，以偏移量0创建CommitLog文件</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> == mappedFile || mappedFile.isFull()) &#123;</span><br><span class="line">            mappedFile = <span class="keyword">this</span>.mappedFileQueue.getLastMappedFile(<span class="number">0</span>); <span class="comment">// Mark: NewFile may be cause noise</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> == mappedFile) &#123;</span><br><span class="line">            log.error(<span class="string">&quot;create mapped file1 error, topic: &quot;</span> + msg.getTopic() + <span class="string">&quot; clientAddr: &quot;</span> + msg.getBornHostString());</span><br><span class="line">            beginTimeInLock = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> PutMessageResult(PutMessageStatus.CREATE_MAPEDFILE_FAILED, <span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 写入消息</span></span><br><span class="line">        result = mappedFile.appendMessage(msg, <span class="keyword">this</span>.appendMessageCallback);</span><br><span class="line">        <span class="keyword">switch</span> (result.getStatus()) &#123;</span><br><span class="line">            <span class="keyword">case</span> PUT_OK:</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> END_OF_FILE:</span><br><span class="line">                unlockMappedFile = mappedFile;</span><br><span class="line">                <span class="comment">// Create a new file, re-write the message</span></span><br><span class="line">                mappedFile = <span class="keyword">this</span>.mappedFileQueue.getLastMappedFile(<span class="number">0</span>);</span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">null</span> == mappedFile) &#123;</span><br><span class="line">                    <span class="comment">// <span class="doctag">XXX:</span> warn and notify me</span></span><br><span class="line">                    log.error(<span class="string">&quot;create mapped file2 error, topic: &quot;</span> + msg.getTopic() + <span class="string">&quot; clientAddr: &quot;</span> + msg.getBornHostString());</span><br><span class="line">                    beginTimeInLock = <span class="number">0</span>;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">new</span> PutMessageResult(PutMessageStatus.CREATE_MAPEDFILE_FAILED, result);</span><br><span class="line">                &#125;</span><br><span class="line">                result = mappedFile.appendMessage(msg, <span class="keyword">this</span>.appendMessageCallback);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> MESSAGE_SIZE_EXCEEDED:</span><br><span class="line">            <span class="keyword">case</span> PROPERTIES_SIZE_EXCEEDED:</span><br><span class="line">                beginTimeInLock = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> PutMessageResult(PutMessageStatus.MESSAGE_ILLEGAL, result);</span><br><span class="line">            <span class="keyword">case</span> UNKNOWN_ERROR:</span><br><span class="line">                beginTimeInLock = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> PutMessageResult(PutMessageStatus.UNKNOWN_ERROR, result);</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                beginTimeInLock = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> PutMessageResult(PutMessageStatus.UNKNOWN_ERROR, result);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        eclipsedTimeInLock = <span class="keyword">this</span>.defaultMessageStore.getSystemClock().now() - beginLockTimestamp;</span><br><span class="line">        beginTimeInLock = <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// 释放锁</span></span><br><span class="line">        putMessageLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (eclipsedTimeInLock &gt; <span class="number">500</span>) &#123;</span><br><span class="line">        log.warn(<span class="string">&quot;[NOTIFYME]putMessage in lock cost time(ms)=&#123;&#125;, bodyLength=&#123;&#125; AppendMessageResult=&#123;&#125;&quot;</span>, eclipsedTimeInLock, msg.getBody().length, result);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">null</span> != unlockMappedFile &amp;&amp; <span class="keyword">this</span>.defaultMessageStore.getMessageStoreConfig().isWarmMapedFileEnable()) &#123;</span><br><span class="line">        <span class="keyword">this</span>.defaultMessageStore.unlockMappedFile(unlockMappedFile);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    PutMessageResult putMessageResult = <span class="keyword">new</span> PutMessageResult(PutMessageStatus.PUT_OK, result);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Statistics</span></span><br><span class="line">    storeStatsService.getSinglePutMessageTopicTimesTotal(msg.getTopic()).incrementAndGet();</span><br><span class="line">    storeStatsService.getSinglePutMessageTopicSizeTotal(topic).addAndGet(result.getWroteBytes());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 刷盘</span></span><br><span class="line">    handleDiskFlush(result, putMessageResult, msg);</span><br><span class="line">    <span class="comment">// HA主从同步复制</span></span><br><span class="line">    handleHA(result, putMessageResult, msg);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> putMessageResult;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> AppendMessageResult <span class="title">appendMessagesInner</span><span class="params">(<span class="keyword">final</span> MessageExt messageExt, <span class="keyword">final</span> AppendMessageCallback cb)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">assert</span> messageExt != <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">assert</span> cb != <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> currentPos = <span class="keyword">this</span>.wrotePosition.get();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (currentPos &lt; <span class="keyword">this</span>.fileSize) &#123;</span><br><span class="line">        <span class="comment">// 创建一个与原ByteBuffer共享的内存区(根据是否开启堆外内存来决定使用 writeBuffer 还是 mappedByteBuffer)</span></span><br><span class="line">        ByteBuffer byteBuffer = writeBuffer != <span class="keyword">null</span> ? writeBuffer.slice() : <span class="keyword">this</span>.mappedByteBuffer.slice();</span><br><span class="line">        byteBuffer.position(currentPos);</span><br><span class="line">        AppendMessageResult result;</span><br><span class="line">        <span class="keyword">if</span> (messageExt <span class="keyword">instanceof</span> MessageExtBrokerInner) &#123;</span><br><span class="line">            result = cb.doAppend(<span class="keyword">this</span>.getFileFromOffset(), byteBuffer, <span class="keyword">this</span>.fileSize - currentPos, (MessageExtBrokerInner) messageExt);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (messageExt <span class="keyword">instanceof</span> MessageExtBatch) &#123;</span><br><span class="line">            result = cb.doAppend(<span class="keyword">this</span>.getFileFromOffset(), byteBuffer, <span class="keyword">this</span>.fileSize - currentPos, (MessageExtBatch) messageExt);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> AppendMessageResult(AppendMessageStatus.UNKNOWN_ERROR);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.wrotePosition.addAndGet(result.getWroteBytes());</span><br><span class="line">        <span class="keyword">this</span>.storeTimestamp = result.getStoreTimestamp();</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 代表文件写满</span></span><br><span class="line">    log.error(<span class="string">&quot;MappedFile.appendMessage return null, wrotePosition: &#123;&#125; fileSize: &#123;&#125;&quot;</span>, currentPos, <span class="keyword">this</span>.fileSize);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> AppendMessageResult(AppendMessageStatus.UNKNOWN_ERROR);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="消息刷盘"><a href="#消息刷盘" class="headerlink" title="消息刷盘"></a>消息刷盘</h2><h3 id="流程图-5"><a href="#流程图-5" class="headerlink" title="流程图"></a>流程图</h3><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://bb3e216f.onedrive-cf-index-ng-e34.pages.dev/api/raw?path=/Public/BlogImg/RocketMQ/RocketMQ%20CommitLog%20%E5%88%B7%E7%9B%98.png"
                      alt="RocketMQ CommitLog 刷盘.png"
                ></p>
<h3 id="关键代码-4"><a href="#关键代码-4" class="headerlink" title="关键代码"></a>关键代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleDiskFlush</span><span class="params">(AppendMessageResult result, PutMessageResult putMessageResult, MessageExt messageExt)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Synchronization flush</span></span><br><span class="line">    <span class="keyword">if</span> (FlushDiskType.SYNC_FLUSH == <span class="keyword">this</span>.defaultMessageStore.getMessageStoreConfig().getFlushDiskType()) &#123;</span><br><span class="line">        <span class="keyword">final</span> GroupCommitService service = (GroupCommitService) <span class="keyword">this</span>.flushCommitLogService;</span><br><span class="line">        <span class="keyword">if</span> (messageExt.isWaitStoreMsgOK()) &#123;</span><br><span class="line">            <span class="comment">// 构建 GroupCommitRequest 同步任务并提交到 GroupCommitService</span></span><br><span class="line">            GroupCommitRequest request = <span class="keyword">new</span> GroupCommitRequest(result.getWroteOffset() + result.getWroteBytes());</span><br><span class="line">            service.putRequest(request);</span><br><span class="line">            <span class="keyword">boolean</span> flushOK = request.waitForFlush(<span class="keyword">this</span>.defaultMessageStore.getMessageStoreConfig().getSyncFlushTimeout());</span><br><span class="line">            <span class="keyword">if</span> (!flushOK) &#123;</span><br><span class="line">                log.error(<span class="string">&quot;do groupcommit, wait for flush failed, topic: &quot;</span> + messageExt.getTopic() + <span class="string">&quot; tags: &quot;</span> + messageExt.getTags()</span><br><span class="line">                    + <span class="string">&quot; client address: &quot;</span> + messageExt.getBornHostString());</span><br><span class="line">                putMessageResult.setPutMessageStatus(PutMessageStatus.FLUSH_DISK_TIMEOUT);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            service.wakeup();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Asynchronous flush</span></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="keyword">this</span>.defaultMessageStore.getMessageStoreConfig().isTransientStorePoolEnable()) &#123;</span><br><span class="line">            flushCommitLogService.wakeup();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            commitLogService.wakeup();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    CommitLog.log.info(<span class="keyword">this</span>.getServiceName() + <span class="string">&quot; service started&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!<span class="keyword">this</span>.isStopped()) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">this</span>.waitForRunning(<span class="number">10</span>);</span><br><span class="line">            <span class="keyword">this</span>.doCommit();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            CommitLog.log.warn(<span class="keyword">this</span>.getServiceName() + <span class="string">&quot; service has exception. &quot;</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Under normal circumstances shutdown, wait for the arrival of the</span></span><br><span class="line">    <span class="comment">// request, and then flush</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Thread.sleep(<span class="number">10</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        CommitLog.log.warn(<span class="string">&quot;GroupCommitService Exception, &quot;</span>, e);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">        <span class="comment">// 交换请求</span></span><br><span class="line">        <span class="keyword">this</span>.swapRequests();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.doCommit();</span><br><span class="line"></span><br><span class="line">    CommitLog.log.info(<span class="keyword">this</span>.getServiceName() + <span class="string">&quot; service end&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doCommit</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>.requestsRead) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="keyword">this</span>.requestsRead.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">for</span> (GroupCommitRequest req : <span class="keyword">this</span>.requestsRead) &#123;</span><br><span class="line">                <span class="comment">// There may be a message in the next file, so a maximum of</span></span><br><span class="line">                <span class="comment">// two times the flush</span></span><br><span class="line">                <span class="keyword">boolean</span> flushOK = <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span> &amp;&amp; !flushOK; i++) &#123;</span><br><span class="line">                    flushOK = CommitLog.<span class="keyword">this</span>.mappedFileQueue.getFlushedWhere() &gt;= req.getNextOffset();</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (!flushOK) &#123;</span><br><span class="line">                        <span class="comment">// 文件刷盘</span></span><br><span class="line">                        CommitLog.<span class="keyword">this</span>.mappedFileQueue.flush(<span class="number">0</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                req.wakeupCustomer(flushOK);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">long</span> storeTimestamp = CommitLog.<span class="keyword">this</span>.mappedFileQueue.getStoreTimestamp();</span><br><span class="line">            <span class="keyword">if</span> (storeTimestamp &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                CommitLog.<span class="keyword">this</span>.defaultMessageStore.getStoreCheckpoint().setPhysicMsgTimestamp(storeTimestamp);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">this</span>.requestsRead.clear();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// Because of individual messages is set to not sync flush, it</span></span><br><span class="line">            <span class="comment">// will come to this process</span></span><br><span class="line">            CommitLog.<span class="keyword">this</span>.mappedFileQueue.flush(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 为了避免同步刷盘消费任务与其他消息生产者提交任务产生锁竞争，</span></span><br><span class="line"><span class="comment">// GroupCommitService提供读容器与写容器，</span></span><br><span class="line"><span class="comment">// 这两个容器每执行完一次任务后交互，继续消费任务</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">swapRequests</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    List&lt;GroupCommitRequest&gt; tmp = <span class="keyword">this</span>.requestsWrite;</span><br><span class="line">    <span class="keyword">this</span>.requestsWrite = <span class="keyword">this</span>.requestsRead;</span><br><span class="line">    <span class="keyword">this</span>.requestsRead = tmp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="消息存储堆外内存相关"><a href="#消息存储堆外内存相关" class="headerlink" title="消息存储堆外内存相关"></a>消息存储堆外内存相关</h2><p>RocketMQ使用堆外内存（Direct Memory）可以提高消息传输的效率和性能，主要表现在以下几个方面：<br>减少了GC的开销：在使用堆内存时，生产者和消费者将消息转换成字节数组并存储在堆中，这些数据最终会被JVM垃圾回收器清理掉。如果消息量很大，就会产生大量的垃圾回收，导致系统效率下降。而使用堆外内存可以避免这个问题，因为这些内存不受JVM垃圾回收的管理，因此可以减少GC的开销。<br>提高了消息传输的效率：在使用堆外内存时，生产者和消费者可以直接将消息写入到内存中，而不需要将数据从堆中拷贝到直接内存中，这样可以减少内存拷贝的次数和数据在内存中的复制次数，从而提高了消息传输的效率。<br>提高了内存使用效率：由于JVM会为堆内存预留一定的内存空间，因此在堆内存使用时，很难将整个JVM进程的内存使用控制在合理的范围内。而使用堆外内存可以将内存管理的责任交给操作系统，避免了JVM管理内存带来的一些问题。需要注意的是，使用堆外内存也会带来一些额外的内存管理和维护的负担，例如需要管理内存映射和释放等问题。此外，在某些情况下，如果使用不当，可能会导致内存泄漏等问题，因此需要谨慎使用。</p>
<h1 id="消息消费流程"><a href="#消息消费流程" class="headerlink" title="消息消费流程"></a>消息消费流程</h1><h2 id="Consumer-1"><a href="#Consumer-1" class="headerlink" title="Consumer"></a>Consumer</h2><h3 id="流程图-6"><a href="#流程图-6" class="headerlink" title="流程图"></a>流程图</h3><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://bb3e216f.onedrive-cf-index-ng-e34.pages.dev/api/raw?path=/Public/BlogImg/RocketMQ/Consumer%E6%B6%88%E6%81%AF%E6%B6%88%E8%B4%B9%E6%B5%81%E7%A8%8B.png"
                      alt="Consumer消息消费流程.png"
                ><br>整体的流程：<br>Rebalance对消息队列进行负载均衡，然后创建PullRequest =&gt; PullRequest拉取消息，拉取成功后创建ConsumeRequest =&gt; ConsumeRequest消息消息</p>
<h3 id="关键代码-5"><a href="#关键代码-5" class="headerlink" title="关键代码"></a>关键代码</h3><h4 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">updateProcessQueueTableInRebalance</span><span class="params">(<span class="keyword">final</span> String topic, <span class="keyword">final</span> Set&lt;MessageQueue&gt; mqSet,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">final</span> <span class="keyword">boolean</span> isOrder)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> changed = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    Iterator&lt;Entry&lt;MessageQueue, ProcessQueue&gt;&gt; it = <span class="keyword">this</span>.processQueueTable.entrySet().iterator();</span><br><span class="line">    <span class="keyword">while</span> (it.hasNext()) &#123;</span><br><span class="line">        Entry&lt;MessageQueue, ProcessQueue&gt; next = it.next();</span><br><span class="line">        MessageQueue mq = next.getKey();</span><br><span class="line">        ProcessQueue pq = next.getValue();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (mq.getTopic().equals(topic)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!mqSet.contains(mq)) &#123;</span><br><span class="line">                <span class="comment">// 经过本次负载均衡，该mq被分配给其他消费者，需要暂停该消息队列消息的消费</span></span><br><span class="line">                pq.setDropped(<span class="keyword">true</span>);</span><br><span class="line">                <span class="comment">// ProcessQueue中的消息将不会再被消费</span></span><br><span class="line">                <span class="comment">// 将MessageQueue，ProcessQueue从缓存列表中移除，且持久化要移除的MessageQueue的消费进度</span></span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">this</span>.removeUnnecessaryMessageQueue(mq, pq)) &#123;</span><br><span class="line">                    it.remove();</span><br><span class="line">                    changed = <span class="keyword">true</span>;</span><br><span class="line">                    log.info(<span class="string">&quot;doRebalance, &#123;&#125;, remove unnecessary mq, &#123;&#125;&quot;</span>, consumerGroup, mq);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pq.isPullExpired()) &#123;</span><br><span class="line">                <span class="keyword">switch</span> (<span class="keyword">this</span>.consumeType()) &#123;</span><br><span class="line">                    <span class="keyword">case</span> CONSUME_ACTIVELY:</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> CONSUME_PASSIVELY:</span><br><span class="line">                        pq.setDropped(<span class="keyword">true</span>);</span><br><span class="line">                        <span class="keyword">if</span> (<span class="keyword">this</span>.removeUnnecessaryMessageQueue(mq, pq)) &#123;</span><br><span class="line">                            it.remove();</span><br><span class="line">                            changed = <span class="keyword">true</span>;</span><br><span class="line">                            log.error(<span class="string">&quot;[BUG]doRebalance, &#123;&#125;, remove unnecessary mq, &#123;&#125;, because pull is pause, so try to fixed it&quot;</span>,</span><br><span class="line">                                consumerGroup, mq);</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">default</span>:</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    List&lt;PullRequest&gt; pullRequestList = <span class="keyword">new</span> ArrayList&lt;PullRequest&gt;();</span><br><span class="line">    <span class="keyword">for</span> (MessageQueue mq : mqSet) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="keyword">this</span>.processQueueTable.containsKey(mq)) &#123;</span><br><span class="line">            <span class="comment">// 顺序消息，上锁(向Broker发起锁定请求)</span></span><br><span class="line">            <span class="keyword">if</span> (isOrder &amp;&amp; !<span class="keyword">this</span>.lock(mq)) &#123;</span><br><span class="line">                <span class="comment">// =&gt; 等待其他消费者释放锁，一直到下一次Rebalance时再尝试加锁</span></span><br><span class="line">                log.warn(<span class="string">&quot;doRebalance, &#123;&#125;, add a new mq failed, &#123;&#125;, because lock failed&quot;</span>, consumerGroup, mq);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 删除内存中过期的消费进度</span></span><br><span class="line">            <span class="keyword">this</span>.removeDirtyOffset(mq);</span><br><span class="line">            ProcessQueue pq = <span class="keyword">new</span> ProcessQueue();</span><br><span class="line">            <span class="comment">// 获取最新的消费进度</span></span><br><span class="line">            <span class="keyword">long</span> nextOffset = <span class="keyword">this</span>.computePullFromWhere(mq);</span><br><span class="line">            <span class="keyword">if</span> (nextOffset &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                ProcessQueue pre = <span class="keyword">this</span>.processQueueTable.putIfAbsent(mq, pq);</span><br><span class="line">                <span class="keyword">if</span> (pre != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    log.info(<span class="string">&quot;doRebalance, &#123;&#125;, mq already exists, &#123;&#125;&quot;</span>, consumerGroup, mq);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// 首次消费该队列，创建PullRequest请求</span></span><br><span class="line">                    log.info(<span class="string">&quot;doRebalance, &#123;&#125;, add a new mq, &#123;&#125;&quot;</span>, consumerGroup, mq);</span><br><span class="line">                    PullRequest pullRequest = <span class="keyword">new</span> PullRequest();</span><br><span class="line">                    pullRequest.setConsumerGroup(consumerGroup);</span><br><span class="line">                    pullRequest.setNextOffset(nextOffset);</span><br><span class="line">                    pullRequest.setMessageQueue(mq);</span><br><span class="line">                    pullRequest.setProcessQueue(pq);</span><br><span class="line">                    pullRequestList.add(pullRequest);</span><br><span class="line">                    changed = <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                log.warn(<span class="string">&quot;doRebalance, &#123;&#125;, add new mq failed, &#123;&#125;&quot;</span>, consumerGroup, mq);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.dispatchPullRequest(pullRequestList);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> changed;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="拉取消息"><a href="#拉取消息" class="headerlink" title="拉取消息"></a>拉取消息</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pullMessage</span><span class="params">(<span class="keyword">final</span> PullRequest pullRequest)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 从PullRequest中获取ProcessQueue</span></span><br><span class="line">    <span class="keyword">final</span> ProcessQueue processQueue = pullRequest.getProcessQueue();</span><br><span class="line">    <span class="keyword">if</span> (processQueue.isDropped()) &#123;</span><br><span class="line">        <span class="comment">// ProcessQueue丢弃</span></span><br><span class="line">        log.info(<span class="string">&quot;the pull request[&#123;&#125;] is dropped.&quot;</span>, pullRequest.toString());</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 更新最后一次拉取时间为当前时间</span></span><br><span class="line">    pullRequest.getProcessQueue().setLastPullTimestamp(System.currentTimeMillis());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 消费者状态不对，延迟3s后拉取</span></span><br><span class="line">        <span class="keyword">this</span>.makeSureStateOK();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (MQClientException e) &#123;</span><br><span class="line">        log.warn(<span class="string">&quot;pullMessage exception, consumer state not ok&quot;</span>, e);</span><br><span class="line">        <span class="keyword">this</span>.executePullRequestLater(pullRequest, pullTimeDelayMillsWhenException);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.isPause()) &#123;</span><br><span class="line">        <span class="comment">// 消费者被挂起，延迟1s后再拉取</span></span><br><span class="line">        log.warn(<span class="string">&quot;consumer was paused, execute pull request later. instanceName=&#123;&#125;, group=&#123;&#125;&quot;</span>, <span class="keyword">this</span>.defaultMQPushConsumer.getInstanceName(), <span class="keyword">this</span>.defaultMQPushConsumer.getConsumerGroup());</span><br><span class="line">        <span class="keyword">this</span>.executePullRequestLater(pullRequest, PULL_TIME_DELAY_MILLS_WHEN_SUSPEND);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">long</span> cachedMessageCount = processQueue.getMsgCount().get();</span><br><span class="line">    <span class="keyword">long</span> cachedMessageSizeInMiB = processQueue.getMsgSize().get() / (<span class="number">1024</span> * <span class="number">1024</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 流控 消息数量/消息占用内存</span></span><br><span class="line">    <span class="keyword">if</span> (cachedMessageCount &gt; <span class="keyword">this</span>.defaultMQPushConsumer.getPullThresholdForQueue()) &#123;</span><br><span class="line">        <span class="keyword">this</span>.executePullRequestLater(pullRequest, PULL_TIME_DELAY_MILLS_WHEN_FLOW_CONTROL);</span><br><span class="line">        <span class="keyword">if</span> ((queueFlowControlTimes++ % <span class="number">1000</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">            log.warn(</span><br><span class="line">                <span class="string">&quot;the cached message count exceeds the threshold &#123;&#125;, so do flow control, minOffset=&#123;&#125;, maxOffset=&#123;&#125;, count=&#123;&#125;, size=&#123;&#125; MiB, pullRequest=&#123;&#125;, flowControlTimes=&#123;&#125;&quot;</span>,</span><br><span class="line">                <span class="keyword">this</span>.defaultMQPushConsumer.getPullThresholdForQueue(), processQueue.getMsgTreeMap().firstKey(), processQueue.getMsgTreeMap().lastKey(), cachedMessageCount, cachedMessageSizeInMiB, pullRequest, queueFlowControlTimes);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (cachedMessageSizeInMiB &gt; <span class="keyword">this</span>.defaultMQPushConsumer.getPullThresholdSizeForQueue()) &#123;</span><br><span class="line">        <span class="keyword">this</span>.executePullRequestLater(pullRequest, PULL_TIME_DELAY_MILLS_WHEN_FLOW_CONTROL);</span><br><span class="line">        <span class="keyword">if</span> ((queueFlowControlTimes++ % <span class="number">1000</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">            log.warn(</span><br><span class="line">                <span class="string">&quot;the cached message size exceeds the threshold &#123;&#125; MiB, so do flow control, minOffset=&#123;&#125;, maxOffset=&#123;&#125;, count=&#123;&#125;, size=&#123;&#125; MiB, pullRequest=&#123;&#125;, flowControlTimes=&#123;&#125;&quot;</span>,</span><br><span class="line">                <span class="keyword">this</span>.defaultMQPushConsumer.getPullThresholdSizeForQueue(), processQueue.getMsgTreeMap().firstKey(), processQueue.getMsgTreeMap().lastKey(), cachedMessageCount, cachedMessageSizeInMiB, pullRequest, queueFlowControlTimes);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">this</span>.consumeOrderly) &#123;</span><br><span class="line">        <span class="comment">// 非顺序消费</span></span><br><span class="line">        <span class="keyword">if</span> (processQueue.getMaxSpan() &gt; <span class="keyword">this</span>.defaultMQPushConsumer.getConsumeConcurrentlyMaxSpan()) &#123;</span><br><span class="line">            <span class="comment">// 消息跨度（队列中最大偏移量-最小偏移量的间距） =&gt; 流控</span></span><br><span class="line">            <span class="keyword">this</span>.executePullRequestLater(pullRequest, PULL_TIME_DELAY_MILLS_WHEN_FLOW_CONTROL);</span><br><span class="line">            <span class="keyword">if</span> ((queueMaxSpanFlowControlTimes++ % <span class="number">1000</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">                log.warn(</span><br><span class="line">                    <span class="string">&quot;the queue&#x27;s messages, span too long, so do flow control, minOffset=&#123;&#125;, maxOffset=&#123;&#125;, maxSpan=&#123;&#125;, pullRequest=&#123;&#125;, flowControlTimes=&#123;&#125;&quot;</span>,</span><br><span class="line">                    processQueue.getMsgTreeMap().firstKey(), processQueue.getMsgTreeMap().lastKey(), processQueue.getMaxSpan(),</span><br><span class="line">                    pullRequest, queueMaxSpanFlowControlTimes);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 顺序消费</span></span><br><span class="line">        <span class="keyword">if</span> (processQueue.isLocked()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!pullRequest.isLockedFirst()) &#123;</span><br><span class="line">                <span class="comment">// 如果该处理队列是第一次拉取任务，则首先计算拉取偏移量，然后向消息服务端拉取消息</span></span><br><span class="line">                <span class="keyword">final</span> <span class="keyword">long</span> offset = <span class="keyword">this</span>.rebalanceImpl.computePullFromWhere(pullRequest.getMessageQueue());</span><br><span class="line">                <span class="keyword">boolean</span> brokerBusy = offset &lt; pullRequest.getNextOffset();</span><br><span class="line">                log.info(<span class="string">&quot;the first time to pull message, so fix offset from broker. pullRequest: &#123;&#125; NewOffset: &#123;&#125; brokerBusy: &#123;&#125;&quot;</span>,</span><br><span class="line">                    pullRequest, offset, brokerBusy);</span><br><span class="line">                <span class="keyword">if</span> (brokerBusy) &#123;</span><br><span class="line">                    log.info(<span class="string">&quot;[NOTIFYME]the first time to pull message, but pull request offset larger than broker consume offset. pullRequest: &#123;&#125; NewOffset: &#123;&#125;&quot;</span>,</span><br><span class="line">                        pullRequest, offset);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                pullRequest.setLockedFirst(<span class="keyword">true</span>);</span><br><span class="line">                pullRequest.setNextOffset(offset);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 如果消息处理队列未被锁定，则延迟3s后再将PullRequest对象放入拉取任务中</span></span><br><span class="line">            <span class="keyword">this</span>.executePullRequestLater(pullRequest, pullTimeDelayMillsWhenException);</span><br><span class="line">            log.info(<span class="string">&quot;pull message later because not locked in broker, &#123;&#125;&quot;</span>, pullRequest);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取该主题的订阅信息</span></span><br><span class="line">    <span class="keyword">final</span> SubscriptionData subscriptionData = <span class="keyword">this</span>.rebalanceImpl.getSubscriptionInner().get(pullRequest.getMessageQueue().getTopic());</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">null</span> == subscriptionData) &#123;</span><br><span class="line">        <span class="keyword">this</span>.executePullRequestLater(pullRequest, pullTimeDelayMillsWhenException);</span><br><span class="line">        log.warn(<span class="string">&quot;find the consumer&#x27;s subscription failed, &#123;&#125;&quot;</span>, pullRequest);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">long</span> beginTimestamp = System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 拉取的回调方法</span></span><br><span class="line">    PullCallback pullCallback = <span class="keyword">new</span> PullCallback() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onSuccess</span><span class="params">(PullResult pullResult)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (pullResult != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 对象转换，消息过滤</span></span><br><span class="line">                pullResult = DefaultMQPushConsumerImpl.<span class="keyword">this</span>.pullAPIWrapper.processPullResult(pullRequest.getMessageQueue(), pullResult,</span><br><span class="line">                    subscriptionData);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">switch</span> (pullResult.getPullStatus()) &#123;</span><br><span class="line">                    <span class="keyword">case</span> FOUND:</span><br><span class="line">                        <span class="keyword">long</span> prevRequestOffset = pullRequest.getNextOffset();</span><br><span class="line">                        <span class="comment">// 更新下次拉取的偏移量</span></span><br><span class="line">                        pullRequest.setNextOffset(pullResult.getNextBeginOffset());</span><br><span class="line">                        <span class="keyword">long</span> pullRT = System.currentTimeMillis() - beginTimestamp;</span><br><span class="line">                        DefaultMQPushConsumerImpl.<span class="keyword">this</span>.getConsumerStatsManager().incPullRT(pullRequest.getConsumerGroup(),</span><br><span class="line">                            pullRequest.getMessageQueue().getTopic(), pullRT);</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">long</span> firstMsgOffset = Long.MAX_VALUE;</span><br><span class="line">                        <span class="keyword">if</span> (pullResult.getMsgFoundList() == <span class="keyword">null</span> || pullResult.getMsgFoundList().isEmpty()) &#123;</span><br><span class="line">                            <span class="comment">// 无消息，立即再次拉取（broker端有符合的消息，但是经过客户端过滤后，没有消息）</span></span><br><span class="line">                            DefaultMQPushConsumerImpl.<span class="keyword">this</span>.executePullRequestImmediately(pullRequest);</span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                            <span class="comment">// 第一条消息的偏移量</span></span><br><span class="line">                            firstMsgOffset = pullResult.getMsgFoundList().get(<span class="number">0</span>).getQueueOffset();</span><br><span class="line"></span><br><span class="line">                            DefaultMQPushConsumerImpl.<span class="keyword">this</span>.getConsumerStatsManager().incPullTPS(pullRequest.getConsumerGroup(),</span><br><span class="line">                                pullRequest.getMessageQueue().getTopic(), pullResult.getMsgFoundList().size());</span><br><span class="line"></span><br><span class="line">                            <span class="comment">// 将拉取到的消息存入ProcessQueue中</span></span><br><span class="line">                            <span class="keyword">boolean</span> dispatchToConsume = processQueue.putMessage(pullResult.getMsgFoundList());</span><br><span class="line">                            <span class="comment">// 提交到ConsumeMessageService中供消费者消费 =&gt; 拉取线程不关心消息消费结果</span></span><br><span class="line">                            DefaultMQPushConsumerImpl.<span class="keyword">this</span>.consumeMessageService.submitConsumeRequest(</span><br><span class="line">                                pullResult.getMsgFoundList(),</span><br><span class="line">                                processQueue,</span><br><span class="line">                                pullRequest.getMessageQueue(),</span><br><span class="line">                                dispatchToConsume);</span><br><span class="line"></span><br><span class="line">                            <span class="keyword">if</span> (DefaultMQPushConsumerImpl.<span class="keyword">this</span>.defaultMQPushConsumer.getPullInterval() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                                DefaultMQPushConsumerImpl.<span class="keyword">this</span>.executePullRequestLater(pullRequest,</span><br><span class="line">                                    DefaultMQPushConsumerImpl.<span class="keyword">this</span>.defaultMQPushConsumer.getPullInterval());</span><br><span class="line">                            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                                DefaultMQPushConsumerImpl.<span class="keyword">this</span>.executePullRequestImmediately(pullRequest);</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">if</span> (pullResult.getNextBeginOffset() &lt; prevRequestOffset</span><br><span class="line">                            || firstMsgOffset &lt; prevRequestOffset) &#123;</span><br><span class="line">                            log.warn(</span><br><span class="line">                                <span class="string">&quot;[BUG] pull message result maybe data wrong, nextBeginOffset: &#123;&#125; firstMsgOffset: &#123;&#125; prevRequestOffset: &#123;&#125;&quot;</span>,</span><br><span class="line">                                pullResult.getNextBeginOffset(),</span><br><span class="line">                                firstMsgOffset,</span><br><span class="line">                                prevRequestOffset);</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> NO_NEW_MSG:</span><br><span class="line">                        pullRequest.setNextOffset(pullResult.getNextBeginOffset());</span><br><span class="line"></span><br><span class="line">                        DefaultMQPushConsumerImpl.<span class="keyword">this</span>.correctTagsOffset(pullRequest);</span><br><span class="line"></span><br><span class="line">                        DefaultMQPushConsumerImpl.<span class="keyword">this</span>.executePullRequestImmediately(pullRequest);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> NO_MATCHED_MSG:</span><br><span class="line">                        pullRequest.setNextOffset(pullResult.getNextBeginOffset());</span><br><span class="line"></span><br><span class="line">                        DefaultMQPushConsumerImpl.<span class="keyword">this</span>.correctTagsOffset(pullRequest);</span><br><span class="line"></span><br><span class="line">                        DefaultMQPushConsumerImpl.<span class="keyword">this</span>.executePullRequestImmediately(pullRequest);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> OFFSET_ILLEGAL:</span><br><span class="line">                        log.warn(<span class="string">&quot;the pull request offset illegal, &#123;&#125; &#123;&#125;&quot;</span>,</span><br><span class="line">                            pullRequest.toString(), pullResult.toString());</span><br><span class="line">                        pullRequest.setNextOffset(pullResult.getNextBeginOffset());</span><br><span class="line"></span><br><span class="line">                        <span class="comment">// 首先将ProcessQueue的dropped设置为true =&gt; 丢弃该消费队列，拉取到的消息停止消费</span></span><br><span class="line">                        pullRequest.getProcessQueue().setDropped(<span class="keyword">true</span>);</span><br><span class="line">                        DefaultMQPushConsumerImpl.<span class="keyword">this</span>.executeTaskLater(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line"></span><br><span class="line">                            <span class="meta">@Override</span></span><br><span class="line">                            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                                <span class="keyword">try</span> &#123;</span><br><span class="line">                                    <span class="comment">// 根据服务端下一次校对的偏移量尝试更新消息消费进度（内存中）</span></span><br><span class="line">                                    DefaultMQPushConsumerImpl.<span class="keyword">this</span>.offsetStore.updateOffset(pullRequest.getMessageQueue(),</span><br><span class="line">                                        pullRequest.getNextOffset(), <span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">                                    <span class="comment">// 持久化消息消费进度</span></span><br><span class="line">                                    DefaultMQPushConsumerImpl.<span class="keyword">this</span>.offsetStore.persist(pullRequest.getMessageQueue());</span><br><span class="line"></span><br><span class="line">                                    <span class="comment">// 将该消息队列从RebalanceImpl中移除, 等待消息队列的下一次重负载</span></span><br><span class="line">                                    DefaultMQPushConsumerImpl.<span class="keyword">this</span>.rebalanceImpl.removeProcessQueue(pullRequest.getMessageQueue());</span><br><span class="line"></span><br><span class="line">                                    log.warn(<span class="string">&quot;fix the pull request offset, &#123;&#125;&quot;</span>, pullRequest);</span><br><span class="line">                                &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">                                    log.error(<span class="string">&quot;executeTaskLater Exception&quot;</span>, e);</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;, <span class="number">10000</span>);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">default</span>:</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onException</span><span class="params">(Throwable e)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (!pullRequest.getMessageQueue().getTopic().startsWith(MixAll.RETRY_GROUP_TOPIC_PREFIX)) &#123;</span><br><span class="line">                log.warn(<span class="string">&quot;execute the pull request exception&quot;</span>, e);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            DefaultMQPushConsumerImpl.<span class="keyword">this</span>.executePullRequestLater(pullRequest, pullTimeDelayMillsWhenException);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">boolean</span> commitOffsetEnable = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">long</span> commitOffsetValue = <span class="number">0L</span>;</span><br><span class="line">    <span class="keyword">if</span> (MessageModel.CLUSTERING == <span class="keyword">this</span>.defaultMQPushConsumer.getMessageModel()) &#123;</span><br><span class="line">        commitOffsetValue = <span class="keyword">this</span>.offsetStore.readOffset(pullRequest.getMessageQueue(), ReadOffsetType.READ_FROM_MEMORY);</span><br><span class="line">        <span class="keyword">if</span> (commitOffsetValue &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            commitOffsetEnable = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    String subExpression = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">boolean</span> classFilter = <span class="keyword">false</span>;</span><br><span class="line">    SubscriptionData sd = <span class="keyword">this</span>.rebalanceImpl.getSubscriptionInner().get(pullRequest.getMessageQueue().getTopic());</span><br><span class="line">    <span class="keyword">if</span> (sd != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.defaultMQPushConsumer.isPostSubscriptionWhenPull() &amp;&amp; !sd.isClassFilterMode()) &#123;</span><br><span class="line">            subExpression = sd.getSubString();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        classFilter = sd.isClassFilterMode();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 消息拉取系统编辑</span></span><br><span class="line">    <span class="keyword">int</span> sysFlag = PullSysFlag.buildSysFlag(</span><br><span class="line">        commitOffsetEnable, <span class="comment">// commitOffset</span></span><br><span class="line">        <span class="keyword">true</span>, <span class="comment">// suspend</span></span><br><span class="line">        subExpression != <span class="keyword">null</span>, <span class="comment">// subscription</span></span><br><span class="line">        classFilter <span class="comment">// class filter</span></span><br><span class="line">    );</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 拉取消息</span></span><br><span class="line">        <span class="keyword">this</span>.pullAPIWrapper.pullKernelImpl(</span><br><span class="line">            pullRequest.getMessageQueue(),</span><br><span class="line">            subExpression,</span><br><span class="line">            subscriptionData.getExpressionType(),</span><br><span class="line">            subscriptionData.getSubVersion(),</span><br><span class="line">            pullRequest.getNextOffset(),</span><br><span class="line">            <span class="keyword">this</span>.defaultMQPushConsumer.getPullBatchSize(),</span><br><span class="line">            sysFlag,</span><br><span class="line">            commitOffsetValue,</span><br><span class="line">            BROKER_SUSPEND_MAX_TIME_MILLIS,</span><br><span class="line">            CONSUMER_TIMEOUT_MILLIS_WHEN_SUSPEND,</span><br><span class="line">            CommunicationMode.ASYNC,</span><br><span class="line">            pullCallback</span><br><span class="line">        );</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        log.error(<span class="string">&quot;pullKernelImpl exception&quot;</span>, e);</span><br><span class="line">        <span class="keyword">this</span>.executePullRequestLater(pullRequest, pullTimeDelayMillsWhenException);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="消费消息"><a href="#消费消息" class="headerlink" title="消费消息"></a>消费消息</h4><h5 id="顺序消费"><a href="#顺序消费" class="headerlink" title="顺序消费"></a>顺序消费</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.processQueue.isDropped()) &#123;</span><br><span class="line">        log.warn(<span class="string">&quot;run, the message queue not be able to consume, because it&#x27;s dropped. &#123;&#125;&quot;</span>, <span class="keyword">this</span>.messageQueue);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对当前的消息队列申请独占锁 =&gt; 锁粒度：MessageQueue</span></span><br><span class="line">    <span class="keyword">final</span> Object objLock = messageQueueLock.fetchLockObject(<span class="keyword">this</span>.messageQueue);</span><br><span class="line">    <span class="keyword">synchronized</span> (objLock) &#123;</span><br><span class="line">        <span class="keyword">if</span> (MessageModel.BROADCASTING.equals(ConsumeMessageOrderlyService.<span class="keyword">this</span>.defaultMQPushConsumerImpl.messageModel())</span><br><span class="line">            || (<span class="keyword">this</span>.processQueue.isLocked() &amp;&amp; !<span class="keyword">this</span>.processQueue.isLockExpired())) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">long</span> beginTime = System.currentTimeMillis();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">boolean</span> continueConsume = <span class="keyword">true</span>; continueConsume; ) &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">this</span>.processQueue.isDropped()) &#123;</span><br><span class="line">                    log.warn(<span class="string">&quot;the message queue not be able to consume, because it&#x27;s dropped. &#123;&#125;&quot;</span>, <span class="keyword">this</span>.messageQueue);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (MessageModel.CLUSTERING.equals(ConsumeMessageOrderlyService.<span class="keyword">this</span>.defaultMQPushConsumerImpl.messageModel())</span><br><span class="line">                    &amp;&amp; !<span class="keyword">this</span>.processQueue.isLocked()) &#123;</span><br><span class="line">                    log.warn(<span class="string">&quot;the message queue not locked, so consume later, &#123;&#125;&quot;</span>, <span class="keyword">this</span>.messageQueue);</span><br><span class="line">                    ConsumeMessageOrderlyService.<span class="keyword">this</span>.tryLockLaterAndReconsume(<span class="keyword">this</span>.messageQueue, <span class="keyword">this</span>.processQueue, <span class="number">10</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (MessageModel.CLUSTERING.equals(ConsumeMessageOrderlyService.<span class="keyword">this</span>.defaultMQPushConsumerImpl.messageModel())</span><br><span class="line">                    &amp;&amp; <span class="keyword">this</span>.processQueue.isLockExpired()) &#123;</span><br><span class="line">                    log.warn(<span class="string">&quot;the message queue lock expired, so consume later, &#123;&#125;&quot;</span>, <span class="keyword">this</span>.messageQueue);</span><br><span class="line">                    ConsumeMessageOrderlyService.<span class="keyword">this</span>.tryLockLaterAndReconsume(<span class="keyword">this</span>.messageQueue, <span class="keyword">this</span>.processQueue, <span class="number">10</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">long</span> interval = System.currentTimeMillis() - beginTime;</span><br><span class="line">                <span class="keyword">if</span> (interval &gt; MAX_TIME_CONSUME_CONTINUOUSLY) &#123;</span><br><span class="line">                    <span class="comment">// 消息消费时间大于 MAX_TIME_CONSUME_CONTINUOUSLY，放弃本次消息消费，交由消费组其他线程继续消费</span></span><br><span class="line">                    ConsumeMessageOrderlyService.<span class="keyword">this</span>.submitConsumeRequestLater(processQueue, messageQueue, <span class="number">10</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">final</span> <span class="keyword">int</span> consumeBatchSize =</span><br><span class="line">                    ConsumeMessageOrderlyService.<span class="keyword">this</span>.defaultMQPushConsumer.getConsumeMessageBatchMaxSize();</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 获取消息</span></span><br><span class="line">                <span class="comment">// 从 msgTreeMap 取出，放到 consumingMsgOrderlyTreeMap 中</span></span><br><span class="line">                List&lt;MessageExt&gt; msgs = <span class="keyword">this</span>.processQueue.takeMessags(consumeBatchSize);</span><br><span class="line">                defaultMQPushConsumerImpl.resetRetryAndNamespace(msgs, defaultMQPushConsumer.getConsumerGroup());</span><br><span class="line">                <span class="keyword">if</span> (!msgs.isEmpty()) &#123;</span><br><span class="line">                    <span class="keyword">final</span> ConsumeOrderlyContext context = <span class="keyword">new</span> ConsumeOrderlyContext(<span class="keyword">this</span>.messageQueue);</span><br><span class="line"></span><br><span class="line">                    ConsumeOrderlyStatus status = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">                    ConsumeMessageContext consumeMessageContext = <span class="keyword">null</span>;</span><br><span class="line">                    <span class="comment">// 钩子函数</span></span><br><span class="line">                    <span class="keyword">if</span> (ConsumeMessageOrderlyService.<span class="keyword">this</span>.defaultMQPushConsumerImpl.hasHook()) &#123;</span><br><span class="line">                        consumeMessageContext = <span class="keyword">new</span> ConsumeMessageContext();</span><br><span class="line">                        consumeMessageContext</span><br><span class="line">                            .setConsumerGroup(ConsumeMessageOrderlyService.<span class="keyword">this</span>.defaultMQPushConsumer.getConsumerGroup());</span><br><span class="line">                        consumeMessageContext.setNamespace(defaultMQPushConsumer.getNamespace());</span><br><span class="line">                        consumeMessageContext.setMq(messageQueue);</span><br><span class="line">                        consumeMessageContext.setMsgList(msgs);</span><br><span class="line">                        consumeMessageContext.setSuccess(<span class="keyword">false</span>);</span><br><span class="line">                        <span class="comment">// init the consume context type</span></span><br><span class="line">                        consumeMessageContext.setProps(<span class="keyword">new</span> HashMap&lt;String, String&gt;());</span><br><span class="line">                        ConsumeMessageOrderlyService.<span class="keyword">this</span>.defaultMQPushConsumerImpl.executeHookBefore(consumeMessageContext);</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">long</span> beginTimestamp = System.currentTimeMillis();</span><br><span class="line">                    ConsumeReturnType returnType = ConsumeReturnType.SUCCESS;</span><br><span class="line">                    <span class="keyword">boolean</span> hasException = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="comment">// 申请消费锁</span></span><br><span class="line">                        <span class="keyword">this</span>.processQueue.getLockConsume().lock();</span><br><span class="line">                        <span class="keyword">if</span> (<span class="keyword">this</span>.processQueue.isDropped()) &#123;</span><br><span class="line">                            log.warn(<span class="string">&quot;consumeMessage, the message queue not be able to consume, because it&#x27;s dropped. &#123;&#125;&quot;</span>,</span><br><span class="line">                                <span class="keyword">this</span>.messageQueue);</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        <span class="comment">// 消费消息</span></span><br><span class="line">                        status = messageListener.consumeMessage(Collections.unmodifiableList(msgs), context);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">                        log.warn(<span class="string">&quot;consumeMessage exception: &#123;&#125; Group: &#123;&#125; Msgs: &#123;&#125; MQ: &#123;&#125;&quot;</span>,</span><br><span class="line">                            RemotingHelper.exceptionSimpleDesc(e),</span><br><span class="line">                            ConsumeMessageOrderlyService.<span class="keyword">this</span>.consumerGroup,</span><br><span class="line">                            msgs,</span><br><span class="line">                            messageQueue);</span><br><span class="line">                        hasException = <span class="keyword">true</span>;</span><br><span class="line">                    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                        <span class="keyword">this</span>.processQueue.getLockConsume().unlock();</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (<span class="keyword">null</span> == status</span><br><span class="line">                        || ConsumeOrderlyStatus.ROLLBACK == status</span><br><span class="line">                        || ConsumeOrderlyStatus.SUSPEND_CURRENT_QUEUE_A_MOMENT == status) &#123;</span><br><span class="line">                        log.warn(<span class="string">&quot;consumeMessage Orderly return not OK, Group: &#123;&#125; Msgs: &#123;&#125; MQ: &#123;&#125;&quot;</span>,</span><br><span class="line">                            ConsumeMessageOrderlyService.<span class="keyword">this</span>.consumerGroup,</span><br><span class="line">                            msgs,</span><br><span class="line">                            messageQueue);</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">long</span> consumeRT = System.currentTimeMillis() - beginTimestamp;</span><br><span class="line">                    <span class="keyword">if</span> (<span class="keyword">null</span> == status) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (hasException) &#123;</span><br><span class="line">                            returnType = ConsumeReturnType.EXCEPTION;</span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                            returnType = ConsumeReturnType.RETURNNULL;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (consumeRT &gt;= defaultMQPushConsumer.getConsumeTimeout() * <span class="number">60</span> * <span class="number">1000</span>) &#123;</span><br><span class="line">                        returnType = ConsumeReturnType.TIME_OUT;</span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ConsumeOrderlyStatus.SUSPEND_CURRENT_QUEUE_A_MOMENT == status) &#123;</span><br><span class="line">                        returnType = ConsumeReturnType.FAILED;</span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ConsumeOrderlyStatus.SUCCESS == status) &#123;</span><br><span class="line">                        returnType = ConsumeReturnType.SUCCESS;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (ConsumeMessageOrderlyService.<span class="keyword">this</span>.defaultMQPushConsumerImpl.hasHook()) &#123;</span><br><span class="line">                        consumeMessageContext.getProps().put(MixAll.CONSUME_CONTEXT_TYPE, returnType.name());</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (<span class="keyword">null</span> == status) &#123;</span><br><span class="line">                        status = ConsumeOrderlyStatus.SUSPEND_CURRENT_QUEUE_A_MOMENT;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 钩子函数</span></span><br><span class="line">                    <span class="keyword">if</span> (ConsumeMessageOrderlyService.<span class="keyword">this</span>.defaultMQPushConsumerImpl.hasHook()) &#123;</span><br><span class="line">                        consumeMessageContext.setStatus(status.toString());</span><br><span class="line">                        consumeMessageContext</span><br><span class="line">                            .setSuccess(ConsumeOrderlyStatus.SUCCESS == status || ConsumeOrderlyStatus.COMMIT == status);</span><br><span class="line">                        ConsumeMessageOrderlyService.<span class="keyword">this</span>.defaultMQPushConsumerImpl.executeHookAfter(consumeMessageContext);</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    ConsumeMessageOrderlyService.<span class="keyword">this</span>.getConsumerStatsManager()</span><br><span class="line">                        .incConsumeRT(ConsumeMessageOrderlyService.<span class="keyword">this</span>.consumerGroup, messageQueue.getTopic(), consumeRT);</span><br><span class="line"></span><br><span class="line">                    continueConsume = ConsumeMessageOrderlyService.<span class="keyword">this</span>.processConsumeResult(msgs, status, context, <span class="keyword">this</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    continueConsume = <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.processQueue.isDropped()) &#123;</span><br><span class="line">                log.warn(<span class="string">&quot;the message queue not be able to consume, because it&#x27;s dropped. &#123;&#125;&quot;</span>, <span class="keyword">this</span>.messageQueue);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            ConsumeMessageOrderlyService.<span class="keyword">this</span>.tryLockLaterAndReconsume(<span class="keyword">this</span>.messageQueue, <span class="keyword">this</span>.processQueue, <span class="number">100</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br></pre></td></tr></table></figure>
<p>更新消费进度</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">processConsumeResult</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">final</span> List&lt;MessageExt&gt; msgs,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">final</span> ConsumeOrderlyStatus status,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">final</span> ConsumeOrderlyContext context,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">final</span> ConsumeRequest consumeRequest</span></span></span><br><span class="line"><span class="params"><span class="function">)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> continueConsume = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">long</span> commitOffset = -<span class="number">1L</span>;</span><br><span class="line">    <span class="keyword">if</span> (context.isAutoCommit()) &#123;</span><br><span class="line">        <span class="keyword">switch</span> (status) &#123;</span><br><span class="line">            <span class="keyword">case</span> COMMIT:</span><br><span class="line">            <span class="keyword">case</span> ROLLBACK:</span><br><span class="line">                log.warn(<span class="string">&quot;the message queue consume result is illegal, we think you want to ack these message &#123;&#125;&quot;</span>,</span><br><span class="line">                    consumeRequest.getMessageQueue());</span><br><span class="line">            <span class="keyword">case</span> SUCCESS:</span><br><span class="line">                <span class="comment">// commit</span></span><br><span class="line">                commitOffset = consumeRequest.getProcessQueue().commit();</span><br><span class="line">                <span class="keyword">this</span>.getConsumerStatsManager().incConsumeOKTPS(consumerGroup, consumeRequest.getMessageQueue().getTopic(), msgs.size());</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> SUSPEND_CURRENT_QUEUE_A_MOMENT:</span><br><span class="line">                <span class="keyword">this</span>.getConsumerStatsManager().incConsumeFailedTPS(consumerGroup, consumeRequest.getMessageQueue().getTopic(), msgs.size());</span><br><span class="line">                <span class="comment">// 重试</span></span><br><span class="line">                <span class="keyword">if</span> (checkReconsumeTimes(msgs)) &#123;</span><br><span class="line">                    consumeRequest.getProcessQueue().makeMessageToCosumeAgain(msgs);</span><br><span class="line">                    <span class="keyword">this</span>.submitConsumeRequestLater(</span><br><span class="line">                        consumeRequest.getProcessQueue(),</span><br><span class="line">                        consumeRequest.getMessageQueue(),</span><br><span class="line">                        context.getSuspendCurrentQueueTimeMillis());</span><br><span class="line">                    continueConsume = <span class="keyword">false</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    commitOffset = consumeRequest.getProcessQueue().commit();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">switch</span> (status) &#123;</span><br><span class="line">            <span class="keyword">case</span> SUCCESS:</span><br><span class="line">                <span class="keyword">this</span>.getConsumerStatsManager().incConsumeOKTPS(consumerGroup, consumeRequest.getMessageQueue().getTopic(), msgs.size());</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> COMMIT:</span><br><span class="line">                commitOffset = consumeRequest.getProcessQueue().commit();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> ROLLBACK:</span><br><span class="line">                consumeRequest.getProcessQueue().rollback();</span><br><span class="line">                <span class="keyword">this</span>.submitConsumeRequestLater(</span><br><span class="line">                    consumeRequest.getProcessQueue(),</span><br><span class="line">                    consumeRequest.getMessageQueue(),</span><br><span class="line">                    context.getSuspendCurrentQueueTimeMillis());</span><br><span class="line">                continueConsume = <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> SUSPEND_CURRENT_QUEUE_A_MOMENT:</span><br><span class="line">                <span class="keyword">this</span>.getConsumerStatsManager().incConsumeFailedTPS(consumerGroup, consumeRequest.getMessageQueue().getTopic(), msgs.size());</span><br><span class="line">                <span class="keyword">if</span> (checkReconsumeTimes(msgs)) &#123;</span><br><span class="line">                    consumeRequest.getProcessQueue().makeMessageToCosumeAgain(msgs);</span><br><span class="line">                    <span class="keyword">this</span>.submitConsumeRequestLater(</span><br><span class="line">                        consumeRequest.getProcessQueue(),</span><br><span class="line">                        consumeRequest.getMessageQueue(),</span><br><span class="line">                        context.getSuspendCurrentQueueTimeMillis());</span><br><span class="line">                    continueConsume = <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (commitOffset &gt;= <span class="number">0</span> &amp;&amp; !consumeRequest.getProcessQueue().isDropped()) &#123;</span><br><span class="line">        <span class="comment">// 更新偏移量</span></span><br><span class="line">        <span class="keyword">this</span>.defaultMQPushConsumerImpl.getOffsetStore().updateOffset(consumeRequest.getMessageQueue(), commitOffset, <span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> continueConsume;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h5 id="非顺序消息"><a href="#非顺序消息" class="headerlink" title="非顺序消息"></a>非顺序消息</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ProcessQueue是否丢弃（例如当前消费者不负责消费当前消息的情况）</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.processQueue.isDropped()) &#123;</span><br><span class="line">        log.info(<span class="string">&quot;the message queue not be able to consume, because it&#x27;s dropped. group=&#123;&#125; &#123;&#125;&quot;</span>, ConsumeMessageConcurrentlyService.<span class="keyword">this</span>.consumerGroup, <span class="keyword">this</span>.messageQueue);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    MessageListenerConcurrently listener = ConsumeMessageConcurrentlyService.<span class="keyword">this</span>.messageListener;</span><br><span class="line">    ConsumeConcurrentlyContext context = <span class="keyword">new</span> ConsumeConcurrentlyContext(messageQueue);</span><br><span class="line">    ConsumeConcurrentlyStatus status = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">// 恢复重试消息主题名</span></span><br><span class="line">    defaultMQPushConsumerImpl.resetRetryAndNamespace(msgs, defaultMQPushConsumer.getConsumerGroup());</span><br><span class="line"></span><br><span class="line">    ConsumeMessageContext consumeMessageContext = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">// 执行钩子函数</span></span><br><span class="line">    <span class="keyword">if</span> (ConsumeMessageConcurrentlyService.<span class="keyword">this</span>.defaultMQPushConsumerImpl.hasHook()) &#123;</span><br><span class="line">        consumeMessageContext = <span class="keyword">new</span> ConsumeMessageContext();</span><br><span class="line">        consumeMessageContext.setNamespace(defaultMQPushConsumer.getNamespace());</span><br><span class="line">        consumeMessageContext.setConsumerGroup(defaultMQPushConsumer.getConsumerGroup());</span><br><span class="line">        consumeMessageContext.setProps(<span class="keyword">new</span> HashMap&lt;String, String&gt;());</span><br><span class="line">        consumeMessageContext.setMq(messageQueue);</span><br><span class="line">        consumeMessageContext.setMsgList(msgs);</span><br><span class="line">        consumeMessageContext.setSuccess(<span class="keyword">false</span>);</span><br><span class="line">        ConsumeMessageConcurrentlyService.<span class="keyword">this</span>.defaultMQPushConsumerImpl.executeHookBefore(consumeMessageContext);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">long</span> beginTimestamp = System.currentTimeMillis();</span><br><span class="line">    <span class="keyword">boolean</span> hasException = <span class="keyword">false</span>;</span><br><span class="line">    ConsumeReturnType returnType = ConsumeReturnType.SUCCESS;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (msgs != <span class="keyword">null</span> &amp;&amp; !msgs.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">for</span> (MessageExt msg : msgs) &#123;</span><br><span class="line">                MessageAccessor.setConsumeStartTimeStamp(msg, String.valueOf(System.currentTimeMillis()));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 具体消息消费业务逻辑</span></span><br><span class="line">        status = listener.consumeMessage(Collections.unmodifiableList(msgs), context);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">        log.warn(<span class="string">&quot;consumeMessage exception: &#123;&#125; Group: &#123;&#125; Msgs: &#123;&#125; MQ: &#123;&#125;&quot;</span>,</span><br><span class="line">            RemotingHelper.exceptionSimpleDesc(e),</span><br><span class="line">            ConsumeMessageConcurrentlyService.<span class="keyword">this</span>.consumerGroup,</span><br><span class="line">            msgs,</span><br><span class="line">            messageQueue);</span><br><span class="line">        hasException = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">long</span> consumeRT = System.currentTimeMillis() - beginTimestamp;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">null</span> == status) &#123;</span><br><span class="line">        <span class="keyword">if</span> (hasException) &#123;</span><br><span class="line">            returnType = ConsumeReturnType.EXCEPTION;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            returnType = ConsumeReturnType.RETURNNULL;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (consumeRT &gt;= defaultMQPushConsumer.getConsumeTimeout() * <span class="number">60</span> * <span class="number">1000</span>) &#123;</span><br><span class="line">        returnType = ConsumeReturnType.TIME_OUT;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ConsumeConcurrentlyStatus.RECONSUME_LATER == status) &#123;</span><br><span class="line">        returnType = ConsumeReturnType.FAILED;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ConsumeConcurrentlyStatus.CONSUME_SUCCESS == status) &#123;</span><br><span class="line">        returnType = ConsumeReturnType.SUCCESS;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ConsumeMessageConcurrentlyService.<span class="keyword">this</span>.defaultMQPushConsumerImpl.hasHook()) &#123;</span><br><span class="line">        consumeMessageContext.getProps().put(MixAll.CONSUME_CONTEXT_TYPE, returnType.name());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">null</span> == status) &#123;</span><br><span class="line">        log.warn(<span class="string">&quot;consumeMessage return null, Group: &#123;&#125; Msgs: &#123;&#125; MQ: &#123;&#125;&quot;</span>,</span><br><span class="line">            ConsumeMessageConcurrentlyService.<span class="keyword">this</span>.consumerGroup,</span><br><span class="line">            msgs,</span><br><span class="line">            messageQueue);</span><br><span class="line">        status = ConsumeConcurrentlyStatus.RECONSUME_LATER;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 钩子函数</span></span><br><span class="line">    <span class="keyword">if</span> (ConsumeMessageConcurrentlyService.<span class="keyword">this</span>.defaultMQPushConsumerImpl.hasHook()) &#123;</span><br><span class="line">        consumeMessageContext.setStatus(status.toString());</span><br><span class="line">        consumeMessageContext.setSuccess(ConsumeConcurrentlyStatus.CONSUME_SUCCESS == status);</span><br><span class="line">        ConsumeMessageConcurrentlyService.<span class="keyword">this</span>.defaultMQPushConsumerImpl.executeHookAfter(consumeMessageContext);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ConsumeMessageConcurrentlyService.<span class="keyword">this</span>.getConsumerStatsManager()</span><br><span class="line">        .incConsumeRT(ConsumeMessageConcurrentlyService.<span class="keyword">this</span>.consumerGroup, messageQueue.getTopic(), consumeRT);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理结果前，再次验证下是否丢弃</span></span><br><span class="line">    <span class="keyword">if</span> (!processQueue.isDropped()) &#123;</span><br><span class="line">        ConsumeMessageConcurrentlyService.<span class="keyword">this</span>.processConsumeResult(status, context, <span class="keyword">this</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        log.warn(<span class="string">&quot;processQueue is dropped without process consume result. messageQueue=&#123;&#125;, msgs=&#123;&#125;&quot;</span>, messageQueue, msgs);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>更新消费进度</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">processConsumeResult</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">final</span> ConsumeConcurrentlyStatus status,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">final</span> ConsumeConcurrentlyContext context,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">final</span> ConsumeRequest consumeRequest</span></span></span><br><span class="line"><span class="params"><span class="function">)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ackIndex = context.getAckIndex();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (consumeRequest.getMsgs().isEmpty())</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (status) &#123;</span><br><span class="line">        <span class="keyword">case</span> CONSUME_SUCCESS:</span><br><span class="line">            <span class="comment">// 消费成功的个数</span></span><br><span class="line">            <span class="keyword">if</span> (ackIndex &gt;= consumeRequest.getMsgs().size()) &#123;</span><br><span class="line">                <span class="comment">// 消费成功，ackIndex = msg.size - 1 即最后一条消息</span></span><br><span class="line">                ackIndex = consumeRequest.getMsgs().size() - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> ok = ackIndex + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">int</span> failed = consumeRequest.getMsgs().size() - ok;</span><br><span class="line">            <span class="keyword">this</span>.getConsumerStatsManager().incConsumeOKTPS(consumerGroup, consumeRequest.getMessageQueue().getTopic(), ok);</span><br><span class="line">            <span class="keyword">this</span>.getConsumerStatsManager().incConsumeFailedTPS(consumerGroup, consumeRequest.getMessageQueue().getTopic(), failed);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> RECONSUME_LATER:</span><br><span class="line">            ackIndex = -<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">this</span>.getConsumerStatsManager().incConsumeFailedTPS(consumerGroup, consumeRequest.getMessageQueue().getTopic(),</span><br><span class="line">                consumeRequest.getMsgs().size());</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (<span class="keyword">this</span>.defaultMQPushConsumer.getMessageModel()) &#123;</span><br><span class="line">        <span class="keyword">case</span> BROADCASTING:</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = ackIndex + <span class="number">1</span>; i &lt; consumeRequest.getMsgs().size(); i++) &#123;</span><br><span class="line">                MessageExt msg = consumeRequest.getMsgs().get(i);</span><br><span class="line">                <span class="comment">// 广播模式，消息消费失败并不会重试</span></span><br><span class="line">                log.warn(<span class="string">&quot;BROADCASTING, the message consume failed, drop it, &#123;&#125;&quot;</span>, msg.toString());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> CLUSTERING:</span><br><span class="line">            List&lt;MessageExt&gt; msgBackFailed = <span class="keyword">new</span> ArrayList&lt;MessageExt&gt;(consumeRequest.getMsgs().size());</span><br><span class="line">            <span class="comment">// 与上面的ackIndex设置向对应，为0时，会去把这批消息重新调用sendMessageBack</span></span><br><span class="line">            <span class="comment">// 发送ack消息（发送给broker延迟消息）</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = ackIndex + <span class="number">1</span>; i &lt; consumeRequest.getMsgs().size(); i++) &#123;</span><br><span class="line">                MessageExt msg = consumeRequest.getMsgs().get(i);</span><br><span class="line">                <span class="comment">// 将消费失败的消息发送到broker，进入重试队列或死信队列</span></span><br><span class="line">                <span class="keyword">boolean</span> result = <span class="keyword">this</span>.sendMessageBack(msg, context);</span><br><span class="line">                <span class="keyword">if</span> (!result) &#123;</span><br><span class="line">                    <span class="comment">// 假如丢入重试队列失败，则在本地重试消费</span></span><br><span class="line">                    msg.setReconsumeTimes(msg.getReconsumeTimes() + <span class="number">1</span>);</span><br><span class="line">                    msgBackFailed.add(msg);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (!msgBackFailed.isEmpty()) &#123;</span><br><span class="line">                consumeRequest.getMsgs().removeAll(msgBackFailed);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 本地消费重试（延迟五秒后重试）</span></span><br><span class="line">                <span class="keyword">this</span>.submitConsumeRequestLater(msgBackFailed, consumeRequest.getProcessQueue(), consumeRequest.getMessageQueue());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从 消息消费队列 中删除这批消息，获取 移除该批消息后最小的偏移量</span></span><br><span class="line">    <span class="comment">// 以便于消费者重启后能从上次消费的位置开始消费</span></span><br><span class="line">    <span class="comment">// 即使消费结果返回的是RECONSUME_LATER,消费偏移量也会发生改变,此时broker会创建出一条全新的但是内容一样的消息,放到commitLog中</span></span><br><span class="line">    <span class="comment">// increaseOnly 只有大于内存中当前的消费偏移量才更新</span></span><br><span class="line">    <span class="keyword">long</span> offset = consumeRequest.getProcessQueue().removeMessage(consumeRequest.getMsgs());</span><br><span class="line">    <span class="keyword">if</span> (offset &gt;= <span class="number">0</span> &amp;&amp; !consumeRequest.getProcessQueue().isDropped()) &#123;</span><br><span class="line">        <span class="keyword">this</span>.defaultMQPushConsumerImpl.getOffsetStore().updateOffset(consumeRequest.getMessageQueue(), offset, <span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Broker"><a href="#Broker" class="headerlink" title="Broker"></a>Broker</h2><h3 id="流程图-7"><a href="#流程图-7" class="headerlink" title="流程图"></a>流程图</h3><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://bb3e216f.onedrive-cf-index-ng-e34.pages.dev/api/raw?path=/Public/BlogImg/RocketMQ/Broker%E6%B6%88%E6%81%AF%E6%B6%88%E8%B4%B9%E6%B5%81%E7%A8%8B.png"
                      alt="Broker消息消费流程.png"
                ></p>
<h3 id="关键代码-6"><a href="#关键代码-6" class="headerlink" title="关键代码"></a>关键代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> RemotingCommand <span class="title">processRequest</span><span class="params">(<span class="keyword">final</span> Channel channel, RemotingCommand request, <span class="keyword">boolean</span> brokerAllowSuspend)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> RemotingCommandException </span>&#123;</span><br><span class="line">    RemotingCommand response = RemotingCommand.createResponseCommand(PullMessageResponseHeader.class);</span><br><span class="line">    <span class="keyword">final</span> PullMessageResponseHeader responseHeader = (PullMessageResponseHeader) response.readCustomHeader();</span><br><span class="line">    <span class="keyword">final</span> PullMessageRequestHeader requestHeader =</span><br><span class="line">        (PullMessageRequestHeader) request.decodeCommandCustomHeader(PullMessageRequestHeader.class);</span><br><span class="line"></span><br><span class="line">    response.setOpaque(request.getOpaque());</span><br><span class="line"></span><br><span class="line">    log.debug(<span class="string">&quot;receive PullMessage request command, &#123;&#125;&quot;</span>, request);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!PermName.isReadable(<span class="keyword">this</span>.brokerController.getBrokerConfig().getBrokerPermission())) &#123;</span><br><span class="line">        response.setCode(ResponseCode.NO_PERMISSION);</span><br><span class="line">        response.setRemark(String.format(<span class="string">&quot;the broker[%s] pulling message is forbidden&quot;</span>, <span class="keyword">this</span>.brokerController.getBrokerConfig().getBrokerIP1()));</span><br><span class="line">        <span class="keyword">return</span> response;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    SubscriptionGroupConfig subscriptionGroupConfig =</span><br><span class="line">        <span class="keyword">this</span>.brokerController.getSubscriptionGroupManager().findSubscriptionGroupConfig(requestHeader.getConsumerGroup());</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">null</span> == subscriptionGroupConfig) &#123;</span><br><span class="line">        response.setCode(ResponseCode.SUBSCRIPTION_GROUP_NOT_EXIST);</span><br><span class="line">        response.setRemark(String.format(<span class="string">&quot;subscription group [%s] does not exist, %s&quot;</span>, requestHeader.getConsumerGroup(), FAQUrl.suggestTodo(FAQUrl.SUBSCRIPTION_GROUP_NOT_EXIST)));</span><br><span class="line">        <span class="keyword">return</span> response;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!subscriptionGroupConfig.isConsumeEnable()) &#123;</span><br><span class="line">        response.setCode(ResponseCode.NO_PERMISSION);</span><br><span class="line">        response.setRemark(<span class="string">&quot;subscription group no permission, &quot;</span> + requestHeader.getConsumerGroup());</span><br><span class="line">        <span class="keyword">return</span> response;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> hasSuspendFlag = PullSysFlag.hasSuspendFlag(requestHeader.getSysFlag());</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> hasCommitOffsetFlag = PullSysFlag.hasCommitOffsetFlag(requestHeader.getSysFlag());</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> hasSubscriptionFlag = PullSysFlag.hasSubscriptionFlag(requestHeader.getSysFlag());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">long</span> suspendTimeoutMillisLong = hasSuspendFlag ? requestHeader.getSuspendTimeoutMillis() : <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    TopicConfig topicConfig = <span class="keyword">this</span>.brokerController.getTopicConfigManager().selectTopicConfig(requestHeader.getTopic());</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">null</span> == topicConfig) &#123;</span><br><span class="line">        log.error(<span class="string">&quot;the topic &#123;&#125; not exist, consumer: &#123;&#125;&quot;</span>, requestHeader.getTopic(), RemotingHelper.parseChannelRemoteAddr(channel));</span><br><span class="line">        response.setCode(ResponseCode.TOPIC_NOT_EXIST);</span><br><span class="line">        response.setRemark(String.format(<span class="string">&quot;topic[%s] not exist, apply first please! %s&quot;</span>, requestHeader.getTopic(), FAQUrl.suggestTodo(FAQUrl.APPLY_TOPIC_URL)));</span><br><span class="line">        <span class="keyword">return</span> response;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!PermName.isReadable(topicConfig.getPerm())) &#123;</span><br><span class="line">        response.setCode(ResponseCode.NO_PERMISSION);</span><br><span class="line">        response.setRemark(<span class="string">&quot;the topic[&quot;</span> + requestHeader.getTopic() + <span class="string">&quot;] pulling message is forbidden&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> response;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (requestHeader.getQueueId() &lt; <span class="number">0</span> || requestHeader.getQueueId() &gt;= topicConfig.getReadQueueNums()) &#123;</span><br><span class="line">        String errorInfo = String.format(<span class="string">&quot;queueId[%d] is illegal, topic:[%s] topicConfig.readQueueNums:[%d] consumer:[%s]&quot;</span>,</span><br><span class="line">            requestHeader.getQueueId(), requestHeader.getTopic(), topicConfig.getReadQueueNums(), channel.remoteAddress());</span><br><span class="line">        log.warn(errorInfo);</span><br><span class="line">        response.setCode(ResponseCode.SYSTEM_ERROR);</span><br><span class="line">        response.setRemark(errorInfo);</span><br><span class="line">        <span class="keyword">return</span> response;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    SubscriptionData subscriptionData = <span class="keyword">null</span>;</span><br><span class="line">    ConsumerFilterData consumerFilterData = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (hasSubscriptionFlag) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            subscriptionData = FilterAPI.build(</span><br><span class="line">                requestHeader.getTopic(), requestHeader.getSubscription(), requestHeader.getExpressionType()</span><br><span class="line">            );</span><br><span class="line">            <span class="keyword">if</span> (!ExpressionType.isTagType(subscriptionData.getExpressionType())) &#123;</span><br><span class="line">                <span class="comment">// 不是TAG模式，构建过滤数据ConsumeFilterData</span></span><br><span class="line">                consumerFilterData = ConsumerFilterManager.build(</span><br><span class="line">                    requestHeader.getTopic(), requestHeader.getConsumerGroup(), requestHeader.getSubscription(),</span><br><span class="line">                    requestHeader.getExpressionType(), requestHeader.getSubVersion()</span><br><span class="line">                );</span><br><span class="line">                <span class="keyword">assert</span> consumerFilterData != <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            log.warn(<span class="string">&quot;Parse the consumer&#x27;s subscription[&#123;&#125;] failed, group: &#123;&#125;&quot;</span>, requestHeader.getSubscription(),</span><br><span class="line">                requestHeader.getConsumerGroup());</span><br><span class="line">            response.setCode(ResponseCode.SUBSCRIPTION_PARSE_FAILED);</span><br><span class="line">            response.setRemark(<span class="string">&quot;parse the consumer&#x27;s subscription failed&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> response;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        ConsumerGroupInfo consumerGroupInfo =</span><br><span class="line">            <span class="keyword">this</span>.brokerController.getConsumerManager().getConsumerGroupInfo(requestHeader.getConsumerGroup());</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> == consumerGroupInfo) &#123;</span><br><span class="line">            log.warn(<span class="string">&quot;the consumer&#x27;s group info not exist, group: &#123;&#125;&quot;</span>, requestHeader.getConsumerGroup());</span><br><span class="line">            response.setCode(ResponseCode.SUBSCRIPTION_NOT_EXIST);</span><br><span class="line">            response.setRemark(<span class="string">&quot;the consumer&#x27;s group info not exist&quot;</span> + FAQUrl.suggestTodo(FAQUrl.SAME_GROUP_DIFFERENT_TOPIC));</span><br><span class="line">            <span class="keyword">return</span> response;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!subscriptionGroupConfig.isConsumeBroadcastEnable()</span><br><span class="line">            &amp;&amp; consumerGroupInfo.getMessageModel() == MessageModel.BROADCASTING) &#123;</span><br><span class="line">            response.setCode(ResponseCode.NO_PERMISSION);</span><br><span class="line">            response.setRemark(<span class="string">&quot;the consumer group[&quot;</span> + requestHeader.getConsumerGroup() + <span class="string">&quot;] can not consume by broadcast way&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> response;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        subscriptionData = consumerGroupInfo.findSubscriptionData(requestHeader.getTopic());</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> == subscriptionData) &#123;</span><br><span class="line">            log.warn(<span class="string">&quot;the consumer&#x27;s subscription not exist, group: &#123;&#125;, topic:&#123;&#125;&quot;</span>, requestHeader.getConsumerGroup(), requestHeader.getTopic());</span><br><span class="line">            response.setCode(ResponseCode.SUBSCRIPTION_NOT_EXIST);</span><br><span class="line">            response.setRemark(<span class="string">&quot;the consumer&#x27;s subscription not exist&quot;</span> + FAQUrl.suggestTodo(FAQUrl.SAME_GROUP_DIFFERENT_TOPIC));</span><br><span class="line">            <span class="keyword">return</span> response;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (subscriptionData.getSubVersion() &lt; requestHeader.getSubVersion()) &#123;</span><br><span class="line">            log.warn(<span class="string">&quot;The broker&#x27;s subscription is not latest, group: &#123;&#125; &#123;&#125;&quot;</span>, requestHeader.getConsumerGroup(),</span><br><span class="line">                subscriptionData.getSubString());</span><br><span class="line">            response.setCode(ResponseCode.SUBSCRIPTION_NOT_LATEST);</span><br><span class="line">            response.setRemark(<span class="string">&quot;the consumer&#x27;s subscription not latest&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> response;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!ExpressionType.isTagType(subscriptionData.getExpressionType())) &#123;</span><br><span class="line">            consumerFilterData = <span class="keyword">this</span>.brokerController.getConsumerFilterManager().get(requestHeader.getTopic(),</span><br><span class="line">                requestHeader.getConsumerGroup());</span><br><span class="line">            <span class="keyword">if</span> (consumerFilterData == <span class="keyword">null</span>) &#123;</span><br><span class="line">                response.setCode(ResponseCode.FILTER_DATA_NOT_EXIST);</span><br><span class="line">                response.setRemark(<span class="string">&quot;The broker&#x27;s consumer filter data is not exist!Your expression may be wrong!&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> response;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (consumerFilterData.getClientVersion() &lt; requestHeader.getSubVersion()) &#123;</span><br><span class="line">                log.warn(<span class="string">&quot;The broker&#x27;s consumer filter data is not latest, group: &#123;&#125;, topic: &#123;&#125;, serverV: &#123;&#125;, clientV: &#123;&#125;&quot;</span>,</span><br><span class="line">                    requestHeader.getConsumerGroup(), requestHeader.getTopic(), consumerFilterData.getClientVersion(), requestHeader.getSubVersion());</span><br><span class="line">                response.setCode(ResponseCode.FILTER_DATA_NOT_LATEST);</span><br><span class="line">                response.setRemark(<span class="string">&quot;the consumer&#x27;s consumer filter data not latest&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> response;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!ExpressionType.isTagType(subscriptionData.getExpressionType())</span><br><span class="line">        &amp;&amp; !<span class="keyword">this</span>.brokerController.getBrokerConfig().isEnablePropertyFilter()) &#123;</span><br><span class="line">        response.setCode(ResponseCode.SYSTEM_ERROR);</span><br><span class="line">        response.setRemark(<span class="string">&quot;The broker does not support consumer to filter message by &quot;</span> + subscriptionData.getExpressionType());</span><br><span class="line">        <span class="keyword">return</span> response;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    MessageFilter messageFilter;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.brokerController.getBrokerConfig().isFilterSupportRetry()) &#123;</span><br><span class="line">        messageFilter = <span class="keyword">new</span> ExpressionForRetryMessageFilter(subscriptionData, consumerFilterData,</span><br><span class="line">            <span class="keyword">this</span>.brokerController.getConsumerFilterManager());</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        messageFilter = <span class="keyword">new</span> ExpressionMessageFilter(subscriptionData, consumerFilterData,</span><br><span class="line">            <span class="keyword">this</span>.brokerController.getConsumerFilterManager());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取消息</span></span><br><span class="line">    <span class="keyword">final</span> GetMessageResult getMessageResult =</span><br><span class="line">        <span class="keyword">this</span>.brokerController.getMessageStore().getMessage(requestHeader.getConsumerGroup(), requestHeader.getTopic(),</span><br><span class="line">            requestHeader.getQueueId(), requestHeader.getQueueOffset(), requestHeader.getMaxMsgNums(), messageFilter);</span><br><span class="line">    <span class="keyword">if</span> (getMessageResult != <span class="keyword">null</span>) &#123;</span><br><span class="line">        response.setRemark(getMessageResult.getStatus().name());</span><br><span class="line">        responseHeader.setNextBeginOffset(getMessageResult.getNextBeginOffset());</span><br><span class="line">        responseHeader.setMinOffset(getMessageResult.getMinOffset());</span><br><span class="line">        responseHeader.setMaxOffset(getMessageResult.getMaxOffset());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (getMessageResult.isSuggestPullingFromSlave()) &#123;</span><br><span class="line">            responseHeader.setSuggestWhichBrokerId(subscriptionGroupConfig.getWhichBrokerWhenConsumeSlowly());</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            responseHeader.setSuggestWhichBrokerId(MixAll.MASTER_ID);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">switch</span> (<span class="keyword">this</span>.brokerController.getMessageStoreConfig().getBrokerRole()) &#123;</span><br><span class="line">            <span class="keyword">case</span> ASYNC_MASTER:</span><br><span class="line">            <span class="keyword">case</span> SYNC_MASTER:</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> SLAVE:</span><br><span class="line">                <span class="keyword">if</span> (!<span class="keyword">this</span>.brokerController.getBrokerConfig().isSlaveReadEnable()) &#123;</span><br><span class="line">                    response.setCode(ResponseCode.PULL_RETRY_IMMEDIATELY);</span><br><span class="line">                    responseHeader.setSuggestWhichBrokerId(MixAll.MASTER_ID);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.brokerController.getBrokerConfig().isSlaveReadEnable()) &#123;</span><br><span class="line">            <span class="comment">// consume too slow ,redirect to another machine</span></span><br><span class="line">            <span class="keyword">if</span> (getMessageResult.isSuggestPullingFromSlave()) &#123;</span><br><span class="line">                responseHeader.setSuggestWhichBrokerId(subscriptionGroupConfig.getWhichBrokerWhenConsumeSlowly());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// consume ok</span></span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                responseHeader.setSuggestWhichBrokerId(subscriptionGroupConfig.getBrokerId());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            responseHeader.setSuggestWhichBrokerId(MixAll.MASTER_ID);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">switch</span> (getMessageResult.getStatus()) &#123;</span><br><span class="line">            <span class="keyword">case</span> FOUND:</span><br><span class="line">                response.setCode(ResponseCode.SUCCESS);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> MESSAGE_WAS_REMOVING:</span><br><span class="line">                response.setCode(ResponseCode.PULL_RETRY_IMMEDIATELY);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> NO_MATCHED_LOGIC_QUEUE:</span><br><span class="line">            <span class="keyword">case</span> NO_MESSAGE_IN_QUEUE:</span><br><span class="line">                <span class="keyword">if</span> (<span class="number">0</span> != requestHeader.getQueueOffset()) &#123;</span><br><span class="line">                    response.setCode(ResponseCode.PULL_OFFSET_MOVED);</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// <span class="doctag">XXX:</span> warn and notify me</span></span><br><span class="line">                    log.info(<span class="string">&quot;the broker store no queue data, fix the request offset &#123;&#125; to &#123;&#125;, Topic: &#123;&#125; QueueId: &#123;&#125; Consumer Group: &#123;&#125;&quot;</span>,</span><br><span class="line">                        requestHeader.getQueueOffset(),</span><br><span class="line">                        getMessageResult.getNextBeginOffset(),</span><br><span class="line">                        requestHeader.getTopic(),</span><br><span class="line">                        requestHeader.getQueueId(),</span><br><span class="line">                        requestHeader.getConsumerGroup()</span><br><span class="line">                    );</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    response.setCode(ResponseCode.PULL_NOT_FOUND);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> NO_MATCHED_MESSAGE:</span><br><span class="line">                response.setCode(ResponseCode.PULL_RETRY_IMMEDIATELY);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> OFFSET_FOUND_NULL:</span><br><span class="line">                response.setCode(ResponseCode.PULL_NOT_FOUND);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> OFFSET_OVERFLOW_BADLY:</span><br><span class="line">                response.setCode(ResponseCode.PULL_OFFSET_MOVED);</span><br><span class="line">                <span class="comment">// <span class="doctag">XXX:</span> warn and notify me</span></span><br><span class="line">                log.info(<span class="string">&quot;the request offset: &#123;&#125; over flow badly, broker max offset: &#123;&#125;, consumer: &#123;&#125;&quot;</span>,</span><br><span class="line">                    requestHeader.getQueueOffset(), getMessageResult.getMaxOffset(), channel.remoteAddress());</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> OFFSET_OVERFLOW_ONE:</span><br><span class="line">                response.setCode(ResponseCode.PULL_NOT_FOUND);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> OFFSET_TOO_SMALL:</span><br><span class="line">                response.setCode(ResponseCode.PULL_OFFSET_MOVED);</span><br><span class="line">                log.info(<span class="string">&quot;the request offset too small. group=&#123;&#125;, topic=&#123;&#125;, requestOffset=&#123;&#125;, brokerMinOffset=&#123;&#125;, clientIp=&#123;&#125;&quot;</span>,</span><br><span class="line">                    requestHeader.getConsumerGroup(), requestHeader.getTopic(), requestHeader.getQueueOffset(),</span><br><span class="line">                    getMessageResult.getMinOffset(), channel.remoteAddress());</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">assert</span> <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.hasConsumeMessageHook()) &#123;</span><br><span class="line">            ConsumeMessageContext context = <span class="keyword">new</span> ConsumeMessageContext();</span><br><span class="line">            context.setConsumerGroup(requestHeader.getConsumerGroup());</span><br><span class="line">            context.setTopic(requestHeader.getTopic());</span><br><span class="line">            context.setQueueId(requestHeader.getQueueId());</span><br><span class="line"></span><br><span class="line">            String owner = request.getExtFields().get(BrokerStatsManager.COMMERCIAL_OWNER);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">switch</span> (response.getCode()) &#123;</span><br><span class="line">                <span class="keyword">case</span> ResponseCode.SUCCESS:</span><br><span class="line">                    <span class="keyword">int</span> commercialBaseCount = brokerController.getBrokerConfig().getCommercialBaseCount();</span><br><span class="line">                    <span class="keyword">int</span> incValue = getMessageResult.getMsgCount4Commercial() * commercialBaseCount;</span><br><span class="line"></span><br><span class="line">                    context.setCommercialRcvStats(BrokerStatsManager.StatsType.RCV_SUCCESS);</span><br><span class="line">                    context.setCommercialRcvTimes(incValue);</span><br><span class="line">                    context.setCommercialRcvSize(getMessageResult.getBufferTotalSize());</span><br><span class="line">                    context.setCommercialOwner(owner);</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> ResponseCode.PULL_NOT_FOUND:</span><br><span class="line">                    <span class="keyword">if</span> (!brokerAllowSuspend) &#123;</span><br><span class="line"></span><br><span class="line">                        context.setCommercialRcvStats(BrokerStatsManager.StatsType.RCV_EPOLLS);</span><br><span class="line">                        context.setCommercialRcvTimes(<span class="number">1</span>);</span><br><span class="line">                        context.setCommercialOwner(owner);</span><br><span class="line"></span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> ResponseCode.PULL_RETRY_IMMEDIATELY:</span><br><span class="line">                <span class="keyword">case</span> ResponseCode.PULL_OFFSET_MOVED:</span><br><span class="line">                    context.setCommercialRcvStats(BrokerStatsManager.StatsType.RCV_EPOLLS);</span><br><span class="line">                    context.setCommercialRcvTimes(<span class="number">1</span>);</span><br><span class="line">                    context.setCommercialOwner(owner);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">default</span>:</span><br><span class="line">                    <span class="keyword">assert</span> <span class="keyword">false</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">this</span>.executeConsumeMessageHookBefore(context);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">switch</span> (response.getCode()) &#123;</span><br><span class="line">            <span class="keyword">case</span> ResponseCode.SUCCESS:</span><br><span class="line"></span><br><span class="line">                <span class="keyword">this</span>.brokerController.getBrokerStatsManager().incGroupGetNums(requestHeader.getConsumerGroup(), requestHeader.getTopic(),</span><br><span class="line">                    getMessageResult.getMessageCount());</span><br><span class="line"></span><br><span class="line">                <span class="keyword">this</span>.brokerController.getBrokerStatsManager().incGroupGetSize(requestHeader.getConsumerGroup(), requestHeader.getTopic(),</span><br><span class="line">                    getMessageResult.getBufferTotalSize());</span><br><span class="line"></span><br><span class="line">                <span class="keyword">this</span>.brokerController.getBrokerStatsManager().incBrokerGetNums(getMessageResult.getMessageCount());</span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">this</span>.brokerController.getBrokerConfig().isTransferMsgByHeap()) &#123;</span><br><span class="line">                    <span class="keyword">final</span> <span class="keyword">long</span> beginTimeMills = <span class="keyword">this</span>.brokerController.getMessageStore().now();</span><br><span class="line">                    <span class="keyword">final</span> <span class="keyword">byte</span>[] r = <span class="keyword">this</span>.readGetMessageResult(getMessageResult, requestHeader.getConsumerGroup(), requestHeader.getTopic(), requestHeader.getQueueId());</span><br><span class="line">                    <span class="keyword">this</span>.brokerController.getBrokerStatsManager().incGroupGetLatency(requestHeader.getConsumerGroup(),</span><br><span class="line">                        requestHeader.getTopic(), requestHeader.getQueueId(),</span><br><span class="line">                        (<span class="keyword">int</span>) (<span class="keyword">this</span>.brokerController.getMessageStore().now() - beginTimeMills));</span><br><span class="line">                    response.setBody(r);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        FileRegion fileRegion =</span><br><span class="line">                            <span class="keyword">new</span> ManyMessageTransfer(response.encodeHeader(getMessageResult.getBufferTotalSize()), getMessageResult);</span><br><span class="line">                        channel.writeAndFlush(fileRegion).addListener(<span class="keyword">new</span> ChannelFutureListener() &#123;</span><br><span class="line">                            <span class="meta">@Override</span></span><br><span class="line">                            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operationComplete</span><span class="params">(ChannelFuture future)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                                getMessageResult.release();</span><br><span class="line">                                <span class="keyword">if</span> (!future.isSuccess()) &#123;</span><br><span class="line">                                    log.error(<span class="string">&quot;transfer many message by pagecache failed, &#123;&#125;&quot;</span>, channel.remoteAddress(), future.cause());</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">                        log.error(<span class="string">&quot;transfer many message by pagecache exception&quot;</span>, e);</span><br><span class="line">                        getMessageResult.release();</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    response = <span class="keyword">null</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> ResponseCode.PULL_NOT_FOUND:</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (brokerAllowSuspend &amp;&amp; hasSuspendFlag) &#123;</span><br><span class="line">                    <span class="keyword">long</span> pollingTimeMills = suspendTimeoutMillisLong;</span><br><span class="line">                    <span class="comment">// 长轮询模式</span></span><br><span class="line">                    <span class="keyword">if</span> (!<span class="keyword">this</span>.brokerController.getBrokerConfig().isLongPollingEnable()) &#123;</span><br><span class="line">                        pollingTimeMills = <span class="keyword">this</span>.brokerController.getBrokerConfig().getShortPollingTimeMills();</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    String topic = requestHeader.getTopic();</span><br><span class="line">                    <span class="keyword">long</span> offset = requestHeader.getQueueOffset();</span><br><span class="line">                    <span class="keyword">int</span> queueId = requestHeader.getQueueId();</span><br><span class="line">                    <span class="comment">// channel 网络通道，通过该通道向消息拉取客户端发送响应结果</span></span><br><span class="line">                    PullRequest pullRequest = <span class="keyword">new</span> PullRequest(request, channel, pollingTimeMills,</span><br><span class="line">                        <span class="keyword">this</span>.brokerController.getMessageStore().now(), offset, subscriptionData, messageFilter);</span><br><span class="line">                    <span class="comment">// 提交到PullRequestsHoldService线程中</span></span><br><span class="line">                    <span class="keyword">this</span>.brokerController.getPullRequestHoldService().suspendPullRequest(topic, queueId, pullRequest);</span><br><span class="line">                    response = <span class="keyword">null</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">case</span> ResponseCode.PULL_RETRY_IMMEDIATELY:</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> ResponseCode.PULL_OFFSET_MOVED:</span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">this</span>.brokerController.getMessageStoreConfig().getBrokerRole() != BrokerRole.SLAVE</span><br><span class="line">                    || <span class="keyword">this</span>.brokerController.getMessageStoreConfig().isOffsetCheckInSlave()) &#123;</span><br><span class="line">                    MessageQueue mq = <span class="keyword">new</span> MessageQueue();</span><br><span class="line">                    mq.setTopic(requestHeader.getTopic());</span><br><span class="line">                    mq.setQueueId(requestHeader.getQueueId());</span><br><span class="line">                    mq.setBrokerName(<span class="keyword">this</span>.brokerController.getBrokerConfig().getBrokerName());</span><br><span class="line"></span><br><span class="line">                    OffsetMovedEvent event = <span class="keyword">new</span> OffsetMovedEvent();</span><br><span class="line">                    event.setConsumerGroup(requestHeader.getConsumerGroup());</span><br><span class="line">                    event.setMessageQueue(mq);</span><br><span class="line">                    event.setOffsetRequest(requestHeader.getQueueOffset());</span><br><span class="line">                    event.setOffsetNew(getMessageResult.getNextBeginOffset());</span><br><span class="line">                    <span class="keyword">this</span>.generateOffsetMovedEvent(event);</span><br><span class="line">                    log.warn(</span><br><span class="line">                        <span class="string">&quot;PULL_OFFSET_MOVED:correction offset. topic=&#123;&#125;, groupId=&#123;&#125;, requestOffset=&#123;&#125;, newOffset=&#123;&#125;, suggestBrokerId=&#123;&#125;&quot;</span>,</span><br><span class="line">                        requestHeader.getTopic(), requestHeader.getConsumerGroup(), event.getOffsetRequest(), event.getOffsetNew(),</span><br><span class="line">                        responseHeader.getSuggestWhichBrokerId());</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    responseHeader.setSuggestWhichBrokerId(subscriptionGroupConfig.getBrokerId());</span><br><span class="line">                    response.setCode(ResponseCode.PULL_RETRY_IMMEDIATELY);</span><br><span class="line">                    log.warn(<span class="string">&quot;PULL_OFFSET_MOVED:none correction. topic=&#123;&#125;, groupId=&#123;&#125;, requestOffset=&#123;&#125;, suggestBrokerId=&#123;&#125;&quot;</span>,</span><br><span class="line">                        requestHeader.getTopic(), requestHeader.getConsumerGroup(), requestHeader.getQueueOffset(),</span><br><span class="line">                        responseHeader.getSuggestWhichBrokerId());</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">assert</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        response.setCode(ResponseCode.SYSTEM_ERROR);</span><br><span class="line">        response.setRemark(<span class="string">&quot;store getMessage return null&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">boolean</span> storeOffsetEnable = brokerAllowSuspend;</span><br><span class="line">    storeOffsetEnable = storeOffsetEnable &amp;&amp; hasCommitOffsetFlag;</span><br><span class="line">    storeOffsetEnable = storeOffsetEnable</span><br><span class="line">        &amp;&amp; <span class="keyword">this</span>.brokerController.getMessageStoreConfig().getBrokerRole() != BrokerRole.SLAVE;</span><br><span class="line">    <span class="keyword">if</span> (storeOffsetEnable) &#123;</span><br><span class="line">        <span class="keyword">this</span>.brokerController.getConsumerOffsetManager().commitOffset(RemotingHelper.parseChannelRemoteAddr(channel),</span><br><span class="line">            requestHeader.getConsumerGroup(), requestHeader.getTopic(), requestHeader.getQueueId(), requestHeader.getCommitOffset());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> response;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> GetMessageResult <span class="title">getMessage</span><span class="params">(<span class="keyword">final</span> String group, <span class="keyword">final</span> String topic, <span class="keyword">final</span> <span class="keyword">int</span> queueId, <span class="keyword">final</span> <span class="keyword">long</span> offset,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">final</span> <span class="keyword">int</span> maxMsgNums,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">final</span> MessageFilter messageFilter)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.shutdown) &#123;</span><br><span class="line">        log.warn(<span class="string">&quot;message store has shutdown, so getMessage is forbidden&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">this</span>.runningFlags.isReadable()) &#123;</span><br><span class="line">        log.warn(<span class="string">&quot;message store is not readable, so getMessage is forbidden &quot;</span> + <span class="keyword">this</span>.runningFlags.getFlagBits());</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">long</span> beginTime = <span class="keyword">this</span>.getSystemClock().now();</span><br><span class="line"></span><br><span class="line">    GetMessageStatus status = GetMessageStatus.NO_MESSAGE_IN_QUEUE;</span><br><span class="line">    <span class="comment">// 待查找队列的偏移量</span></span><br><span class="line">    <span class="keyword">long</span> nextBeginOffset = offset;</span><br><span class="line">    <span class="comment">// 当前消息队列的最小偏移量</span></span><br><span class="line">    <span class="keyword">long</span> minOffset = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 当前消息队列的最大偏移量</span></span><br><span class="line">    <span class="keyword">long</span> maxOffset = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    GetMessageResult getResult = <span class="keyword">new</span> GetMessageResult();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当前CommitLog文件的最大偏移量</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">long</span> maxOffsetPy = <span class="keyword">this</span>.commitLog.getMaxOffset();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据topic与队列id获取对应的ConsumeQueue文件</span></span><br><span class="line">    ConsumeQueue consumeQueue = findConsumeQueue(topic, queueId);</span><br><span class="line">    <span class="keyword">if</span> (consumeQueue != <span class="keyword">null</span>) &#123;</span><br><span class="line">        minOffset = consumeQueue.getMinOffsetInQueue();</span><br><span class="line">        maxOffset = consumeQueue.getMaxOffsetInQueue();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (maxOffset == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 代表当前消息队列没有消息</span></span><br><span class="line">            status = GetMessageStatus.NO_MESSAGE_IN_QUEUE;</span><br><span class="line">            nextBeginOffset = nextOffsetCorrection(offset, <span class="number">0</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (offset &lt; minOffset) &#123;</span><br><span class="line">            <span class="comment">// 待拉取消息偏移量小于队列的起始偏移量</span></span><br><span class="line">            status = GetMessageStatus.OFFSET_TOO_SMALL;</span><br><span class="line">            nextBeginOffset = nextOffsetCorrection(offset, minOffset);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (offset == maxOffset) &#123;</span><br><span class="line">            <span class="comment">// 待拉取消息偏移量等于队列的起始偏移量</span></span><br><span class="line">            status = GetMessageStatus.OFFSET_OVERFLOW_ONE;</span><br><span class="line">            nextBeginOffset = nextOffsetCorrection(offset, offset);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (offset &gt; maxOffset) &#123;</span><br><span class="line">            <span class="comment">// 带拉取消息偏移量大于队列的其实偏移量</span></span><br><span class="line">            status = GetMessageStatus.OFFSET_OVERFLOW_BADLY;</span><br><span class="line">            <span class="keyword">if</span> (<span class="number">0</span> == minOffset) &#123;</span><br><span class="line">                nextBeginOffset = nextOffsetCorrection(offset, minOffset);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                nextBeginOffset = nextOffsetCorrection(offset, maxOffset);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 偏移量合法</span></span><br><span class="line">            SelectMappedBufferResult bufferConsumeQueue = consumeQueue.getIndexBuffer(offset);</span><br><span class="line">            <span class="keyword">if</span> (bufferConsumeQueue != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    status = GetMessageStatus.NO_MATCHED_MESSAGE;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">long</span> nextPhyFileStartOffset = Long.MIN_VALUE;</span><br><span class="line">                    <span class="keyword">long</span> maxPhyOffsetPulling = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">                    <span class="comment">// 客户端传过来的拉取消息条数限制</span></span><br><span class="line">                    <span class="keyword">final</span> <span class="keyword">int</span> maxFilterMessageCount = Math.max(<span class="number">16000</span>, maxMsgNums * ConsumeQueue.CQ_STORE_UNIT_SIZE);</span><br><span class="line">                    <span class="keyword">final</span> <span class="keyword">boolean</span> diskFallRecorded = <span class="keyword">this</span>.messageStoreConfig.isDiskFallRecorded();</span><br><span class="line">                    ConsumeQueueExt.CqExtUnit cqExtUnit = <span class="keyword">new</span> ConsumeQueueExt.CqExtUnit();</span><br><span class="line">                    <span class="keyword">for</span> (; i &lt; bufferConsumeQueue.getSize() &amp;&amp; i &lt; maxFilterMessageCount; i += ConsumeQueue.CQ_STORE_UNIT_SIZE) &#123;</span><br><span class="line">                        <span class="keyword">long</span> offsetPy = bufferConsumeQueue.getByteBuffer().getLong();</span><br><span class="line">                        <span class="keyword">int</span> sizePy = bufferConsumeQueue.getByteBuffer().getInt();</span><br><span class="line">                        <span class="keyword">long</span> tagsCode = bufferConsumeQueue.getByteBuffer().getLong();</span><br><span class="line"></span><br><span class="line">                        maxPhyOffsetPulling = offsetPy;</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">if</span> (nextPhyFileStartOffset != Long.MIN_VALUE) &#123;</span><br><span class="line">                            <span class="keyword">if</span> (offsetPy &lt; nextPhyFileStartOffset)</span><br><span class="line">                                <span class="keyword">continue</span>;</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">boolean</span> isInDisk = checkInDiskByCommitOffset(offsetPy, maxOffsetPy);</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">if</span> (<span class="keyword">this</span>.isTheBatchFull(sizePy, maxMsgNums, getResult.getBufferTotalSize(), getResult.getMessageCount(),</span><br><span class="line">                            isInDisk)) &#123;</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">boolean</span> extRet = <span class="keyword">false</span>, isTagsCodeLegal = <span class="keyword">true</span>;</span><br><span class="line">                        <span class="keyword">if</span> (consumeQueue.isExtAddr(tagsCode)) &#123;</span><br><span class="line">                            extRet = consumeQueue.getExt(tagsCode, cqExtUnit);</span><br><span class="line">                            <span class="keyword">if</span> (extRet) &#123;</span><br><span class="line">                                tagsCode = cqExtUnit.getTagsCode();</span><br><span class="line">                            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                                <span class="comment">// can&#x27;t find ext content.Client will filter messages by tag also.</span></span><br><span class="line">                                log.error(<span class="string">&quot;[BUG] can&#x27;t find consume queue extend file content!addr=&#123;&#125;, offsetPy=&#123;&#125;, sizePy=&#123;&#125;, topic=&#123;&#125;, group=&#123;&#125;&quot;</span>,</span><br><span class="line">                                    tagsCode, offsetPy, sizePy, topic, group);</span><br><span class="line">                                isTagsCodeLegal = <span class="keyword">false</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">if</span> (messageFilter != <span class="keyword">null</span></span><br><span class="line">                            <span class="comment">// 根据tag hash码过滤</span></span><br><span class="line">                            &amp;&amp; !messageFilter.isMatchedByConsumeQueue(isTagsCodeLegal ? tagsCode : <span class="keyword">null</span>, extRet ? cqExtUnit : <span class="keyword">null</span>)) &#123;</span><br><span class="line">                            <span class="keyword">if</span> (getResult.getBufferTotalSize() == <span class="number">0</span>) &#123;</span><br><span class="line">                                status = GetMessageStatus.NO_MATCHED_MESSAGE;</span><br><span class="line">                            &#125;</span><br><span class="line"></span><br><span class="line">                            <span class="keyword">continue</span>;</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        <span class="comment">// 以上为从ConsumeQueue中获取消息在CommitLog中的偏移量及大小</span></span><br><span class="line">                        <span class="comment">// 以下为从CommitLog中获取对应的消息内容</span></span><br><span class="line">                        SelectMappedBufferResult selectResult = <span class="keyword">this</span>.commitLog.getMessage(offsetPy, sizePy);</span><br><span class="line">                        <span class="keyword">if</span> (<span class="keyword">null</span> == selectResult) &#123;</span><br><span class="line">                            <span class="keyword">if</span> (getResult.getBufferTotalSize() == <span class="number">0</span>) &#123;</span><br><span class="line">                                status = GetMessageStatus.MESSAGE_WAS_REMOVING;</span><br><span class="line">                            &#125;</span><br><span class="line"></span><br><span class="line">                            nextPhyFileStartOffset = <span class="keyword">this</span>.commitLog.rollNextFile(offsetPy);</span><br><span class="line">                            <span class="keyword">continue</span>;</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">if</span> (messageFilter != <span class="keyword">null</span></span><br><span class="line">                            &amp;&amp; !messageFilter.isMatchedByCommitLog(selectResult.getByteBuffer().slice(), <span class="keyword">null</span>)) &#123;</span><br><span class="line">                            <span class="keyword">if</span> (getResult.getBufferTotalSize() == <span class="number">0</span>) &#123;</span><br><span class="line">                                status = GetMessageStatus.NO_MATCHED_MESSAGE;</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="comment">// release...</span></span><br><span class="line">                            selectResult.release();</span><br><span class="line">                            <span class="keyword">continue</span>;</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">this</span>.storeStatsService.getGetMessageTransferedMsgCount().incrementAndGet();</span><br><span class="line">                        getResult.addMessage(selectResult);</span><br><span class="line">                        status = GetMessageStatus.FOUND;</span><br><span class="line">                        nextPhyFileStartOffset = Long.MIN_VALUE;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (diskFallRecorded) &#123;</span><br><span class="line">                        <span class="keyword">long</span> fallBehind = maxOffsetPy - maxPhyOffsetPulling;</span><br><span class="line">                        brokerStatsManager.recordDiskFallBehindSize(group, topic, queueId, fallBehind);</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    nextBeginOffset = offset + (i / ConsumeQueue.CQ_STORE_UNIT_SIZE);</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">long</span> diff = maxOffsetPy - maxPhyOffsetPulling;</span><br><span class="line">                    <span class="keyword">long</span> memory = (<span class="keyword">long</span>) (StoreUtil.TOTAL_PHYSICAL_MEMORY_SIZE</span><br><span class="line">                        * (<span class="keyword">this</span>.messageStoreConfig.getAccessMessageInMemoryMaxRatio() / <span class="number">100.0</span>));</span><br><span class="line">                    getResult.setSuggestPullingFromSlave(diff &gt; memory);</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line"></span><br><span class="line">                    bufferConsumeQueue.release();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                status = GetMessageStatus.OFFSET_FOUND_NULL;</span><br><span class="line">                nextBeginOffset = nextOffsetCorrection(offset, consumeQueue.rollNextFile(offset));</span><br><span class="line">                log.warn(<span class="string">&quot;consumer request topic: &quot;</span> + topic + <span class="string">&quot;offset: &quot;</span> + offset + <span class="string">&quot; minOffset: &quot;</span> + minOffset + <span class="string">&quot; maxOffset: &quot;</span></span><br><span class="line">                    + maxOffset + <span class="string">&quot;, but access logic queue failed.&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        status = GetMessageStatus.NO_MATCHED_LOGIC_QUEUE;</span><br><span class="line">        nextBeginOffset = nextOffsetCorrection(offset, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (GetMessageStatus.FOUND == status) &#123;</span><br><span class="line">        <span class="keyword">this</span>.storeStatsService.getGetMessageTimesTotalFound().incrementAndGet();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.storeStatsService.getGetMessageTimesTotalMiss().incrementAndGet();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">long</span> elapsedTime = <span class="keyword">this</span>.getSystemClock().now() - beginTime;</span><br><span class="line">    <span class="keyword">this</span>.storeStatsService.setGetMessageEntireTimeMax(elapsedTime);</span><br><span class="line"></span><br><span class="line">    getResult.setStatus(status);</span><br><span class="line">    getResult.setNextBeginOffset(nextBeginOffset);</span><br><span class="line">    getResult.setMaxOffset(maxOffset);</span><br><span class="line">    getResult.setMinOffset(minOffset);</span><br><span class="line">    <span class="keyword">return</span> getResult;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="消息消费失败处理"><a href="#消息消费失败处理" class="headerlink" title="消息消费失败处理"></a>消息消费失败处理</h2><p>非顺序消息 =&gt; CONSUMER_SEND_MSG_BACK<br>丢入重试队列或死信队列</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> RemotingCommand <span class="title">consumerSendMsgBack</span><span class="params">(<span class="keyword">final</span> ChannelHandlerContext ctx, <span class="keyword">final</span> RemotingCommand request)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> RemotingCommandException </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> RemotingCommand response = RemotingCommand.createResponseCommand(<span class="keyword">null</span>);</span><br><span class="line">    <span class="keyword">final</span> ConsumerSendMsgBackRequestHeader requestHeader =</span><br><span class="line">        (ConsumerSendMsgBackRequestHeader)request.decodeCommandCustomHeader(ConsumerSendMsgBackRequestHeader.class);</span><br><span class="line"></span><br><span class="line">    String namespace = NamespaceUtil.getNamespaceFromResource(requestHeader.getGroup());</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.hasConsumeMessageHook() &amp;&amp; !UtilAll.isBlank(requestHeader.getOriginMsgId())) &#123;</span><br><span class="line"></span><br><span class="line">        ConsumeMessageContext context = <span class="keyword">new</span> ConsumeMessageContext();</span><br><span class="line">        context.setNamespace(namespace);</span><br><span class="line">        context.setConsumerGroup(requestHeader.getGroup());</span><br><span class="line">        context.setTopic(requestHeader.getOriginTopic());</span><br><span class="line">        context.setCommercialRcvStats(BrokerStatsManager.StatsType.SEND_BACK);</span><br><span class="line">        context.setCommercialRcvTimes(<span class="number">1</span>);</span><br><span class="line">        context.setCommercialOwner(request.getExtFields().get(BrokerStatsManager.COMMERCIAL_OWNER));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>.executeConsumeMessageHookAfter(context);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取消费组的订阅配置信息</span></span><br><span class="line">    SubscriptionGroupConfig subscriptionGroupConfig =</span><br><span class="line">        <span class="keyword">this</span>.brokerController.getSubscriptionGroupManager().findSubscriptionGroupConfig(requestHeader.getGroup());</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">null</span> == subscriptionGroupConfig) &#123;</span><br><span class="line">        response.setCode(ResponseCode.SUBSCRIPTION_GROUP_NOT_EXIST);</span><br><span class="line">        response.setRemark(<span class="string">&quot;subscription group not exist, &quot;</span> + requestHeader.getGroup() + <span class="string">&quot; &quot;</span></span><br><span class="line">            + FAQUrl.suggestTodo(FAQUrl.SUBSCRIPTION_GROUP_NOT_EXIST));</span><br><span class="line">        <span class="keyword">return</span> response;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!PermName.isWriteable(<span class="keyword">this</span>.brokerController.getBrokerConfig().getBrokerPermission())) &#123;</span><br><span class="line">        response.setCode(ResponseCode.NO_PERMISSION);</span><br><span class="line">        response.setRemark(<span class="string">&quot;the broker[&quot;</span> + <span class="keyword">this</span>.brokerController.getBrokerConfig().getBrokerIP1() + <span class="string">&quot;] sending message is forbidden&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> response;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重试队列数量小于1</span></span><br><span class="line">    <span class="keyword">if</span> (subscriptionGroupConfig.getRetryQueueNums() &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        response.setCode(ResponseCode.SUCCESS);</span><br><span class="line">        response.setRemark(<span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">return</span> response;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    String newTopic = MixAll.getRetryTopic(requestHeader.getGroup());</span><br><span class="line">    <span class="keyword">int</span> queueIdInt = Math.abs(<span class="keyword">this</span>.random.nextInt() % <span class="number">99999999</span>) % subscriptionGroupConfig.getRetryQueueNums();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> topicSysFlag = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (requestHeader.isUnitMode()) &#123;</span><br><span class="line">        topicSysFlag = TopicSysFlag.buildSysFlag(<span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建重试队列</span></span><br><span class="line">    TopicConfig topicConfig = <span class="keyword">this</span>.brokerController.getTopicConfigManager().createTopicInSendMessageBackMethod(</span><br><span class="line">        newTopic,</span><br><span class="line">        subscriptionGroupConfig.getRetryQueueNums(),</span><br><span class="line">        PermName.PERM_WRITE | PermName.PERM_READ, topicSysFlag);</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">null</span> == topicConfig) &#123;</span><br><span class="line">        response.setCode(ResponseCode.SYSTEM_ERROR);</span><br><span class="line">        response.setRemark(<span class="string">&quot;topic[&quot;</span> + newTopic + <span class="string">&quot;] not exist&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> response;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!PermName.isWriteable(topicConfig.getPerm())) &#123;</span><br><span class="line">        response.setCode(ResponseCode.NO_PERMISSION);</span><br><span class="line">        response.setRemark(String.format(<span class="string">&quot;the topic[%s] sending message is forbidden&quot;</span>, newTopic));</span><br><span class="line">        <span class="keyword">return</span> response;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    MessageExt msgExt = <span class="keyword">this</span>.brokerController.getMessageStore().lookMessageByOffset(requestHeader.getOffset());</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">null</span> == msgExt) &#123;</span><br><span class="line">        response.setCode(ResponseCode.SYSTEM_ERROR);</span><br><span class="line">        response.setRemark(<span class="string">&quot;look message by offset failed, &quot;</span> + requestHeader.getOffset());</span><br><span class="line">        <span class="keyword">return</span> response;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> String retryTopic = msgExt.getProperty(MessageConst.PROPERTY_RETRY_TOPIC);</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">null</span> == retryTopic) &#123;</span><br><span class="line">        MessageAccessor.putProperty(msgExt, MessageConst.PROPERTY_RETRY_TOPIC, msgExt.getTopic());</span><br><span class="line">    &#125;</span><br><span class="line">    msgExt.setWaitStoreMsgOK(<span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> delayLevel = requestHeader.getDelayLevel();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> maxReconsumeTimes = subscriptionGroupConfig.getRetryMaxTimes();</span><br><span class="line">    <span class="keyword">if</span> (request.getVersion() &gt;= MQVersion.Version.V3_4_9.ordinal()) &#123;</span><br><span class="line">        maxReconsumeTimes = requestHeader.getMaxReconsumeTimes();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (msgExt.getReconsumeTimes() &gt;= maxReconsumeTimes</span><br><span class="line">        || delayLevel &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        newTopic = MixAll.getDLQTopic(requestHeader.getGroup());</span><br><span class="line">        <span class="comment">// 超出重试次数，丢到死信队列中</span></span><br><span class="line">        queueIdInt = Math.abs(<span class="keyword">this</span>.random.nextInt() % <span class="number">99999999</span>) % DLQ_NUMS_PER_GROUP;</span><br><span class="line"></span><br><span class="line">        topicConfig = <span class="keyword">this</span>.brokerController.getTopicConfigManager().createTopicInSendMessageBackMethod(newTopic,</span><br><span class="line">            DLQ_NUMS_PER_GROUP,</span><br><span class="line">            PermName.PERM_WRITE, <span class="number">0</span></span><br><span class="line">        );</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> == topicConfig) &#123;</span><br><span class="line">            response.setCode(ResponseCode.SYSTEM_ERROR);</span><br><span class="line">            response.setRemark(<span class="string">&quot;topic[&quot;</span> + newTopic + <span class="string">&quot;] not exist&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> response;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 根据重试次数设置延迟级别</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="number">0</span> == delayLevel) &#123;</span><br><span class="line">            delayLevel = <span class="number">3</span> + msgExt.getReconsumeTimes();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        msgExt.setDelayTimeLevel(delayLevel);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    MessageExtBrokerInner msgInner = <span class="keyword">new</span> MessageExtBrokerInner();</span><br><span class="line">    msgInner.setTopic(newTopic);</span><br><span class="line">    msgInner.setBody(msgExt.getBody());</span><br><span class="line">    msgInner.setFlag(msgExt.getFlag());</span><br><span class="line">    MessageAccessor.setProperties(msgInner, msgExt.getProperties());</span><br><span class="line">    msgInner.setPropertiesString(MessageDecoder.messageProperties2String(msgExt.getProperties()));</span><br><span class="line">    msgInner.setTagsCode(MessageExtBrokerInner.tagsString2tagsCode(<span class="keyword">null</span>, msgExt.getTags()));</span><br><span class="line"></span><br><span class="line">    msgInner.setQueueId(queueIdInt);</span><br><span class="line">    msgInner.setSysFlag(msgExt.getSysFlag());</span><br><span class="line">    msgInner.setBornTimestamp(msgExt.getBornTimestamp());</span><br><span class="line">    msgInner.setBornHost(msgExt.getBornHost());</span><br><span class="line">    msgInner.setStoreHost(<span class="keyword">this</span>.getStoreHost());</span><br><span class="line">    msgInner.setReconsumeTimes(msgExt.getReconsumeTimes() + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    String originMsgId = MessageAccessor.getOriginMessageId(msgExt);</span><br><span class="line">    MessageAccessor.setOriginMessageId(msgInner, UtilAll.isBlank(originMsgId) ? msgExt.getMsgId() : originMsgId);</span><br><span class="line"></span><br><span class="line">    PutMessageResult putMessageResult = <span class="keyword">this</span>.brokerController.getMessageStore().putMessage(msgInner);</span><br><span class="line">    <span class="keyword">if</span> (putMessageResult != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">switch</span> (putMessageResult.getPutMessageStatus()) &#123;</span><br><span class="line">            <span class="keyword">case</span> PUT_OK:</span><br><span class="line">                String backTopic = msgExt.getTopic();</span><br><span class="line">                String correctTopic = msgExt.getProperty(MessageConst.PROPERTY_RETRY_TOPIC);</span><br><span class="line">                <span class="keyword">if</span> (correctTopic != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    backTopic = correctTopic;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">this</span>.brokerController.getBrokerStatsManager().incSendBackNums(requestHeader.getGroup(), backTopic);</span><br><span class="line"></span><br><span class="line">                response.setCode(ResponseCode.SUCCESS);</span><br><span class="line">                response.setRemark(<span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span> response;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        response.setCode(ResponseCode.SYSTEM_ERROR);</span><br><span class="line">        response.setRemark(putMessageResult.getPutMessageStatus().name());</span><br><span class="line">        <span class="keyword">return</span> response;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    response.setCode(ResponseCode.SYSTEM_ERROR);</span><br><span class="line">    response.setRemark(<span class="string">&quot;putMessageResult is null&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> response;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="消息长轮询"><a href="#消息长轮询" class="headerlink" title="消息长轮询"></a>消息长轮询</h2><p>假如消息拉取开启了长轮询，服务端在没有新消息的时候，会将客户端的请求hold住（直至超时），然后等有新消息时再激活客户端请求，给客户端传输数据</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">case</span> ResponseCode.PULL_NOT_FOUND:</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (brokerAllowSuspend &amp;&amp; hasSuspendFlag) &#123;</span><br><span class="line">        <span class="keyword">long</span> pollingTimeMills = suspendTimeoutMillisLong;</span><br><span class="line">        <span class="comment">// 长轮询模式</span></span><br><span class="line">        <span class="keyword">if</span> (!<span class="keyword">this</span>.brokerController.getBrokerConfig().isLongPollingEnable()) &#123;</span><br><span class="line">            pollingTimeMills = <span class="keyword">this</span>.brokerController.getBrokerConfig().getShortPollingTimeMills();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        String topic = requestHeader.getTopic();</span><br><span class="line">        <span class="keyword">long</span> offset = requestHeader.getQueueOffset();</span><br><span class="line">        <span class="keyword">int</span> queueId = requestHeader.getQueueId();</span><br><span class="line">        <span class="comment">// channel 网络通道，通过该通道向消息拉取客户端发送响应结果</span></span><br><span class="line">        PullRequest pullRequest = <span class="keyword">new</span> PullRequest(request, channel, pollingTimeMills,</span><br><span class="line">            <span class="keyword">this</span>.brokerController.getMessageStore().now(), offset, subscriptionData, messageFilter);</span><br><span class="line">        <span class="comment">// 提交到PullRequestsHoldService线程中</span></span><br><span class="line">        <span class="keyword">this</span>.brokerController.getPullRequestHoldService().suspendPullRequest(topic, queueId, pullRequest);</span><br><span class="line">        response = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>PullRequestHoldService定时执行</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    log.info(<span class="string">&quot;&#123;&#125; service started&quot;</span>, <span class="keyword">this</span>.getServiceName());</span><br><span class="line">    <span class="keyword">while</span> (!<span class="keyword">this</span>.isStopped()) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.brokerController.getBrokerConfig().isLongPollingEnable()) &#123;</span><br><span class="line">                <span class="keyword">this</span>.waitForRunning(<span class="number">5</span> * <span class="number">1000</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">this</span>.waitForRunning(<span class="keyword">this</span>.brokerController.getBrokerConfig().getShortPollingTimeMills());</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">long</span> beginLockTimestamp = <span class="keyword">this</span>.systemClock.now();</span><br><span class="line">            <span class="keyword">this</span>.checkHoldRequest();</span><br><span class="line">            <span class="keyword">long</span> costTime = <span class="keyword">this</span>.systemClock.now() - beginLockTimestamp;</span><br><span class="line">            <span class="keyword">if</span> (costTime &gt; <span class="number">5</span> * <span class="number">1000</span>) &#123;</span><br><span class="line">                log.info(<span class="string">&quot;[NOTIFYME] check hold request cost &#123;&#125; ms.&quot;</span>, costTime);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">            log.warn(<span class="keyword">this</span>.getServiceName() + <span class="string">&quot; service has exception. &quot;</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    log.info(<span class="string">&quot;&#123;&#125; service end&quot;</span>, <span class="keyword">this</span>.getServiceName());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">notifyMessageArriving</span><span class="params">(<span class="keyword">final</span> String topic, <span class="keyword">final</span> <span class="keyword">int</span> queueId, <span class="keyword">final</span> <span class="keyword">long</span> maxOffset, <span class="keyword">final</span> Long tagsCode,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">long</span> msgStoreTime, <span class="keyword">byte</span>[] filterBitMap, Map&lt;String, String&gt; properties)</span> </span>&#123;</span><br><span class="line">    String key = <span class="keyword">this</span>.buildKey(topic, queueId);</span><br><span class="line">    ManyPullRequest mpr = <span class="keyword">this</span>.pullRequestTable.get(key);</span><br><span class="line">    <span class="keyword">if</span> (mpr != <span class="keyword">null</span>) &#123;</span><br><span class="line">        List&lt;PullRequest&gt; requestList = mpr.cloneListAndClear();</span><br><span class="line">        <span class="keyword">if</span> (requestList != <span class="keyword">null</span>) &#123;</span><br><span class="line">            List&lt;PullRequest&gt; replayList = <span class="keyword">new</span> ArrayList&lt;PullRequest&gt;();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (PullRequest request : requestList) &#123;</span><br><span class="line">                <span class="keyword">long</span> newestOffset = maxOffset;</span><br><span class="line">                <span class="keyword">if</span> (newestOffset &lt;= request.getPullFromThisOffset()) &#123;</span><br><span class="line">                    newestOffset = <span class="keyword">this</span>.brokerController.getMessageStore().getMaxOffsetInQueue(topic, queueId);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (newestOffset &gt; request.getPullFromThisOffset()) &#123;</span><br><span class="line">                    <span class="keyword">boolean</span> match = request.getMessageFilter().isMatchedByConsumeQueue(tagsCode,</span><br><span class="line">                        <span class="keyword">new</span> ConsumeQueueExt.CqExtUnit(tagsCode, msgStoreTime, filterBitMap));</span><br><span class="line">                    <span class="comment">// match by bit map, need eval again when properties is not null.</span></span><br><span class="line">                    <span class="keyword">if</span> (match &amp;&amp; properties != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        match = request.getMessageFilter().isMatchedByCommitLog(<span class="keyword">null</span>, properties);</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (match) &#123;</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            <span class="keyword">this</span>.brokerController.getPullMessageProcessor().executeRequestWhenWakeup(request.getClientChannel(),</span><br><span class="line">                                request.getRequestCommand());</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">                            log.error(<span class="string">&quot;execute request when wakeup failed.&quot;</span>, e);</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (System.currentTimeMillis() &gt;= (request.getSuspendTimestamp() + request.getTimeoutMillis())) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="keyword">this</span>.brokerController.getPullMessageProcessor().executeRequestWhenWakeup(request.getClientChannel(),</span><br><span class="line">                            request.getRequestCommand());</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">                        log.error(<span class="string">&quot;execute request when wakeup failed.&quot;</span>, e);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                replayList.add(request);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (!replayList.isEmpty()) &#123;</span><br><span class="line">                mpr.addPullRequest(replayList);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<div id="gitalk-container"></div>
<script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

		<script>
		var gitalkConfig = {"clientID":"26b8e6758f16d4524e69","clientSecret":"ecfd9e9a439bcb8a4c4fd21f4677fa102c68b352","repo":"beastmouth.github.io","owner":"beastmouth","admin":["beastmouth"],"distractionFreeMode":false,"createIssueManually":true};
	    gitalkConfig.id = md5(location.pathname);
		var gitalk = new Gitalk(gitalkConfig);
	    gitalk.render("gitalk-container");
	    </script>]]></content>
      <categories>
        <category>RocketMQ</category>
      </categories>
  </entry>
  <entry>
    <title>Synchronized关键字</title>
    <url>/2023/11/23/Synchronized%E5%85%B3%E9%94%AE%E5%AD%97/</url>
    <content><![CDATA[<h3 id="Synchronized关键字"><a href="#Synchronized关键字" class="headerlink" title="Synchronized关键字"></a>Synchronized关键字</h3><p>Synchronized实际上就是通过操作Java对象的对象监视器（内部锁），来实现锁的操作</p>
<ul>
<li><p>进入同步块时，线程必须先获得与对象关联的监视器。</p>
<ul>
<li>如果监视器未被其他线程占用，线程将成功获取监视器，并进入同步块执行。</li>
<li>如果监视器已被其他线程占用，线程将被阻塞，直到监视器被释放。</li>
</ul>
</li>
<li><p>退出同步块时，线程释放与对象关联的监视器。</p>
<ul>
<li>如果有其他线程在等待获取该监视器，其中之一将被唤醒，获得监视器，然后执行相应的同步块。</li>
</ul>
</li>
</ul>
<p>那么它是怎么实现的呢，在底层编译后的jvm指令中，我们会发现</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3: monitorenter                      // 获取Synchronized锁，进入同步代码块</span><br><span class="line">// 代码相关指令</span><br><span class="line">13: monitorexit                       // 释放Synchronized锁，退出同步代码块</span><br></pre></td></tr></table></figure>

<p>或者</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">synchronized void sayHelloHi();</span><br><span class="line">    descriptor: ()V</span><br><span class="line">    flags: ACC_SYNCHRONIZED                   // 用ACC_SYNCHRONIZED标识同步代码块</span><br></pre></td></tr></table></figure>

<p>来实现锁的操作</p>
<p>那么，对象监视器操作的是对象实例的对象头，来实现对对象打上锁的标记</p>
<h4 id="对象头内容"><a href="#对象头内容" class="headerlink" title="对象头内容"></a>对象头内容</h4><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://bb3e216f.onedrive-cf-index-ng-e34.pages.dev/api/raw?path=/Public/BlogImg/%E7%BA%BF%E7%A8%8B/%E5%AF%B9%E8%B1%A1%E5%A4%B4%E7%9A%84%E5%86%85%E5%AE%B9.png"
                      alt="对象头内容"
                ></p>
<h4 id="Synchronized底层原理-Linux管程模型"><a href="#Synchronized底层原理-Linux管程模型" class="headerlink" title="Synchronized底层原理-Linux管程模型"></a>Synchronized底层原理-Linux管程模型</h4><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://bb3e216f.onedrive-cf-index-ng-e34.pages.dev/api/raw?path=/Public/BlogImg/%E7%BA%BF%E7%A8%8B/Linux%E7%AE%A1%E7%A8%8B%E6%A8%A1%E5%9E%8B.png"
                      alt="Linux管程模型"
                ></p>
<p>synchronized基于管程模型。同步共享变量和入口等待队列来实现互斥，通过条件变量与条件变量等待队列实现通信。多线程竞争时，拿不到对象头monitor锁的线程便会被放到入口等待队列中。而获取到对象头monitor锁的线程则会进入临界区。此时同步代码块中存在条件变量判断是否进入wait方法时，满足条件变量则会继续执行，不满足条件变量的线程会被封装成ObjectWaiter放入条件等待队列中。待满足条件遍历的线程执行完毕时，会选择一个条件变量等待队列中的线程出队，唤醒线程进入临界区，与其他临界区的线程（入口等待队列）竞争<br>管程：进程间互斥（只有一个进程持有锁）使用管程</p>
<h4 id="JVM对Synchronized的优化"><a href="#JVM对Synchronized的优化" class="headerlink" title="JVM对Synchronized的优化"></a>JVM对Synchronized的优化</h4><h5 id="锁膨胀"><a href="#锁膨胀" class="headerlink" title="锁膨胀"></a>锁膨胀</h5><p>锁膨胀升级的方向：无锁 –&gt; 偏向锁  –&gt; 轻量级锁  –&gt; 重量级锁</p>
<h5 id="偏向锁"><a href="#偏向锁" class="headerlink" title="偏向锁"></a>偏向锁</h5><p>一句话总结它的作用：减少统一线程获取锁的代价。在大多数情况下，锁不存在多线程竞争，总是由同一线程多次获得，那么此时就是偏向锁。<br>核心思想：<br>如果一个线程获得了锁，那么锁就进入偏向模式，此时<code>Mark Word</code>的结构也就变为偏向锁结构，当该线程再次请求锁时，无需再做任何同步操作，即获取锁的过程只需要检查<code>Mark Word</code>的锁标记位为偏向锁以及当前线程ID等于<code>Mark Word</code>的ThreadID即可，这样就省去了大量有关锁申请的操作。</p>
<h5 id="轻量级锁"><a href="#轻量级锁" class="headerlink" title="轻量级锁"></a>轻量级锁</h5><p>轻量级锁是由偏向锁升级而来，当存在第二个线程申请同一个锁对象时，偏向锁就会立即升级为轻量级锁。<br>假如此时持有线程的锁没有释放，第二个线程便会在自旋等待（自旋锁）</p>
<p>轻量级锁向重量级锁升级过程<br>若当前只有一个等待线程，则该线程通过自旋进行等待。但是当自旋超过一定的次数，或者一个线程在持有锁，一个在自旋，又有第三个来访时，轻量级锁升级为重量级锁。</p>
<h5 id="重量级锁"><a href="#重量级锁" class="headerlink" title="重量级锁"></a>重量级锁</h5><p>重量级锁是由轻量级锁升级而来，当<strong>同一时间</strong>有多个线程竞争锁时，锁就会被升级成重量级锁，此时其申请锁带来的开销也就变大。<br>重量级锁一般使用场景会在追求吞吐量，同步块或者同步方法执行时间较长的场景。</p>
<h5 id="自旋锁和自适应自旋锁"><a href="#自旋锁和自适应自旋锁" class="headerlink" title="自旋锁和自适应自旋锁"></a>自旋锁和自适应自旋锁</h5><p>轻量级锁失败后，虚拟机为了避免线程真实地在操作系统层面挂起，还会进行一项称为自旋锁的优化手段。<br>自旋锁：许多情况下，共享数据的锁定状态持续时间较短，切换线程不值得，通过让线程执行循环等待锁的释放，不让出CPU。如果得到锁，就顺利进入临界区。如果还不能获得锁，那就会将线程在操作系统层面挂起，这就是自旋锁的优化方式。但是它也存在缺点：如果锁被其他线程长时间占用，一直不释放CPU，会带来许多的性能开销。<br><strong>自适应自旋锁</strong>：这种相当于是对上面自旋锁优化方式的进一步优化，它的自旋的次数不再固定，其自旋的次数由前一次在同一个锁上的自旋时间及锁的拥有者的状态来决定，这就解决了自旋锁带来的缺点。</p>
<p><strong>偏向锁通过对比Mark Word解决加锁问题，避免执行CAS操作。而轻量级锁是通过用CAS操作和自旋来解决加锁问题，避免线程阻塞和唤醒而影响性能。重量级锁是将除了拥有锁的线程以外的线程都阻塞。</strong></p>
<p><strong>synchronized 不可响应中断</strong></p>
<p>wait，notify，notifyall 配合synchronized使用</p>

<div id="gitalk-container"></div>
<script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

		<script>
		var gitalkConfig = {"clientID":"26b8e6758f16d4524e69","clientSecret":"ecfd9e9a439bcb8a4c4fd21f4677fa102c68b352","repo":"beastmouth.github.io","owner":"beastmouth","admin":["beastmouth"],"distractionFreeMode":false,"createIssueManually":true};
	    gitalkConfig.id = md5(location.pathname);
		var gitalk = new Gitalk(gitalkConfig);
	    gitalk.render("gitalk-container");
	    </script>]]></content>
      <categories>
        <category>多线程</category>
      </categories>
  </entry>
  <entry>
    <title>Update语句执行流程</title>
    <url>/2021/12/26/Update%E8%AF%AD%E5%8F%A5%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B/</url>
    <content><![CDATA[<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://bb3e216f.onedrive-cf-index-ng-e34.pages.dev/api/raw?path=/Public/BlogImg/MySQL/Update%E8%AF%AD%E5%8F%A5%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B%20%E6%B5%81%E7%A8%8B.png"
                      alt="Update语句执行流程 流程.jpg"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://bb3e216f.onedrive-cf-index-ng-e34.pages.dev/api/raw?path=/Public/BlogImg/MySQL/Update%E8%AF%AD%E5%8F%A5%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B%20%E5%8F%82%E8%80%83.png"
                      alt="Update语句执行流程 参考.png"
                ></p>
<p>先刷redo log盘，然后再删除redo log日志。（redo log刷盘操作是幂等的）</p>
<hr>
<!-- 20231009更新 -->

<h1 id="两阶段提交思想"><a href="#两阶段提交思想" class="headerlink" title="两阶段提交思想"></a>两阶段提交思想</h1><p>redo log</p>
<h1 id="刷脏页"><a href="#刷脏页" class="headerlink" title="刷脏页"></a>刷脏页</h1><p>我们的一条SQL语句，正常执行时速度特别快，但是有的时候不知道为什么，速度特别慢。</p>
<p>那么可能是因为MySQL在刷脏页导致的（flush）</p>
<h2 id="首先先介绍下什么是脏页"><a href="#首先先介绍下什么是脏页" class="headerlink" title="首先先介绍下什么是脏页"></a>首先先介绍下什么是脏页</h2><ul>
<li>脏页：内存数据页跟磁盘数据页内容不一致，我们就会称呼这个内存页为脏页</li>
<li>干净页：内存数据写入到磁盘后，内存和磁盘上的数据页的内容就一致了。</li>
</ul>
<h2 id="刷脏页的几种情况"><a href="#刷脏页的几种情况" class="headerlink" title="刷脏页的几种情况"></a>刷脏页的几种情况</h2><ul>
<li>redo log写满了，此时系统会停止所有更新操作，把checkpoint向前推进，redo log留出空间后才能继续写（redo log是个环形，会涉及到删除原有的内容）</li>
<li>需要记录的数据太多，内存页不够，需要淘汰一些数据页，空出内存给别的数据页使用。淘汰的是脏页的话，就要先将脏页写到磁盘中</li>
<li>MySQL认为系统空闲的时候，会刷脏页</li>
<li>MySQL正常关闭的时候，会刷脏页</li>
</ul>
<h1 id="MVCC（MySQL隔离性的保证）"><a href="#MVCC（MySQL隔离性的保证）" class="headerlink" title="MVCC（MySQL隔离性的保证）"></a>MVCC（MySQL隔离性的保证）</h1><p>相关概念</p>
<p>视图：InnoDB在实现MVCC时用到的一致性读视图（consistent read view，用于支持RC和RR隔离级别的实现），此处要与查询语句的虚拟表视图（view）区分</p>
<h2 id="多版本和row-trx-id"><a href="#多版本和row-trx-id" class="headerlink" title="多版本和row trx_id"></a>多版本和row trx_id</h2><p>为了保证可重复度，事务在启动时需要对数据库拍一个快照。但是对整个数据库的数据备份一份，无疑是一个很耗性能的工作。那么InnoDB是如何保证可重复度的呢？</p>
<p>基于版本号与undolog</p>
<p>InnoDB每个事务都有一个唯一的事务ID（transaction id），在事务启动时向InnoDB的事务系统申请的，根据申请顺序严格递增的</p>
<p>同时每行数据都是有多个版本的，每次事务更新的时候，都会生成一个新的数据版本，并把transaction id复制给这个数据版本的事务ID，记为 row trx_id。同时也会保存旧的数据版本</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://bb3e216f.onedrive-cf-index-ng-e34.pages.dev/api/raw?path=/Public/BlogImg/MySQL/Update%E8%AF%AD%E5%8F%A5%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B%20MVCC%E5%A4%9A%E7%89%88%E6%9C%AC.png"
                      alt="Update语句执行流程 MVCC多版本"
                ></p>
<p>U1,U2,U3就是对应的undo log，而V1,V2,V3并不是真是存在的。是根据当前版本和undo log计算出来的</p>
<p>同时，在查询数据的时候，就会以当前事务启动时的版本号为准，对记录进行查找，一直找到当前事务之前的版本号的数据为准</p>
<p>undolog何时删除？在系统中没有比这个回滚日志更早的read-view时，就会删除undolog</p>
<hr>
<p align="right">**2023/10/10更新**</p>



<h1 id="MySQL运行过程中Crash的该如何恢复"><a href="#MySQL运行过程中Crash的该如何恢复" class="headerlink" title="MySQL运行过程中Crash的该如何恢复"></a>MySQL运行过程中Crash的该如何恢复</h1><p>redo log里记录了数据页的修改以及change buffer新写入的信息<br>如果掉电,持久化的change buffer数据已经purge,不用恢复。主要分析没有持久化的数据<br>情况又分为以下几种:<br>(1)change buffer写入,redo log虽然做了fsync但未commit,binlog未fsync到磁盘,这部分数据丢失<br>(2)change buffer写入,redo log写入但没有commit,binlog以及fsync到磁盘,先从binlog恢复redo log,再从redo log恢复change buffer<br>(3)change buffer写入,redo log和binlog都已经fsync.那么直接从redo log里恢复。</p>
<h1 id="关于ChangeBuffer对更新时候的帮助"><a href="#关于ChangeBuffer对更新时候的帮助" class="headerlink" title="关于ChangeBuffer对更新时候的帮助"></a>关于ChangeBuffer对更新时候的帮助</h1><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- a为普通索引,b为普通索引</span></span><br><span class="line">update table_a <span class="keyword">set</span> a <span class="operator">=</span> <span class="number">1</span> <span class="keyword">where</span> b <span class="operator">=</span> <span class="number">2</span> <span class="keyword">and</span> version <span class="operator">=</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure>

<p>首先先明确下ChangeBuffer的作用<br>当需要更新一个数据页时，如果数据页在内存中就直接更新，而如果这个数据页还没有在内存中的话，在不影响数据一致性的前提下，InnoDB 会将这些更新操作缓存在 change buffer 中，这样就不需要从磁盘中读入这个数据页了。在下次查询需要访问这个数据页的时候，将数据页读入内存，然后执行 change buffer 中与这个页有关的操作。<br>由上面的这句话我们可以得出两个结论</p>
<ul>
<li>ChangeBuffer适用的场景: 非唯一索引变更</li>
<li>ChangeBuffer的优点: 减少对索引页的随机读, 提高修改数据的效率</li>
</ul>
<p>那么我们结合前面的执行流程图和ChangeBuffer，分析下刚刚上面的那个sql, 它在执行的时候分别做了哪些事情?</p>
<ul>
<li>查找索引b, 获取对应的主键id列表</li>
<li>回表, 加载对应数据所在的数据页到内存中</li>
<li>修改内存中的数据</li>
<li>对索引a的修改，记录到change buffer中</li>
<li>redo log prepare状态</li>
<li>binlog</li>
<li>redo log commit状态</li>
<li>返回成功</li>
</ul>
<h2 id="关于binlog是否完整如何判断"><a href="#关于binlog是否完整如何判断" class="headerlink" title="关于binlog是否完整如何判断"></a>关于binlog是否完整如何判断</h2><ul>
<li>statement 格式的 binlog，最后会有 COMMIT；</li>
<li>row 格式的 binlog，最后会有一个 XID event。</li>
</ul>
<h2 id="为什么prepare阶段的redo-log加上完整的binlog事务就可以提交"><a href="#为什么prepare阶段的redo-log加上完整的binlog事务就可以提交" class="headerlink" title="为什么prepare阶段的redo log加上完整的binlog事务就可以提交"></a>为什么prepare阶段的redo log加上完整的binlog事务就可以提交</h2><p>加入binlog写完之后，MySQL发生崩溃，此时binlog已经写入，后面从库包括我们恢复这个奔溃的MySQL都会使用到这个binlog，所以此时奔溃的主库也要提交事务</p>
<h2 id="关于写-redolog"><a href="#关于写-redolog" class="headerlink" title="关于写 redolog"></a>关于写 redolog</h2><p>此时MySQL会用到redolog buffer。在插入数据的过程中，生成的日志会先写入到redolog buffer中，等待commit语句执行时redolog buffer才会刷盘</p>

<div id="gitalk-container"></div>
<script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

		<script>
		var gitalkConfig = {"clientID":"26b8e6758f16d4524e69","clientSecret":"ecfd9e9a439bcb8a4c4fd21f4677fa102c68b352","repo":"beastmouth.github.io","owner":"beastmouth","admin":["beastmouth"],"distractionFreeMode":false,"createIssueManually":true};
	    gitalkConfig.id = md5(location.pathname);
		var gitalk = new Gitalk(gitalkConfig);
	    gitalk.render("gitalk-container");
	    </script>]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
  </entry>
  <entry>
    <title>next-keylock备忘</title>
    <url>/2023/10/24/next-keylock%E5%A4%87%E5%BF%98/</url>
    <content><![CDATA[<h1 id="名词解释"><a href="#名词解释" class="headerlink" title="名词解释"></a>名词解释</h1><p>解释: 间隙锁(Gap Lock)和行锁合称 NextKey Lock 【前开后闭的区间】<br>间隙锁存在的场景和原因: 当为可重复读的时候，就会用到间隙锁，用来解决幻读问题</p>
<h1 id="加锁规则"><a href="#加锁规则" class="headerlink" title="加锁规则"></a>加锁规则</h1><ul>
<li>原则 1：加锁的基本单位是 next-key lock。希望你还记得，next-key lock 是前开后闭区间。</li>
<li>原则 2：查找过程中访问到的对象才会加锁。</li>
<li>优化 1：索引上的等值查询，给唯一索引加锁的时候，next-key lock 退化为行锁。</li>
<li>优化 2：索引上的等值查询，向右遍历时且最后一个值不满足等值条件的时候，next-key lock 退化为间隙锁。</li>
<li>一个 bug：唯一索引上的范围查询会访问到不满足条件的第一个值为止。</li>
</ul>
<p>同时，有一个注意点。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- mysql会认为查询完接下来就要更新数据，会顺便给主键索引满足条件的行上锁</span></span><br><span class="line"><span class="keyword">select</span> ... <span class="keyword">for</span> update;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 仅对当前索引上锁</span></span><br><span class="line"><span class="keyword">select</span> ... lock <span class="keyword">in</span> share mode;</span><br></pre></td></tr></table></figure>

<div id="gitalk-container"></div>
<script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

		<script>
		var gitalkConfig = {"clientID":"26b8e6758f16d4524e69","clientSecret":"ecfd9e9a439bcb8a4c4fd21f4677fa102c68b352","repo":"beastmouth.github.io","owner":"beastmouth","admin":["beastmouth"],"distractionFreeMode":false,"createIssueManually":true};
	    gitalkConfig.id = md5(location.pathname);
		var gitalk = new Gitalk(gitalkConfig);
	    gitalk.render("gitalk-container");
	    </script>]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
  </entry>
  <entry>
    <title>三级缓存解决循环依赖</title>
    <url>/2023/10/07/%E4%B8%89%E7%BA%A7%E7%BC%93%E5%AD%98%E8%A7%A3%E5%86%B3%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96/</url>
    <content><![CDATA[<h1 id="大致流程图概览"><a href="#大致流程图概览" class="headerlink" title="大致流程图概览"></a>大致流程图概览</h1><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://bb3e216f.onedrive-cf-index-ng-e34.pages.dev/api/raw?path=/Public/BlogImg/Spring/SpringBean%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96.jpg"
                      alt="SpringBean循环依赖.jpg"
                ></p>
<p>为什么需要第三级缓存：考虑到AOP代理的情况，否则就会有在放入二级缓存的时候同时要把代理类的生成</p>
<p>而二级缓存存在的必要就是为了性能，从三级缓存的工厂里创建出对象，再扔到二级缓存（这样就不用每次都要从工厂里拿）</p>
<ul>
<li>第二级缓存考虑性能</li>
<li>第三季缓存考虑代理</li>
</ul>
<h1 id="三级缓存各自作用"><a href="#三级缓存各自作用" class="headerlink" title="三级缓存各自作用"></a>三级缓存各自作用</h1><table>
<thead>
<tr>
<th>缓存层级</th>
<th>名称</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>一级缓存</td>
<td>singletonObjects</td>
<td>单例对象缓存池，存放的 Bean 已经实例化、属性赋值、完全初始化好（成品）</td>
</tr>
<tr>
<td>二级缓存</td>
<td>earlySingletonObjects</td>
<td>早期单例对象缓存池，存放的 Bean 已经实例化但尚未属性赋值、未执行 init 方法（半成品）</td>
</tr>
<tr>
<td>三级缓存</td>
<td>singletonFactories</td>
<td>单例工厂的缓存</td>
</tr>
</tbody></table>
<h1 id="核心代码逻辑"><a href="#核心代码逻辑" class="headerlink" title="核心代码逻辑"></a>核心代码逻辑</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Create bean instance.</span></span><br><span class="line"><span class="keyword">if</span> (mbd.isSingleton()) &#123;</span><br><span class="line">    <span class="comment">// 获取单例对象</span></span><br><span class="line">    sharedInstance = getSingleton(beanName, () -&gt; &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 创建bean</span></span><br><span class="line">            <span class="keyword">return</span> createBean(beanName, mbd, args);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (BeansException ex) &#123;</span><br><span class="line">            <span class="comment">// Explicitly remove instance from singleton cache: It might have been put there</span></span><br><span class="line">            <span class="comment">// eagerly by the creation process, to allow for circular reference resolution.</span></span><br><span class="line">            <span class="comment">// Also remove any beans that received a temporary reference to the bean.</span></span><br><span class="line">            destroySingleton(beanName);</span><br><span class="line">            <span class="keyword">throw</span> ex;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    bean = getObjectForBeanInstance(sharedInstance, name, beanName, mbd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// getSingleton最终调用到addSingleton</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">addSingleton</span><span class="params">(String beanName, Object singletonObject)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>.singletonObjects) &#123;</span><br><span class="line">        <span class="comment">// bean实例化并填充属性等完成, 放入一级缓存</span></span><br><span class="line">        <span class="keyword">this</span>.singletonObjects.put(beanName, singletonObject);</span><br><span class="line">        <span class="keyword">this</span>.singletonFactories.remove(beanName);</span><br><span class="line">        <span class="keyword">this</span>.earlySingletonObjects.remove(beanName);</span><br><span class="line">        <span class="keyword">this</span>.registeredSingletons.add(beanName);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// createBean最终调用到doCreateBean</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">doCreateBean</span><span class="params">(<span class="keyword">final</span> String beanName, <span class="keyword">final</span> RootBeanDefinition mbd, <span class="keyword">final</span> <span class="meta">@Nullable</span> Object[] args)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> BeanCreationException </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Instantiate the bean.</span></span><br><span class="line">    BeanWrapper instanceWrapper = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (mbd.isSingleton()) &#123;</span><br><span class="line">        instanceWrapper = <span class="keyword">this</span>.factoryBeanInstanceCache.remove(beanName);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (instanceWrapper == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 创建bean实例</span></span><br><span class="line">        instanceWrapper = createBeanInstance(beanName, mbd, args);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">final</span> Object bean = instanceWrapper.getWrappedInstance();</span><br><span class="line">    Class&lt;?&gt; beanType = instanceWrapper.getWrappedClass();</span><br><span class="line">    <span class="keyword">if</span> (beanType != NullBean.class) &#123;</span><br><span class="line">        mbd.resolvedTargetType = beanType;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Allow post-processors to modify the merged bean definition.</span></span><br><span class="line">    <span class="keyword">synchronized</span> (mbd.postProcessingLock) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!mbd.postProcessed) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                applyMergedBeanDefinitionPostProcessors(mbd, beanType, beanName);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(mbd.getResourceDescription(), beanName,</span><br><span class="line">                        <span class="string">&quot;Post-processing of merged bean definition failed&quot;</span>, ex);</span><br><span class="line">            &#125;</span><br><span class="line">            mbd.postProcessed = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Eagerly cache singletons to be able to resolve circular references</span></span><br><span class="line">    <span class="comment">// even when triggered by lifecycle interfaces like BeanFactoryAware.</span></span><br><span class="line">    <span class="keyword">boolean</span> earlySingletonExposure = (mbd.isSingleton() &amp;&amp; <span class="keyword">this</span>.allowCircularReferences &amp;&amp;</span><br><span class="line">            isSingletonCurrentlyInCreation(beanName));</span><br><span class="line">    <span class="keyword">if</span> (earlySingletonExposure) &#123;</span><br><span class="line">        <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">            logger.debug(<span class="string">&quot;Eagerly caching bean &#x27;&quot;</span> + beanName +</span><br><span class="line">                    <span class="string">&quot;&#x27; to allow for resolving potential circular references&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 添加到三级缓存中</span></span><br><span class="line">        <span class="comment">// 其中getEarlyBeanReference的方法, 会进行动态代理的处理</span></span><br><span class="line">        addSingletonFactory(beanName, () -&gt; getEarlyBeanReference(beanName, mbd, bean));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Initialize the bean instance.</span></span><br><span class="line">    Object exposedObject = bean;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 填充属性 此处会注入其他bean</span></span><br><span class="line">        populateBean(beanName, mbd, instanceWrapper);</span><br><span class="line">        <span class="comment">// 执行一些init方法</span></span><br><span class="line">        exposedObject = initializeBean(beanName, exposedObject, mbd);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">        <span class="keyword">if</span> (ex <span class="keyword">instanceof</span> BeanCreationException &amp;&amp; beanName.equals(((BeanCreationException) ex).getBeanName())) &#123;</span><br><span class="line">            <span class="keyword">throw</span> (BeanCreationException) ex;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(</span><br><span class="line">                    mbd.getResourceDescription(), beanName, <span class="string">&quot;Initialization of bean failed&quot;</span>, ex);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (earlySingletonExposure) &#123;</span><br><span class="line">        <span class="comment">// 添加到二级缓存</span></span><br><span class="line">        Object earlySingletonReference = getSingleton(beanName, <span class="keyword">false</span>);</span><br><span class="line">        <span class="keyword">if</span> (earlySingletonReference != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (exposedObject == bean) &#123;</span><br><span class="line">                exposedObject = earlySingletonReference;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (!<span class="keyword">this</span>.allowRawInjectionDespiteWrapping &amp;&amp; hasDependentBean(beanName)) &#123;</span><br><span class="line">                String[] dependentBeans = getDependentBeans(beanName);</span><br><span class="line">                Set&lt;String&gt; actualDependentBeans = <span class="keyword">new</span> LinkedHashSet&lt;&gt;(dependentBeans.length);</span><br><span class="line">                <span class="keyword">for</span> (String dependentBean : dependentBeans) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (!removeSingletonIfCreatedForTypeCheckOnly(dependentBean)) &#123;</span><br><span class="line">                        actualDependentBeans.add(dependentBean);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (!actualDependentBeans.isEmpty()) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> BeanCurrentlyInCreationException(beanName,</span><br><span class="line">                            <span class="string">&quot;Bean with name &#x27;&quot;</span> + beanName + <span class="string">&quot;&#x27; has been injected into other beans [&quot;</span> +</span><br><span class="line">                            StringUtils.collectionToCommaDelimitedString(actualDependentBeans) +</span><br><span class="line">                            <span class="string">&quot;] in its raw version as part of a circular reference, but has eventually been &quot;</span> +</span><br><span class="line">                            <span class="string">&quot;wrapped. This means that said other beans do not use the final version of the &quot;</span> +</span><br><span class="line">                            <span class="string">&quot;bean. This is often the result of over-eager type matching - consider using &quot;</span> +</span><br><span class="line">                            <span class="string">&quot;&#x27;getBeanNamesOfType&#x27; with the &#x27;allowEagerInit&#x27; flag turned off, for example.&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Register bean as disposable.</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        registerDisposableBeanIfNecessary(beanName, bean, mbd);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (BeanDefinitionValidationException ex) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(</span><br><span class="line">                mbd.getResourceDescription(), beanName, <span class="string">&quot;Invalid destruction signature&quot;</span>, ex);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> exposedObject;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">getSingleton</span><span class="params">(String beanName, <span class="keyword">boolean</span> allowEarlyReference)</span> </span>&#123;</span><br><span class="line">    Object singletonObject = <span class="keyword">this</span>.singletonObjects.get(beanName);</span><br><span class="line">    <span class="keyword">if</span> (singletonObject == <span class="keyword">null</span> &amp;&amp; isSingletonCurrentlyInCreation(beanName)) &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>.singletonObjects) &#123;</span><br><span class="line">            singletonObject = <span class="keyword">this</span>.earlySingletonObjects.get(beanName);</span><br><span class="line">            <span class="keyword">if</span> (singletonObject == <span class="keyword">null</span> &amp;&amp; allowEarlyReference) &#123;</span><br><span class="line">                ObjectFactory&lt;?&gt; singletonFactory = <span class="keyword">this</span>.singletonFactories.get(beanName);</span><br><span class="line">                <span class="keyword">if</span> (singletonFactory != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    singletonObject = singletonFactory.getObject();</span><br><span class="line">                    <span class="keyword">this</span>.earlySingletonObjects.put(beanName, singletonObject);</span><br><span class="line">                    <span class="keyword">this</span>.singletonFactories.remove(beanName);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> singletonObject;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="三级缓存解决循环依赖细节"><a href="#三级缓存解决循环依赖细节" class="headerlink" title="三级缓存解决循环依赖细节"></a>三级缓存解决循环依赖细节</h1><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://bb3e216f.onedrive-cf-index-ng-e34.pages.dev/api/raw?path=/Public/BlogImg/Spring/%E4%B8%89%E7%BA%A7%E7%BC%93%E5%AD%98%20%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96.jpg"
                      alt="三级缓存 循环依赖.jpg"
                ></p>

<div id="gitalk-container"></div>
<script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

		<script>
		var gitalkConfig = {"clientID":"26b8e6758f16d4524e69","clientSecret":"ecfd9e9a439bcb8a4c4fd21f4677fa102c68b352","repo":"beastmouth.github.io","owner":"beastmouth","admin":["beastmouth"],"distractionFreeMode":false,"createIssueManually":true};
	    gitalkConfig.id = md5(location.pathname);
		var gitalk = new Gitalk(gitalkConfig);
	    gitalk.render("gitalk-container");
	    </script>]]></content>
      <categories>
        <category>Spring</category>
      </categories>
  </entry>
  <entry>
    <title>从ReentrantLock看AQS</title>
    <url>/2022/03/19/%E4%BB%8EReentrantLock%E7%9C%8BAQS/</url>
    <content><![CDATA[<h1 id="从ReentrantLock看AQS"><a href="#从ReentrantLock看AQS" class="headerlink" title="从ReentrantLock看AQS"></a>从ReentrantLock看AQS</h1><h2 id="AQS的三个核心点"><a href="#AQS的三个核心点" class="headerlink" title="AQS的三个核心点"></a>AQS的三个核心点</h2><ul>
<li>state</li>
<li>协作类实现的获取锁/释放锁的方法</li>
<li>FIFO队列</li>
</ul>
<h2 id="关于state"><a href="#关于state" class="headerlink" title="关于state"></a>关于state</h2><p><code>state</code>是用来判断是否有线程占用当前锁，与另一个参数<code>exclusiveOwnerThread</code> 配合使用</p>
<p>以ReentrantLock获取锁为例</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * ReentrantLock 获取非公平锁的代码</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">NonfairSync</span> <span class="keyword">extends</span> <span class="title">Sync</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">7316153563782823691L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Performs lock.  Try immediate barge, backing up to normal</span></span><br><span class="line"><span class="comment">     * acquire on failure.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">				<span class="comment">// 设置state =&gt; 从0到1 [即占有锁]</span></span><br><span class="line">        <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, <span class="number">1</span>))</span><br><span class="line">						<span class="comment">// 成功 =&gt; 将占用的线程改成当前线程</span></span><br><span class="line">            setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">						<span class="comment">// 设置失败，说明当前的锁被其他线程占用，尝试获取锁 [见下一段代码]</span></span><br><span class="line">            acquire(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> nonfairTryAcquire(acquires);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="关于协作类实现的释放锁-获取锁的方法"><a href="#关于协作类实现的释放锁-获取锁的方法" class="headerlink" title="关于协作类实现的释放锁/获取锁的方法"></a>关于协作类实现的释放锁/获取锁的方法</h2><p>以上面的例子为例，当线程要获取的锁被其他线程占用的时候，就需要我们去自定一个获取锁的逻辑</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// tryAcquire 就是协作类自定义的获取锁的逻辑</span></span><br><span class="line">    <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">				<span class="comment">// 获取失败，统一交给AQS管理（添加等待节点，放入队列中，将当前线程挂起）-这套属于固有的逻辑，不需要协作类去实现（实现成本高，且属于重复代码）</span></span><br><span class="line">        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">        selfInterrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>那么来重点看看 <code>tryAcquire</code> 方法 （接着以非公平锁为例）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> nonfairTryAcquire(acquires);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">nonfairTryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Thread current = Thread.currentThread();</span><br><span class="line">		<span class="comment">// 再次获取一下state</span></span><br><span class="line">    <span class="keyword">int</span> c = getState();</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">				<span class="comment">// 说明锁被释放，再次cas设置state</span></span><br><span class="line">        <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">            setExclusiveOwnerThread(current);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">		<span class="comment">// 如果持有锁的线程是当前线索，state+1（可重入）</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">        <span class="keyword">int</span> nextc = c + acquires;</span><br><span class="line">        <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>) <span class="comment">// overflow</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">&quot;Maximum lock count exceeded&quot;</span>);</span><br><span class="line">        setState(nextc);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>再次尝试，获取的到锁还好说。假如获取不到锁，就需要用到了刚刚提到的FIFO队列</p>
<h2 id="AQS核心内容-FIFO队列及入队出队规则-入队"><a href="#AQS核心内容-FIFO队列及入队出队规则-入队" class="headerlink" title="AQS核心内容 FIFO队列及入队出队规则-入队"></a>AQS核心内容 FIFO队列及入队出队规则-入队</h2><p>此处结合着我们刚刚将的流程来，不单独针对各个点做叙述</p>
<p>单独再将这块代码拿出来</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">		<span class="comment">// 获取失败，统一交给AQS管理（添加等待节点，放入队列中，将当前线程挂起）-这套属于固有的逻辑，不需要协作类去实现（实现成本高，且属于重复代码）</span></span><br><span class="line">    acquireQueued(addWaiter(Node.EXCLUSIVE), arg)) <span class="comment">// 具体见下段代码</span></span><br><span class="line">    selfInterrupt();</span><br></pre></td></tr></table></figure>

<h3 id="添加等待节点"><a href="#添加等待节点" class="headerlink" title="添加等待节点"></a>添加等待节点</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">addWaiter</span><span class="params">(Node mode)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// 新建一个节点对象</span></span><br><span class="line">    Node node = <span class="keyword">new</span> Node(Thread.currentThread(), mode);</span><br><span class="line">    <span class="comment">// Try the fast path of enq; backup to full enq on failure</span></span><br><span class="line">    Node pred = tail;</span><br><span class="line">		<span class="comment">// 已经有等待节点的情况</span></span><br><span class="line">    <span class="keyword">if</span> (pred != <span class="keyword">null</span>) &#123;</span><br><span class="line">        node.prev = pred;</span><br><span class="line">				<span class="comment">// CAS将当前节点设置为尾节点[链表添加尾节点]</span></span><br><span class="line">        <span class="keyword">if</span> (compareAndSetTail(pred, node)) &#123;</span><br><span class="line">            pred.next = node;</span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">		<span class="comment">// 入队（此处是没有等待节点的情况）</span></span><br><span class="line">    enq(node);</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 关于上面代码的一段思考：如果同时多个线程进入，会不会有并发问题？</span></span><br><span class="line"><span class="comment">// ===&gt; 不会，有一个线程会cas操作成功设置，其它cas失败的线程会执行enq的方法入队</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// CAS操作</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">compareAndSetTail</span><span class="params">(Node expect, Node update)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> unsafe.compareAndSwapObject(<span class="keyword">this</span>, tailOffset, expect, update);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">enq</span><span class="params">(<span class="keyword">final</span> Node node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        Node t = tail;</span><br><span class="line">        <span class="keyword">if</span> (t == <span class="keyword">null</span>) &#123; <span class="comment">// Must initialize</span></span><br><span class="line">						<span class="comment">// 新建一个节点，并将其设置成头节点。并将尾节点也指向这个新建的头节点</span></span><br><span class="line">            <span class="keyword">if</span> (compareAndSetHead(<span class="keyword">new</span> Node()))</span><br><span class="line">                tail = head;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            node.prev = t;</span><br><span class="line">						<span class="comment">// 再将我们具体的节点入队，并将具体的节点设置为尾节点</span></span><br><span class="line">            <span class="keyword">if</span> (compareAndSetTail(t, node)) &#123;</span><br><span class="line">                t.next = node;</span><br><span class="line">                <span class="keyword">return</span> t;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="尝试让队列中的头节点获取锁"><a href="#尝试让队列中的头节点获取锁" class="headerlink" title="尝试让队列中的头节点获取锁"></a>尝试让队列中的头节点获取锁</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">acquireQueued</span><span class="params">(<span class="keyword">final</span> Node node, <span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">boolean</span> interrupted = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">						<span class="comment">// 获取当前节点的前置节点</span></span><br><span class="line">            <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">						<span class="comment">// 前置节点是head，说明当前节点是第一个等待锁的节点（此时也会让当前节点再次去尝试获取锁 即tryAcquire方法）</span></span><br><span class="line">            <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">								<span class="comment">// 获取锁成功的处理</span></span><br><span class="line">                setHead(node);</span><br><span class="line">                p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                failed = <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">return</span> interrupted;</span><br><span class="line">            &#125;</span><br><span class="line">						<span class="comment">// 获取锁失败的处理 shouldParkAfterFailedAcquire （这个方法一会单独讲）</span></span><br><span class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">										<span class="comment">// 挂起当前线程</span></span><br><span class="line">                		parkAndCheckInterrupt())</span><br><span class="line">                interrupted = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">				<span class="comment">// 响应中断</span></span><br><span class="line">        <span class="keyword">if</span> (failed)</span><br><span class="line">						<span class="comment">// 撤销尝试获取锁（这个也一会在再讲）</span></span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>是否要挂起当获取锁失败方法解析 <code>shouldParkAfterFailedAcquire</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">shouldParkAfterFailedAcquire</span><span class="params">(Node pred, Node node)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// 前缀节点的等待状态</span></span><br><span class="line">	  <span class="keyword">int</span> ws = pred.waitStatus;</span><br><span class="line">	  <span class="keyword">if</span> (ws == Node.SIGNAL)</span><br><span class="line">	      <span class="comment">/*</span></span><br><span class="line"><span class="comment">	       * This node has already set status asking a release</span></span><br><span class="line"><span class="comment">	       * to signal it, so it can safely park.</span></span><br><span class="line"><span class="comment">	       */</span></span><br><span class="line">				<span class="comment">// 前面有节点已经做好被唤醒的准备，就等资源释放，去获取锁，当前节点可以被挂起</span></span><br><span class="line">	      <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">	  <span class="keyword">if</span> (ws &gt; <span class="number">0</span>) &#123;</span><br><span class="line">	      <span class="comment">/*</span></span><br><span class="line"><span class="comment">	       * Predecessor was cancelled. Skip over predecessors and</span></span><br><span class="line"><span class="comment">	       * indicate retry.</span></span><br><span class="line"><span class="comment">	       */</span></span><br><span class="line">				<span class="comment">// 说明是个从尾到头的查找过程</span></span><br><span class="line">	      <span class="keyword">do</span> &#123;</span><br><span class="line">	          node.prev = pred = pred.prev;</span><br><span class="line">						<span class="comment">// &gt;0 说明前置节点已经被取消，可以直接删除</span></span><br><span class="line">	      &#125; <span class="keyword">while</span> (pred.waitStatus &gt; <span class="number">0</span>);</span><br><span class="line">	      pred.next = node;</span><br><span class="line">	  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">	      <span class="comment">/*</span></span><br><span class="line"><span class="comment">	       * waitStatus must be 0 or PROPAGATE.  Indicate that we</span></span><br><span class="line"><span class="comment">	       * need a signal, but don&#x27;t park yet.  Caller will need to</span></span><br><span class="line"><span class="comment">	       * retry to make sure it cannot acquire before parking.</span></span><br><span class="line"><span class="comment">	       */</span></span><br><span class="line">				<span class="comment">// 将前置节点设置为SIGNAL的状态，先入队的线程先被唤醒</span></span><br><span class="line">	      compareAndSetWaitStatus(pred, ws, Node.SIGNAL);</span><br><span class="line">	  &#125;</span><br><span class="line">	  <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此处放一个WaitStatus枚举的状态表</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** waitStatus value to indicate thread has cancelled */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CANCELLED =  <span class="number">1</span>;</span><br><span class="line"><span class="comment">/** waitStatus value to indicate successor&#x27;s thread needs unparking */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SIGNAL    = -<span class="number">1</span>;</span><br><span class="line"><span class="comment">/** waitStatus value to indicate thread is waiting on condition */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CONDITION = -<span class="number">2</span>;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * waitStatus value to indicate the next acquireShared should</span></span><br><span class="line"><span class="comment"> * unconditionally propagate</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> PROPAGATE = -<span class="number">3</span>;</span><br></pre></td></tr></table></figure>

<p>WaitStatus枚举含义</p>
<table>
<thead>
<tr>
<th>SATUS</th>
<th>当一个Node被初始化的时候的默认值</th>
</tr>
</thead>
<tbody><tr>
<td>CANCELLED</td>
<td>为1，表示线程获取锁的请求已经取消了</td>
</tr>
<tr>
<td>CONDITION</td>
<td>为-2，表示节点在等待队列中，节点线程等待唤醒</td>
</tr>
<tr>
<td>PROPAGATE</td>
<td>为-3，当前线程处在SHARED情况下，该字段才会使用</td>
</tr>
<tr>
<td>SIGNAL</td>
<td>为-1，表示线程已经准备好了，就等资源释放了</td>
</tr>
</tbody></table>
<p>释放锁的代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    sync.release(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">release</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// 尝试释放锁</span></span><br><span class="line">    <span class="keyword">if</span> (tryRelease(arg)) &#123;</span><br><span class="line">        Node h = head;</span><br><span class="line">				<span class="comment">// 如果有等待节点，尝试唤醒（即使创建的临时节点，也会在实际入队的过程中将临时节点改成SIGNAL状态）</span></span><br><span class="line">        <span class="keyword">if</span> (h != <span class="keyword">null</span> &amp;&amp; h.waitStatus != <span class="number">0</span>)</span><br><span class="line">						<span class="comment">// 唤醒</span></span><br><span class="line">            unparkSuccessor(h);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>tryRelease</code> 释放锁</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">int</span> releases)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// state - release 重入次数 - 释放次数</span></span><br><span class="line">    <span class="keyword">int</span> c = getState() - releases;</span><br><span class="line">    <span class="keyword">if</span> (Thread.currentThread() != getExclusiveOwnerThread()) <span class="comment">// 当前线程不为持有锁的线程</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</span><br><span class="line">    <span class="keyword">boolean</span> free = <span class="keyword">false</span>;</span><br><span class="line">		<span class="comment">// state = 0，代表释放锁</span></span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">        free = <span class="keyword">true</span>;</span><br><span class="line">      	<span class="comment">// 全部释放</span></span><br><span class="line">        setExclusiveOwnerThread(<span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    setState(c);</span><br><span class="line">    <span class="keyword">return</span> free;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="AQS核心内容-FIFO队列及入队出队规则-出队"><a href="#AQS核心内容-FIFO队列及入队出队规则-出队" class="headerlink" title="AQS核心内容 FIFO队列及入队出队规则-出队"></a>AQS核心内容 FIFO队列及入队出队规则-出队</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">unparkSuccessor</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * If status is negative (i.e., possibly needing signal) try</span></span><br><span class="line"><span class="comment">     * to clear in anticipation of signalling.  It is OK if this</span></span><br><span class="line"><span class="comment">     * fails or if status is changed by waiting thread.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">int</span> ws = node.waitStatus;</span><br><span class="line">    <span class="keyword">if</span> (ws &lt; <span class="number">0</span>)</span><br><span class="line">				<span class="comment">// 头节点&lt;0，设置为初始状态 （小于0可能是非虚拟节点作为头节点的情况）</span></span><br><span class="line">        compareAndSetWaitStatus(node, ws, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Thread to unpark is held in successor, which is normally</span></span><br><span class="line"><span class="comment">     * just the next node.  But if cancelled or apparently null,</span></span><br><span class="line"><span class="comment">     * traverse backwards from tail to find the actual</span></span><br><span class="line"><span class="comment">     * non-cancelled successor.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Node s = node.next;</span><br><span class="line">    <span class="keyword">if</span> (s == <span class="keyword">null</span> || s.waitStatus &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        s = <span class="keyword">null</span>;</span><br><span class="line">				<span class="comment">// 从后往前找，找到最前面的可以被唤醒的节点（此处不做无效节点的删除，删除的操作在入队的时候做）</span></span><br><span class="line">				<span class="comment">// 猜测：此处也是从后往前找的原因估计是为了不和入队时候删除的代码冲突</span></span><br><span class="line">        <span class="keyword">for</span> (Node t = tail; t != <span class="keyword">null</span> &amp;&amp; t != node; t = t.prev)</span><br><span class="line">            <span class="keyword">if</span> (t.waitStatus &lt;= <span class="number">0</span>)</span><br><span class="line">                s = t;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (s != <span class="keyword">null</span>)</span><br><span class="line">				<span class="comment">// 唤醒节点，再走入刚刚的acquireQueued方法</span></span><br><span class="line">        LockSupport.unpark(s.thread);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>加锁失败撤销等待节点 <code>cancelAcquire</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">cancelAcquire</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Ignore if node doesn&#x27;t exist</span></span><br><span class="line">    <span class="keyword">if</span> (node == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    node.thread = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Skip cancelled predecessors</span></span><br><span class="line">    Node pred = node.prev;</span><br><span class="line">    <span class="keyword">while</span> (pred.waitStatus &gt; <span class="number">0</span>)</span><br><span class="line">				<span class="comment">// 删除前面取消的节点</span></span><br><span class="line">        node.prev = pred = pred.prev;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// predNext is the apparent node to unsplice. CASes below will</span></span><br><span class="line">    <span class="comment">// fail if not, in which case, we lost race vs another cancel</span></span><br><span class="line">    <span class="comment">// or signal, so no further action is necessary.</span></span><br><span class="line">    Node predNext = pred.next;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Can use unconditional write instead of CAS here.</span></span><br><span class="line">    <span class="comment">// After this atomic step, other Nodes can skip past us.</span></span><br><span class="line">    <span class="comment">// Before, we are free of interference from other threads.</span></span><br><span class="line">    node.waitStatus = Node.CANCELLED;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If we are the tail, remove ourselves.</span></span><br><span class="line">    <span class="keyword">if</span> (node == tail &amp;&amp; compareAndSetTail(node, pred)) &#123;</span><br><span class="line">				<span class="comment">// 尾节点，直接删除当前</span></span><br><span class="line">        compareAndSetNext(pred, predNext, <span class="keyword">null</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// If successor needs signal, try to set pred&#x27;s next-link</span></span><br><span class="line">        <span class="comment">// so it will get one. Otherwise wake it up to propagate.</span></span><br><span class="line">        <span class="keyword">int</span> ws;</span><br><span class="line">        <span class="keyword">if</span> (pred != head &amp;&amp;</span><br><span class="line">            ((ws = pred.waitStatus) == Node.SIGNAL ||</span><br><span class="line">             (ws &lt;= <span class="number">0</span> &amp;&amp; compareAndSetWaitStatus(pred, ws, Node.SIGNAL))) &amp;&amp;</span><br><span class="line">            pred.thread != <span class="keyword">null</span>) &#123;</span><br><span class="line">						<span class="comment">// 找到前一个被唤醒的节点</span></span><br><span class="line">            Node next = node.next;</span><br><span class="line">						<span class="comment">// 如果当前节点的下一个节点是符合被唤醒的条件，</span></span><br><span class="line">						<span class="comment">// 将前一个符合被唤醒的节点的下一个节点设置为当前节点的下一个节点</span></span><br><span class="line">            <span class="keyword">if</span> (next != <span class="keyword">null</span> &amp;&amp; next.waitStatus &lt;= <span class="number">0</span>)</span><br><span class="line">                compareAndSetNext(pred, predNext, next);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            unparkSuccessor(node);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        node.next = node; <span class="comment">// help GC</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="一个问题"><a href="#一个问题" class="headerlink" title="一个问题"></a>一个问题</h2><p>关于刚刚为什么要从尾节点往前找去添加节点</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 尝试获取锁的入队操作</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">shouldParkAfterFailedAcquire</span><span class="params">(Node pred, Node node)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> ws = pred.waitStatus;</span><br><span class="line">  <span class="keyword">if</span> (ws == Node.SIGNAL)</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * This node has already set status asking a release</span></span><br><span class="line"><span class="comment">     * to signal it, so it can safely park.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">  <span class="keyword">if</span> (ws &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Predecessor was cancelled. Skip over predecessors and</span></span><br><span class="line"><span class="comment">     * indicate retry.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">      <span class="comment">// 删除cancel的节点(先建立后面指向前面的指针，再建立前面到后面的指针)</span></span><br><span class="line">      node.prev = pred = pred.prev;</span><br><span class="line">    &#125; <span class="keyword">while</span> (pred.waitStatus &gt; <span class="number">0</span>);</span><br><span class="line">    pred.next = node;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * waitStatus must be 0 or PROPAGATE.  Indicate that we</span></span><br><span class="line"><span class="comment">     * need a signal, but don&#x27;t park yet.  Caller will need to</span></span><br><span class="line"><span class="comment">     * retry to make sure it cannot acquire before parking.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    compareAndSetWaitStatus(pred, ws, Node.SIGNAL);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 唤醒节点</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">unparkSuccessor</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">   * If status is negative (i.e., possibly needing signal) try</span></span><br><span class="line"><span class="comment">   * to clear in anticipation of signalling.  It is OK if this</span></span><br><span class="line"><span class="comment">   * fails or if status is changed by waiting thread.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">int</span> ws = node.waitStatus;</span><br><span class="line">  <span class="keyword">if</span> (ws &lt; <span class="number">0</span>)</span><br><span class="line">    compareAndSetWaitStatus(node, ws, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">   * Thread to unpark is held in successor, which is normally</span></span><br><span class="line"><span class="comment">   * just the next node.  But if cancelled or apparently null,</span></span><br><span class="line"><span class="comment">   * traverse backwards from tail to find the actual</span></span><br><span class="line"><span class="comment">   * non-cancelled successor.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  Node s = node.next;</span><br><span class="line">  <span class="keyword">if</span> (s == <span class="keyword">null</span> || s.waitStatus &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    s = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">for</span> (Node t = tail; t != <span class="keyword">null</span> &amp;&amp; t != node; t = t.prev)</span><br><span class="line">      <span class="keyword">if</span> (t.waitStatus &lt;= <span class="number">0</span>)</span><br><span class="line">        s = t;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (s != <span class="keyword">null</span>)</span><br><span class="line">    LockSupport.unpark(s.thread);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>node.prev = pred; compareAndSetTail(pred, node) 这两个地方可以看作Tail入队的原子操作，但是此时pred.next = node;还没执行，如果这个时候执行了unparkSuccessor方法，就没办法从前往后找了，所以需要从后往前找。还有一点原因，在产生CANCELLED状态节点的时候，先断开的是Next指针，Prev指针并未断开，因此也是必须要从后往前遍历才能够遍历完全部的Node。</p>
<h2 id="流程图"><a href="#流程图" class="headerlink" title="流程图"></a>流程图</h2><h3 id="获取锁的流程图"><a href="#获取锁的流程图" class="headerlink" title="获取锁的流程图"></a>获取锁的流程图</h3><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://bb3e216f.onedrive-cf-index-ng-e34.pages.dev/api/raw?path=/Public/BlogImg/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/ReentrantLock%E5%B0%9D%E8%AF%95%E8%8E%B7%E5%8F%96%E9%94%81.png"
                      alt="ReentrantLock尝试获取锁.jpg"
                ></p>
<h3 id="释放锁的流程图"><a href="#释放锁的流程图" class="headerlink" title="释放锁的流程图"></a>释放锁的流程图</h3><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://bb3e216f.onedrive-cf-index-ng-e34.pages.dev/api/raw?path=/Public/BlogImg/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/ReentrantLock%E5%B0%9D%E8%AF%95%E9%87%8A%E6%94%BE%E9%94%81.png"
                      alt="ReentrantLock尝试释放锁.jpg"
                ></p>
<p>======================== 2023.11.24 更新 ========================</p>
<h2 id="公平锁相关"><a href="#公平锁相关" class="headerlink" title="公平锁相关"></a>公平锁相关</h2><p>之前讲的都是非公平锁，此处补充下公平锁，对比下两者之间的差距</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 尝试获取锁</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  acquire(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">      acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">    selfInterrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> Thread current = Thread.currentThread();</span><br><span class="line">  <span class="keyword">int</span> c = getState();</span><br><span class="line">  <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">// 不存在等待的节点【逻辑差异处】</span></span><br><span class="line">    <span class="keyword">if</span> (!hasQueuedPredecessors() &amp;&amp;</span><br><span class="line">        compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">      setExclusiveOwnerThread(current);</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">    <span class="keyword">int</span> nextc = c + acquires;</span><br><span class="line">    <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>)</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">&quot;Maximum lock count exceeded&quot;</span>);</span><br><span class="line">    setState(nextc);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 逻辑相同</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">addWaiter</span><span class="params">(Node mode)</span> </span>&#123;</span><br><span class="line">  Node node = <span class="keyword">new</span> Node(Thread.currentThread(), mode);</span><br><span class="line">  <span class="comment">// Try the fast path of enq; backup to full enq on failure</span></span><br><span class="line">  Node pred = tail;</span><br><span class="line">  <span class="keyword">if</span> (pred != <span class="keyword">null</span>) &#123;</span><br><span class="line">    node.prev = pred;</span><br><span class="line">    <span class="keyword">if</span> (compareAndSetTail(pred, node)) &#123;</span><br><span class="line">      pred.next = node;</span><br><span class="line">      <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  enq(node);</span><br><span class="line">  <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 逻辑相同</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">acquireQueued</span><span class="params">(<span class="keyword">final</span> Node node, <span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">boolean</span> interrupted = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">      <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">      <span class="comment">// tryAcquire逻辑不同</span></span><br><span class="line">      <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">        setHead(node);</span><br><span class="line">        p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">        failed = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">return</span> interrupted;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">          parkAndCheckInterrupt())</span><br><span class="line">        interrupted = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (failed)</span><br><span class="line">      cancelAcquire(node);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>==&gt; 结论：非公平锁和公平锁的差别就是在尝试获取锁的时候，公平锁会去看一下还有没有节点在等待获取锁，有的话等待的节点优先级高于当前节点。而非公平锁则是直接尝试获取锁，当前节点与其他等待节点进行竞争</p>

<div id="gitalk-container"></div>
<script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

		<script>
		var gitalkConfig = {"clientID":"26b8e6758f16d4524e69","clientSecret":"ecfd9e9a439bcb8a4c4fd21f4677fa102c68b352","repo":"beastmouth.github.io","owner":"beastmouth","admin":["beastmouth"],"distractionFreeMode":false,"createIssueManually":true};
	    gitalkConfig.id = md5(location.pathname);
		var gitalk = new Gitalk(gitalkConfig);
	    gitalk.render("gitalk-container");
	    </script>]]></content>
      <categories>
        <category>多线程</category>
      </categories>
  </entry>
  <entry>
    <title>写一篇RocketMQ卷文让自己冷静一下</title>
    <url>/2021/12/08/%E5%86%99%E4%B8%80%E7%AF%87RocketMQ%E5%8D%B7%E6%96%87%E8%AE%A9%E8%87%AA%E5%B7%B1%E5%86%B7%E9%9D%99%E4%B8%80%E4%B8%8B/</url>
    <content><![CDATA[<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://bb3e216f.onedrive-cf-index-ng-e34.pages.dev/api/raw?path=/Public/BlogImg/RocketMQ/RocketMQ%E5%8D%B7%E6%96%87%20background.jpeg"
                      alt="RocketMQ卷文 background.jpeg"
                ></p>
<hr>
<p>不吃（烧烤）不喝（奶茶可乐）看了好久才概括出这么一点点东西，希望大佬们能够有耐心看一看，遇到说的不对的地方，也欢迎在评论区或者私信与我交流</p>
<p>另外完整版的代码注释，我在我的github上也添加了，感兴趣的小伙伴也可以点击这个链接去看一波 <a class="link"   href="https://github.com/beastmouth/rocketmq" >github地址<i class="fas fa-external-link-alt"></i></a></p>
<p>觉得我讲的有那么一点点道理，对你有那么一丢丢的帮助的，也可以给我一波点赞关注666哟～</p>
<p>废话不多说，下面开始我的表演～</p>
<h3 id="RocketMQ全局流程图"><a href="#RocketMQ全局流程图" class="headerlink" title="RocketMQ全局流程图"></a>RocketMQ全局流程图</h3><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://bb3e216f.onedrive-cf-index-ng-e34.pages.dev/api/raw?path=/Public/BlogImg/RocketMQ/RocketMQ%E5%8D%B7%E6%96%87%20%E5%85%A8%E6%B5%81%E7%A8%8B.jpeg"
                      alt="RocketMQ卷文 全流程.jpeg"
                ></p>
<p>上来就是这么一大张图片，相信大家肯定完全不想看下去。（那么我为什么还要放在一开始呢？主要是为了能够让大家有一个全局的印象，然后后续复习的时候也可以根据这个流程图去具体复习）</p>
<p>那么，下面我们就针对一些问题来具体描述RocketMQ的工作流程 <em>此处内容会不断补充，也欢迎大家把遇到的问题在评论区留下来</em></p>
<h3 id="消息消费逻辑"><a href="#消息消费逻辑" class="headerlink" title="消息消费逻辑"></a>消息消费逻辑</h3><p>消息消费可以分为三大模块</p>
<ul>
<li>Rebalance</li>
<li>拉取消息</li>
<li>消费消息</li>
</ul>
<h4 id="Rebalance"><a href="#Rebalance" class="headerlink" title="Rebalance"></a>Rebalance</h4><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://bb3e216f.onedrive-cf-index-ng-e34.pages.dev/api/raw?path=/Public/BlogImg/RocketMQ/RocketMQ%E5%8D%B7%E6%96%87%20Rebalance%E6%B5%81%E7%A8%8B.jpeg"
                      alt="RocketMQ卷文 Rebalance流程.jpeg"
                ></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// RebalanceImpl</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doRebalance</span><span class="params">(<span class="keyword">final</span> <span class="keyword">boolean</span> isOrder)</span> </span>&#123;</span><br><span class="line">  Map&lt;String, SubscriptionData&gt; subTable = <span class="keyword">this</span>.getSubscriptionInner();</span><br><span class="line">  <span class="keyword">if</span> (subTable != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="comment">// 遍历每个主题的队列</span></span><br><span class="line">    <span class="comment">// subTable 会在 DefaultMQPushConsumerImpl 的 subscribe 和 unsubscribe 时修改</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">final</span> Map.Entry&lt;String, SubscriptionData&gt; entry : subTable.entrySet()) &#123;</span><br><span class="line">      <span class="keyword">final</span> String topic = entry.getKey();</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 对队列进行重新负载</span></span><br><span class="line">        <span class="keyword">this</span>.rebalanceByTopic(topic, isOrder);</span><br><span class="line">      &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!topic.startsWith(MixAll.RETRY_GROUP_TOPIC_PREFIX)) &#123;</span><br><span class="line">          log.warn(<span class="string">&quot;rebalanceByTopic Exception&quot;</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">this</span>.truncateMessageQueueNotMyTopic();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">rebalanceByTopic</span><span class="params">(<span class="keyword">final</span> String topic, <span class="keyword">final</span> <span class="keyword">boolean</span> isOrder)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">switch</span> (messageModel) &#123;</span><br><span class="line">    <span class="keyword">case</span> BROADCASTING: &#123;</span><br><span class="line">      Set&lt;MessageQueue&gt; mqSet = <span class="keyword">this</span>.topicSubscribeInfoTable.get(topic);</span><br><span class="line">      <span class="keyword">if</span> (mqSet != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">boolean</span> changed = <span class="keyword">this</span>.updateProcessQueueTableInRebalance(topic, mqSet, isOrder);</span><br><span class="line">        <span class="keyword">if</span> (changed) &#123;</span><br><span class="line">          <span class="keyword">this</span>.messageQueueChanged(topic, mqSet, mqSet);</span><br><span class="line">          log.info(<span class="string">&quot;messageQueueChanged &#123;&#125; &#123;&#125; &#123;&#125; &#123;&#125;&quot;</span>,</span><br><span class="line">                   consumerGroup,</span><br><span class="line">                   topic,</span><br><span class="line">                   mqSet,</span><br><span class="line">                   mqSet);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        log.warn(<span class="string">&quot;doRebalance, &#123;&#125;, but the topic[&#123;&#125;] not exist.&quot;</span>, consumerGroup, topic);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">case</span> CLUSTERING: &#123;</span><br><span class="line">      <span class="comment">// topicSubscribeInfoTable topic订阅信息缓存表</span></span><br><span class="line">      Set&lt;MessageQueue&gt; mqSet = <span class="keyword">this</span>.topicSubscribeInfoTable.get(topic);</span><br><span class="line">      <span class="comment">// 发送请求到broker获取topic下该消费组内当前所有的消费者客户端id</span></span><br><span class="line">      List&lt;String&gt; cidAll = <span class="keyword">this</span>.mQClientFactory.findConsumerIdList(topic, consumerGroup);</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">null</span> == mqSet) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!topic.startsWith(MixAll.RETRY_GROUP_TOPIC_PREFIX)) &#123;</span><br><span class="line">          log.warn(<span class="string">&quot;doRebalance, &#123;&#125;, but the topic[&#123;&#125;] not exist.&quot;</span>, consumerGroup, topic);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">null</span> == cidAll) &#123;</span><br><span class="line">        log.warn(<span class="string">&quot;doRebalance, &#123;&#125; &#123;&#125;, get consumer id list failed&quot;</span>, consumerGroup, topic);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (mqSet != <span class="keyword">null</span> &amp;&amp; cidAll != <span class="keyword">null</span>) &#123;</span><br><span class="line">        List&lt;MessageQueue&gt; mqAll = <span class="keyword">new</span> ArrayList&lt;MessageQueue&gt;();</span><br><span class="line">        mqAll.addAll(mqSet);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 排序保证了同一个消费组内消费者看到的视图保持一致，确保同一个消费队列不会被多个消费者分配</span></span><br><span class="line">        Collections.sort(mqAll);</span><br><span class="line">        Collections.sort(cidAll);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 分配算法 （尽量使用前两种）</span></span><br><span class="line">        <span class="comment">// 默认有5种 1）平均分配 2）平均轮询分配 3）一致性hash</span></span><br><span class="line">        <span class="comment">// 4）根据配置 为每一个消费者配置固定的消息队列 5）根据broker部署机房名，对每个消费者负责不同的broker上的队列</span></span><br><span class="line">        <span class="comment">// 但是如果消费者数目大于消息队列数量，则会有些消费者无法消费消息</span></span><br><span class="line">        AllocateMessageQueueStrategy strategy = <span class="keyword">this</span>.allocateMessageQueueStrategy;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 当前消费者分配到的队列</span></span><br><span class="line">        List&lt;MessageQueue&gt; allocateResult = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          allocateResult = strategy.allocate(</span><br><span class="line">            <span class="keyword">this</span>.consumerGroup,</span><br><span class="line">            <span class="keyword">this</span>.mQClientFactory.getClientId(),</span><br><span class="line">            mqAll,</span><br><span class="line">            cidAll);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">          log.error(<span class="string">&quot;AllocateMessageQueueStrategy.allocate Exception. allocateMessageQueueStrategyName=&#123;&#125;&quot;</span>, strategy.getName(),</span><br><span class="line">                    e);</span><br><span class="line">          <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Set&lt;MessageQueue&gt; allocateResultSet = <span class="keyword">new</span> HashSet&lt;MessageQueue&gt;();</span><br><span class="line">        <span class="keyword">if</span> (allocateResult != <span class="keyword">null</span>) &#123;</span><br><span class="line">          allocateResultSet.addAll(allocateResult);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 更新消息消费队列，如果是新增的消息消费队列，则会创建一个消息拉取请求并立即执行拉取</span></span><br><span class="line">        <span class="keyword">boolean</span> changed = <span class="keyword">this</span>.updateProcessQueueTableInRebalance(topic, allocateResultSet, isOrder);</span><br><span class="line">        <span class="keyword">if</span> (changed) &#123;</span><br><span class="line">          log.info(</span><br><span class="line">            <span class="string">&quot;rebalanced result changed. allocateMessageQueueStrategyName=&#123;&#125;, group=&#123;&#125;, topic=&#123;&#125;, clientId=&#123;&#125;, mqAllSize=&#123;&#125;, cidAllSize=&#123;&#125;, rebalanceResultSize=&#123;&#125;, rebalanceResultSet=&#123;&#125;&quot;</span>,</span><br><span class="line">            strategy.getName(), consumerGroup, topic, <span class="keyword">this</span>.mQClientFactory.getClientId(), mqSet.size(), cidAll.size(),</span><br><span class="line">            allocateResultSet.size(), allocateResultSet);</span><br><span class="line">          <span class="keyword">this</span>.messageQueueChanged(topic, mqSet, allocateResultSet);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">updateProcessQueueTableInRebalance</span><span class="params">(<span class="keyword">final</span> String topic, <span class="keyword">final</span> Set&lt;MessageQueue&gt; mqSet,</span></span></span><br><span class="line"><span class="params"><span class="function">                                                   <span class="keyword">final</span> <span class="keyword">boolean</span> isOrder)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">boolean</span> changed = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">  Iterator&lt;Entry&lt;MessageQueue, ProcessQueue&gt;&gt; it = <span class="keyword">this</span>.processQueueTable.entrySet().iterator();</span><br><span class="line">  <span class="keyword">while</span> (it.hasNext()) &#123;</span><br><span class="line">    Entry&lt;MessageQueue, ProcessQueue&gt; next = it.next();</span><br><span class="line">    MessageQueue mq = next.getKey();</span><br><span class="line">    ProcessQueue pq = next.getValue();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mq.getTopic().equals(topic)) &#123;</span><br><span class="line">      <span class="comment">// 当前分配到的队列中不包含原先的队列（说明当前队列被分配给了其他消费者）</span></span><br><span class="line">      <span class="keyword">if</span> (!mqSet.contains(mq)) &#123;</span><br><span class="line">        <span class="comment">// 丢弃 processQueue</span></span><br><span class="line">        pq.setDropped(<span class="keyword">true</span>);</span><br><span class="line">        <span class="comment">// 移除当前消息队列</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.removeUnnecessaryMessageQueue(mq, pq)) &#123;</span><br><span class="line">          it.remove();</span><br><span class="line">          changed = <span class="keyword">true</span>;</span><br><span class="line">          log.info(<span class="string">&quot;doRebalance, &#123;&#125;, remove unnecessary mq, &#123;&#125;&quot;</span>, consumerGroup, mq);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pq.isPullExpired()) &#123;</span><br><span class="line">        <span class="keyword">switch</span> (<span class="keyword">this</span>.consumeType()) &#123;</span><br><span class="line">          <span class="keyword">case</span> CONSUME_ACTIVELY:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">          <span class="keyword">case</span> CONSUME_PASSIVELY:</span><br><span class="line">            pq.setDropped(<span class="keyword">true</span>);</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.removeUnnecessaryMessageQueue(mq, pq)) &#123;</span><br><span class="line">              it.remove();</span><br><span class="line">              changed = <span class="keyword">true</span>;</span><br><span class="line">              log.error(<span class="string">&quot;[BUG]doRebalance, &#123;&#125;, remove unnecessary mq, &#123;&#125;, because pull is pause, so try to fixed it&quot;</span>,</span><br><span class="line">                        consumerGroup, mq);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">          <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  List&lt;PullRequest&gt; pullRequestList = <span class="keyword">new</span> ArrayList&lt;PullRequest&gt;();</span><br><span class="line">  <span class="keyword">for</span> (MessageQueue mq : mqSet) &#123;</span><br><span class="line">    <span class="comment">// 消息消费队列缓存中不存在当前队列 本次分配新增的队列</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">this</span>.processQueueTable.containsKey(mq)) &#123;</span><br><span class="line">      <span class="comment">// 向broker发起锁定队列请求 (向broker端请求锁定MessageQueue,同时在本地锁定对应的ProcessQueue)</span></span><br><span class="line">      <span class="keyword">if</span> (isOrder &amp;&amp; !<span class="keyword">this</span>.lock(mq)) &#123;</span><br><span class="line">        log.warn(<span class="string">&quot;doRebalance, &#123;&#125;, add a new mq failed, &#123;&#125;, because lock failed&quot;</span>, consumerGroup, mq);</span><br><span class="line">        <span class="comment">// 加锁失败，跳过，等待下一次队列重新负载时再尝试加锁</span></span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 从内存中移除该消息队列的消费进度</span></span><br><span class="line">      <span class="keyword">this</span>.removeDirtyOffset(mq);</span><br><span class="line">      ProcessQueue pq = <span class="keyword">new</span> ProcessQueue();</span><br><span class="line"></span><br><span class="line">      <span class="keyword">long</span> nextOffset = -<span class="number">1L</span>;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        nextOffset = <span class="keyword">this</span>.computePullFromWhereWithException(mq);</span><br><span class="line">      &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        log.info(<span class="string">&quot;doRebalance, &#123;&#125;, compute offset failed, &#123;&#125;&quot;</span>, consumerGroup, mq);</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (nextOffset &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        ProcessQueue pre = <span class="keyword">this</span>.processQueueTable.putIfAbsent(mq, pq);</span><br><span class="line">        <span class="keyword">if</span> (pre != <span class="keyword">null</span>) &#123;</span><br><span class="line">          log.info(<span class="string">&quot;doRebalance, &#123;&#125;, mq already exists, &#123;&#125;&quot;</span>, consumerGroup, mq);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="comment">// 首次添加，构建拉取消息的请求</span></span><br><span class="line">          log.info(<span class="string">&quot;doRebalance, &#123;&#125;, add a new mq, &#123;&#125;&quot;</span>, consumerGroup, mq);</span><br><span class="line">          PullRequest pullRequest = <span class="keyword">new</span> PullRequest();</span><br><span class="line">          pullRequest.setConsumerGroup(consumerGroup);</span><br><span class="line">          pullRequest.setNextOffset(nextOffset);</span><br><span class="line">          pullRequest.setMessageQueue(mq);</span><br><span class="line">          pullRequest.setProcessQueue(pq);</span><br><span class="line">          pullRequestList.add(pullRequest);</span><br><span class="line">          changed = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        log.warn(<span class="string">&quot;doRebalance, &#123;&#125;, add new mq failed, &#123;&#125;&quot;</span>, consumerGroup, mq);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 立即拉取消息(对新增的队列)</span></span><br><span class="line">  <span class="keyword">this</span>.dispatchPullRequest(pullRequestList);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> changed;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由流程图和代码，我们可以得知，集群模式下消息负载主要有以下几个步骤：</p>
<ol>
<li>从Broker获取订阅当前Topic的消费者列表</li>
<li>根据具体的策略进行负载均衡</li>
<li>对当前消费者分配到的队列进行处理<ol>
<li>原来有，现在没有：丢弃对应的消息处理队列（ProcessQueue）</li>
<li>原来没有，现在有：添加消息处理队列（ProcessQueue），如果是第一次新增，还会创建一个消息拉取请求</li>
</ol>
</li>
</ol>
<h4 id="拉取消息"><a href="#拉取消息" class="headerlink" title="拉取消息"></a>拉取消息</h4><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://bb3e216f.onedrive-cf-index-ng-e34.pages.dev/api/raw?path=/Public/BlogImg/RocketMQ/RocketMQ%E5%8D%B7%E6%96%87%20%E6%8B%89%E5%8F%96%E6%B6%88%E6%81%AF%E6%B5%81%E7%A8%8B.jpeg"
                      alt="RocketMQ卷文 拉取消息流程.jpeg"
                ></p>
<p>拉取消息的代码太多了，我就不再这里贴出来了。</p>
<p>我在这里说一下大致流程，然后有几个需要注意的地方</p>
<p>流程：在我们Rebalance第一次添加负责的队列和后续拉取消息后，都会再提交一个拉取请求到拉取请求队列（pullRequestQueue）中，然后有一个线程不停的去里面获取拉取请求，去执行拉取的操作</p>
<p>这里说一个RocketMQ消费者这边设计的一个亮点</p>
<p>它将拉取消息，消费消息通过两个任务队列的方式进行解耦，然后每一个模块仅需要负责它自己的功能。（虽然大佬们觉得很常见，但是当时我看的时候还是感觉妙呀～）</p>
<p>另外还有一点需要注意的是：拉取消息的时候broker和consumer都会对消息进行过滤，只不过broker是根据tag的hash进行过滤的，而consumer是根据具体的tag字符串匹配过滤的。这也是有的时候，明明拉取到了消息，但是却没有需要消费的消息产生的原因</p>
<p>既然说到了消息过滤，这边先简单提一下RocketMQ消息过滤的几种方式</p>
<ul>
<li>表达式过滤<ul>
<li>tag</li>
<li>SQL92</li>
</ul>
</li>
<li>类过滤</li>
</ul>
<h4 id="消费消息"><a href="#消费消息" class="headerlink" title="消费消息"></a>消费消息</h4><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://bb3e216f.onedrive-cf-index-ng-e34.pages.dev/api/raw?path=/Public/BlogImg/RocketMQ/RocketMQ%E5%8D%B7%E6%96%87%20%E6%B6%88%E8%B4%B9%E6%B6%88%E6%81%AF.jpeg"
                      alt="RocketMQ卷文 消费消息.jpeg"
                ></p>
<p>这边也先说几个注意点吧，后面再单独出篇文章。</p>
<p>（一）顺序消费和非顺序消费消费失败的处理</p>
<p>（二）消费失败偏移量的更新：只有当前这批消息全部消费成功后，才会将偏移量更新成为这批消息最后一条的偏移量</p>
<p>（三）广播消息失败不会重试，仅打印失败日志</p>
<h4 id="补充：为什么同一个消费组下消费者的订阅信息要相同"><a href="#补充：为什么同一个消费组下消费者的订阅信息要相同" class="headerlink" title="补充：为什么同一个消费组下消费者的订阅信息要相同"></a>补充：为什么同一个消费组下消费者的订阅信息要相同</h4><p>首先，先说一下什么叫做同一个消费组下消费者的订阅信息要相同</p>
<p>即：在相同的GroupId下，每一个消费者他们的订阅内容（Topic+Tag）要保持一致，否则会导致消息无法被正常消费</p>
<p>参考文档：<a class="link"   href="https://help.aliyun.com/document_detail/43523.html?spm=a2c4g.11186623.6.777.1dba3635aj4Own" >阿里云:订阅关系一致<i class="fas fa-external-link-alt"></i></a></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://bb3e216f.onedrive-cf-index-ng-e34.pages.dev/api/raw?path=/Public/BlogImg/RocketMQ/RocketMQ%E5%8D%B7%E6%96%87%20Rebalance%E8%AF%A6%E6%83%85.jpeg"
                      alt="RocketMQ卷文 Rebalance详情.jpeg"
                ></p>
<p>我们在看待这个问题的时候，可以把它分为两类情况考虑</p>
<ul>
<li>topic不一致</li>
<li>tag不一致</li>
</ul>
<p>（一）topic不一致的问题</p>
<p>首先先说一个场景，消费者A监听了TopicA，消费者B监听了TopicB，但是消费者A和消费者B同属一个groupTest</p>
<p>在Rebalance阶段，消费者A对TopicA进行负载均衡时，会去查询groupTest下的所有消费者信息。获取到了消费者A和消费者B。此时就会将TopicA的队列对消费者A和消费者B进行负载均衡（例如消费者A分配到了1234四个队列，消费者B分配到了5678四个队列）。此时消费者B没有针对TopicA的处理逻辑，就会导致推送到5678这几个队列里面的消息没有办法得到处理。</p>
<p>（二）tag不一致的问题</p>
<p>随着消费者A，消费者B负载均衡的不断进行，会不断把最新的订阅信息（消息过滤规则）上报给broker。broker就会不断的覆盖更新，导致tag信息不停地变化，而tag的变化在消费者拉取消息时broker的过滤就会产生影响，会导致一些本来要被消费者拉取到的消息被broker过滤掉</p>
<h4 id="消费者总结"><a href="#消费者总结" class="headerlink" title="消费者总结"></a>消费者总结</h4><p>讲了这么多的消费者的内容，出现了好多名词，也把消费者的一些比较核心的内容逐个讲了一遍。</p>
<p>那么，在这里，我们将消费者这个模块里面的所有东西，在进行一个完整的串联。然后消费者这一方面的介绍就要告一段落了</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://bb3e216f.onedrive-cf-index-ng-e34.pages.dev/api/raw?path=/Public/BlogImg/RocketMQ/RocketMQ%E5%8D%B7%E6%96%87%20%E6%B6%88%E8%B4%B9%E8%80%85%E5%AE%8C%E6%95%B4%E6%B5%81%E7%A8%8B.jpeg"
                      alt="RocketMQ卷文 消费者完整流程.jpeg"
                ></p>
<h3 id="延时队列是如何工作的"><a href="#延时队列是如何工作的" class="headerlink" title="延时队列是如何工作的"></a>延时队列是如何工作的</h3><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://bb3e216f.onedrive-cf-index-ng-e34.pages.dev/api/raw?path=/Public/BlogImg/RocketMQ/RocketMQ%E5%8D%B7%E6%96%87%20%E5%BB%B6%E8%BF%9F%E9%98%9F%E5%88%97.png"
                      alt="RocketMQ卷文 延迟队列.jpg"
                ></p>
<p>由流程图中我们不难看出，RocketMQ对延时消息的处理，是交由Timer去完成的（相关类ScheduleMessageService）。在Timer的任务队列中读取需要处理的延迟任务，将消息从延迟队列转发到具体的业务队列中</p>
<p>此处补充一点：此处提到的Timer为java工具类包（java.util.Timer）下的一个定时任务工具。它主要由两个部分：TaskQueue queue（任务队列）和TimerThread thread（工作线程）。这边我把它简单的类比为一个单线程的工作线程池</p>
<p>另外在ScheduleMessageService中使用到了Timer的两个方法，我在这里先单独列出来下</p>
<ul>
<li>this.timer.schedule ：在任务执行成功后，再加上对应的周期，然后再执行</li>
<li>this.timer.scheduleAtFixedRate ：每隔指定时间就执行一次，与任务执行时间无关</li>
</ul>
<p>话不多少，贴上源码<em>（源码虽然枯燥，但希望可以耐心的看完）</em></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ScheduleMessageService</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (started.compareAndSet(<span class="keyword">false</span>, <span class="keyword">true</span>)) &#123;</span><br><span class="line">    <span class="keyword">super</span>.load();</span><br><span class="line">    <span class="keyword">this</span>.timer = <span class="keyword">new</span> Timer(<span class="string">&quot;ScheduleMessageTimerThread&quot;</span>, <span class="keyword">true</span>);</span><br><span class="line">    <span class="comment">// 根据延时队列创建对应的定时任务</span></span><br><span class="line">    <span class="keyword">for</span> (Map.Entry&lt;Integer, Long&gt; entry : <span class="keyword">this</span>.delayLevelTable.entrySet()) &#123;</span><br><span class="line">      Integer level = entry.getKey();</span><br><span class="line">      Long timeDelay = entry.getValue();</span><br><span class="line">      Long offset = <span class="keyword">this</span>.offsetTable.get(level);</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">null</span> == offset) &#123;</span><br><span class="line">        offset = <span class="number">0L</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (timeDelay != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 第一次，延迟一秒执行任务，后续根据对应延时时间来执行</span></span><br><span class="line">        <span class="comment">// 延时级别和消息队列id对应关系 ： 消息队列id = 延时级别 - 1</span></span><br><span class="line">        <span class="comment">// shedule 在任务执行成功后，再加上对应的周期，然后再执行</span></span><br><span class="line">        <span class="keyword">this</span>.timer.schedule(<span class="keyword">new</span> DeliverDelayedMessageTimerTask(level, offset), FIRST_DELAY_TIME);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// scheduleAtFixedRate 每隔指定时间就执行一次，与任务执行时间无关</span></span><br><span class="line">    <span class="keyword">this</span>.timer.scheduleAtFixedRate(<span class="keyword">new</span> TimerTask() &#123;</span><br><span class="line"></span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="keyword">if</span> (started.get()) &#123;</span><br><span class="line">            <span class="comment">// 每个十秒持久化一次延迟队列的处理进度</span></span><br><span class="line">            ScheduleMessageService.<span class="keyword">this</span>.persist();</span><br><span class="line">          &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">          log.error(<span class="string">&quot;scheduleAtFixedRate flush exception&quot;</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;, <span class="number">10000</span>, <span class="keyword">this</span>.defaultMessageStore.getMessageStoreConfig().getFlushDelayOffsetInterval());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// DeliverDelayedMessageTimerTask</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (isStarted()) &#123;</span><br><span class="line">      <span class="keyword">this</span>.executeOnTimeup();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    <span class="comment">// <span class="doctag">XXX:</span> warn and notify me</span></span><br><span class="line">    log.error(<span class="string">&quot;ScheduleMessageService, executeOnTimeup exception&quot;</span>, e);</span><br><span class="line">    ScheduleMessageService.<span class="keyword">this</span>.timer.schedule(<span class="keyword">new</span> DeliverDelayedMessageTimerTask(</span><br><span class="line">      <span class="keyword">this</span>.delayLevel, <span class="keyword">this</span>.offset), DELAY_FOR_A_PERIOD);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">executeOnTimeup</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 根据 延时队列topic 和 延时队列id 查找消费队列</span></span><br><span class="line">  ConsumeQueue cq =</span><br><span class="line">    ScheduleMessageService.<span class="keyword">this</span>.defaultMessageStore.findConsumeQueue(TopicValidator.RMQ_SYS_SCHEDULE_TOPIC,</span><br><span class="line">                                                                     delayLevel2QueueId(delayLevel));</span><br><span class="line"></span><br><span class="line">  <span class="keyword">long</span> failScheduleOffset = offset;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (cq != <span class="keyword">null</span>) &#123;</span><br><span class="line">    SelectMappedBufferResult bufferCQ = cq.getIndexBuffer(<span class="keyword">this</span>.offset);</span><br><span class="line">    <span class="keyword">if</span> (bufferCQ != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">long</span> nextOffset = offset;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 遍历ConsumeQueue，每一个标准的ConsumeQueue条目为20字节</span></span><br><span class="line">        ConsumeQueueExt.CqExtUnit cqExtUnit = <span class="keyword">new</span> ConsumeQueueExt.CqExtUnit();</span><br><span class="line">        <span class="keyword">for</span> (; i &lt; bufferCQ.getSize(); i += ConsumeQueue.CQ_STORE_UNIT_SIZE) &#123;</span><br><span class="line">          <span class="keyword">long</span> offsetPy = bufferCQ.getByteBuffer().getLong();</span><br><span class="line">          <span class="keyword">int</span> sizePy = bufferCQ.getByteBuffer().getInt();</span><br><span class="line">          <span class="keyword">long</span> tagsCode = bufferCQ.getByteBuffer().getLong();</span><br><span class="line"></span><br><span class="line">          <span class="keyword">if</span> (cq.isExtAddr(tagsCode)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (cq.getExt(tagsCode, cqExtUnit)) &#123;</span><br><span class="line">              tagsCode = cqExtUnit.getTagsCode();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">              <span class="comment">//can&#x27;t find ext content.So re compute tags code.</span></span><br><span class="line">              log.error(<span class="string">&quot;[BUG] can&#x27;t find consume queue extend file content!addr=&#123;&#125;, offsetPy=&#123;&#125;, sizePy=&#123;&#125;&quot;</span>,</span><br><span class="line">                        tagsCode, offsetPy, sizePy);</span><br><span class="line">              <span class="keyword">long</span> msgStoreTime = defaultMessageStore.getCommitLog().pickupStoreTimestamp(offsetPy, sizePy);</span><br><span class="line">              tagsCode = computeDeliverTimestamp(delayLevel, msgStoreTime);</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          <span class="keyword">long</span> now = System.currentTimeMillis();</span><br><span class="line">          <span class="keyword">long</span> deliverTimestamp = <span class="keyword">this</span>.correctDeliverTimestamp(now, tagsCode);</span><br><span class="line"></span><br><span class="line">          nextOffset = offset + (i / ConsumeQueue.CQ_STORE_UNIT_SIZE);</span><br><span class="line"></span><br><span class="line">          <span class="comment">// &gt; 0 未到消息消费时间</span></span><br><span class="line">          <span class="keyword">long</span> countdown = deliverTimestamp - now;</span><br><span class="line"></span><br><span class="line">          <span class="keyword">if</span> (countdown &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            MessageExt msgExt =</span><br><span class="line">              ScheduleMessageService.<span class="keyword">this</span>.defaultMessageStore.lookMessageByOffset(</span><br><span class="line">              offsetPy, sizePy);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (msgExt != <span class="keyword">null</span>) &#123;</span><br><span class="line">              <span class="keyword">try</span> &#123;</span><br><span class="line">                MessageExtBrokerInner msgInner = <span class="keyword">this</span>.messageTimeup(msgExt);</span><br><span class="line">                <span class="keyword">if</span> (TopicValidator.RMQ_SYS_TRANS_HALF_TOPIC.equals(msgInner.getTopic())) &#123;</span><br><span class="line">                  log.error(<span class="string">&quot;[BUG] the real topic of schedule msg is &#123;&#125;, discard the msg. msg=&#123;&#125;&quot;</span>,</span><br><span class="line">                            msgInner.getTopic(), msgInner);</span><br><span class="line">                  <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 放到对应的 %RETRY%+gid 重试topic下进行消费(转发消息)</span></span><br><span class="line">                PutMessageResult putMessageResult =</span><br><span class="line">                  ScheduleMessageService.<span class="keyword">this</span>.writeMessageStore</span><br><span class="line">                  .putMessage(msgInner);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (putMessageResult != <span class="keyword">null</span></span><br><span class="line">                    &amp;&amp; putMessageResult.getPutMessageStatus() == PutMessageStatus.PUT_OK) &#123;</span><br><span class="line">                  <span class="keyword">if</span> (ScheduleMessageService.<span class="keyword">this</span>.defaultMessageStore.getMessageStoreConfig().isEnableScheduleMessageStats()) &#123;</span><br><span class="line">                    ScheduleMessageService.<span class="keyword">this</span>.defaultMessageStore.getBrokerStatsManager().incQueueGetNums(MixAll.SCHEDULE_CONSUMER_GROUP, TopicValidator.RMQ_SYS_SCHEDULE_TOPIC, delayLevel - <span class="number">1</span>, putMessageResult.getAppendMessageResult().getMsgNum());</span><br><span class="line">                    ScheduleMessageService.<span class="keyword">this</span>.defaultMessageStore.getBrokerStatsManager().incQueueGetSize(MixAll.SCHEDULE_CONSUMER_GROUP, TopicValidator.RMQ_SYS_SCHEDULE_TOPIC, delayLevel - <span class="number">1</span>, putMessageResult.getAppendMessageResult().getWroteBytes());</span><br><span class="line">                    ScheduleMessageService.<span class="keyword">this</span>.defaultMessageStore.getBrokerStatsManager().incGroupGetNums(MixAll.SCHEDULE_CONSUMER_GROUP, TopicValidator.RMQ_SYS_SCHEDULE_TOPIC, putMessageResult.getAppendMessageResult().getMsgNum());</span><br><span class="line">                    ScheduleMessageService.<span class="keyword">this</span>.defaultMessageStore.getBrokerStatsManager().incGroupGetSize(MixAll.SCHEDULE_CONSUMER_GROUP, TopicValidator.RMQ_SYS_SCHEDULE_TOPIC, putMessageResult.getAppendMessageResult().getWroteBytes());</span><br><span class="line">                    ScheduleMessageService.<span class="keyword">this</span>.defaultMessageStore.getBrokerStatsManager().incTopicPutNums(msgInner.getTopic(), putMessageResult.getAppendMessageResult().getMsgNum(), <span class="number">1</span>);</span><br><span class="line">                    ScheduleMessageService.<span class="keyword">this</span>.defaultMessageStore.getBrokerStatsManager().incTopicPutSize(msgInner.getTopic(),</span><br><span class="line">                                                                                                            putMessageResult.getAppendMessageResult().getWroteBytes());</span><br><span class="line">                    ScheduleMessageService.<span class="keyword">this</span>.defaultMessageStore.getBrokerStatsManager().incBrokerPutNums(putMessageResult.getAppendMessageResult().getMsgNum());</span><br><span class="line">                  &#125;</span><br><span class="line">                  <span class="keyword">continue</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                  <span class="comment">// <span class="doctag">XXX:</span> warn and notify me</span></span><br><span class="line">                  log.error(</span><br><span class="line">                    <span class="string">&quot;ScheduleMessageService, a message time up, but reput it failed, topic: &#123;&#125; msgId &#123;&#125;&quot;</span>,</span><br><span class="line">                    msgExt.getTopic(), msgExt.getMsgId());</span><br><span class="line">                  ScheduleMessageService.<span class="keyword">this</span>.timer.schedule(</span><br><span class="line">                    <span class="keyword">new</span> DeliverDelayedMessageTimerTask(<span class="keyword">this</span>.delayLevel,</span><br><span class="line">                                                       nextOffset), DELAY_FOR_A_PERIOD);</span><br><span class="line">                  ScheduleMessageService.<span class="keyword">this</span>.updateOffset(<span class="keyword">this</span>.delayLevel,</span><br><span class="line">                                                           nextOffset);</span><br><span class="line">                  <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">              &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                <span class="comment">/*</span></span><br><span class="line"><span class="comment">                                         * <span class="doctag">XXX:</span> warn and notify me</span></span><br><span class="line"><span class="comment">                                         */</span></span><br><span class="line">                log.error(</span><br><span class="line">                  <span class="string">&quot;ScheduleMessageService, messageTimeup execute error, drop it. msgExt=&#123;&#125;, nextOffset=&#123;&#125;, offsetPy=&#123;&#125;, sizePy=&#123;&#125;&quot;</span>, msgExt, nextOffset, offsetPy, sizePy, e);</span><br><span class="line">              &#125;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 会将下次任务执行时间设置为countdown 即 消息的延时转发时间-当前时间</span></span><br><span class="line">            ScheduleMessageService.<span class="keyword">this</span>.timer.schedule(</span><br><span class="line">              <span class="keyword">new</span> DeliverDelayedMessageTimerTask(<span class="keyword">this</span>.delayLevel, nextOffset),</span><br><span class="line">              countdown);</span><br><span class="line">            ScheduleMessageService.<span class="keyword">this</span>.updateOffset(<span class="keyword">this</span>.delayLevel, nextOffset);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125; <span class="comment">// end of for</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 更新延时队列拉取任务进度</span></span><br><span class="line">        nextOffset = offset + (i / ConsumeQueue.CQ_STORE_UNIT_SIZE);</span><br><span class="line">        ScheduleMessageService.<span class="keyword">this</span>.timer.schedule(<span class="keyword">new</span> DeliverDelayedMessageTimerTask(</span><br><span class="line">          <span class="keyword">this</span>.delayLevel, nextOffset), DELAY_FOR_A_WHILE);</span><br><span class="line">        ScheduleMessageService.<span class="keyword">this</span>.updateOffset(<span class="keyword">this</span>.delayLevel, nextOffset);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line"></span><br><span class="line">        bufferCQ.release();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="comment">// end of if (bufferCQ != null)</span></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 消费队列不存在，默认为没有需要消费的任务，跳过本次消费</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">long</span> cqMinOffset = cq.getMinOffsetInQueue();</span><br><span class="line">      <span class="keyword">long</span> cqMaxOffset = cq.getMaxOffsetInQueue();</span><br><span class="line">      <span class="keyword">if</span> (offset &lt; cqMinOffset) &#123;</span><br><span class="line">        <span class="comment">// 下次拉取任务进度更新</span></span><br><span class="line">        failScheduleOffset = cqMinOffset;</span><br><span class="line">        log.error(<span class="string">&quot;schedule CQ offset invalid. offset=&#123;&#125;, cqMinOffset=&#123;&#125;, cqMaxOffset=&#123;&#125;, queueId=&#123;&#125;&quot;</span>,</span><br><span class="line">                  offset, cqMinOffset, cqMaxOffset, cq.getQueueId());</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (offset &gt; cqMaxOffset) &#123;</span><br><span class="line">        failScheduleOffset = cqMaxOffset;</span><br><span class="line">        log.error(<span class="string">&quot;schedule CQ offset invalid. offset=&#123;&#125;, cqMinOffset=&#123;&#125;, cqMaxOffset=&#123;&#125;, queueId=&#123;&#125;&quot;</span>,</span><br><span class="line">                  offset, cqMinOffset, cqMaxOffset, cq.getQueueId());</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="comment">// end of if (cq != null)</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 根据延时等级创建一个任务</span></span><br><span class="line">  ScheduleMessageService.<span class="keyword">this</span>.timer.schedule(<span class="keyword">new</span> DeliverDelayedMessageTimerTask(<span class="keyword">this</span>.delayLevel,</span><br><span class="line">                                                                                failScheduleOffset), DELAY_FOR_A_WHILE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<div id="gitalk-container"></div>
<script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

		<script>
		var gitalkConfig = {"clientID":"26b8e6758f16d4524e69","clientSecret":"ecfd9e9a439bcb8a4c4fd21f4677fa102c68b352","repo":"beastmouth.github.io","owner":"beastmouth","admin":["beastmouth"],"distractionFreeMode":false,"createIssueManually":true};
	    gitalkConfig.id = md5(location.pathname);
		var gitalk = new Gitalk(gitalkConfig);
	    gitalk.render("gitalk-container");
	    </script>]]></content>
      <categories>
        <category>RocketMQ</category>
      </categories>
  </entry>
  <entry>
    <title>垃圾收集相关知识</title>
    <url>/2022/01/03/%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86/</url>
    <content><![CDATA[<h1 id="垃圾收集相关知识"><a href="#垃圾收集相关知识" class="headerlink" title="垃圾收集相关知识"></a>垃圾收集相关知识</h1><h2 id="思维导图"><a href="#思维导图" class="headerlink" title="思维导图"></a>思维导图</h2><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://bb3e216f.onedrive-cf-index-ng-e34.pages.dev/api/raw?path=/Public/BlogImg/JVM/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE.png"
                      alt="垃圾回收思维导图.jpg"
                ></p>
<h2 id="回收的对象"><a href="#回收的对象" class="headerlink" title="回收的对象"></a>回收的对象</h2><p>堆，方法区（方法区虚拟机不要求实现）</p>
<h2 id="如何判断一个对象可以回收"><a href="#如何判断一个对象可以回收" class="headerlink" title="如何判断一个对象可以回收"></a>如何判断一个对象可以回收</h2><h3 id="引用计数算法"><a href="#引用计数算法" class="headerlink" title="引用计数算法"></a>引用计数算法</h3><p>主流的Java虚拟机没有使用该算法。因为简单的引用计数无法解决循环引用问题，需要很多额外的操作</p>
<h3 id="可达性分析算法"><a href="#可达性分析算法" class="headerlink" title="可达性分析算法"></a>可达性分析算法</h3><p>GC ROOT 到该对象是否可达</p>
<h4 id="能够作为GC-ROOT的对象"><a href="#能够作为GC-ROOT的对象" class="headerlink" title="能够作为GC ROOT的对象"></a>能够作为GC ROOT的对象</h4><ul>
<li>在虚拟机栈（栈帧中的本地变量表）中引用的对象，譬如各个线程被调用的方法堆栈中使用到的 参数、局部变量、临时变量等。</li>
<li>在方法区中类静态属性引用的对象，譬如Java类的引用类型静态变量。</li>
<li>在方法区中常量引用的对象，譬如字符串常量池（String Table）里的引用。</li>
<li>在本地方法栈中JNI（即通常所说的Native方法）引用的对象。</li>
<li>Java虚拟机内部的引用，如基本数据类型对应的Class对象，一些常驻的异常对象（比如 NullPointExcepiton、OutOfMemoryError）等，还有系统类加载器。</li>
<li>所有被同步锁（synchronized关键字）持有的对象。</li>
<li>反映Java虚拟机内部情况的JMXBean、JVMTI中注册的回调、本地代码缓存等。</li>
<li>同时还会有一些其他对象被“临时性”的加入</li>
</ul>
<h4 id="关于GC-Roots根结点枚举的一个优化"><a href="#关于GC-Roots根结点枚举的一个优化" class="headerlink" title="关于GC Roots根结点枚举的一个优化"></a>关于GC Roots根结点枚举的一个优化</h4><p>首先要先明确一个前提：虚拟机（就算是几乎不会发生停顿的CMS、G1、ZGC等收集器）在进行根结点枚举的时候，都是需要STW的。因为根结点枚举始终要在一个能够保障一致性的快照中才能进行的（整个枚举过程中子系统不会再出现根结点集合的对象引用关系的变化）</p>
<p>可作为GC Roots的节点主要在全局性的引用（例如常量或类静态属性）与执行上下文（例如 栈帧中的本地变量表）中。但是尽管我们目标明确，但是查找过程要做到高效并不是一件容易的事情。因为随着Java应用越来越大，光是方法去的大小就常有数百上千兆，每次都从这边开始查找，无疑是一个耗时的操作。</p>
<p>此时就用到了个OopMap来记录对象引用（这样就不需要每次都从方法区开始找了）</p>
<p>OopMap在类加载动作完成之后，HotSpot就可以把对象内什么偏移量上是什么类型的数据给计算出来</p>
<h4 id="安全点"><a href="#安全点" class="headerlink" title="安全点"></a>安全点</h4><p>但是要知道，不是每条指令都生成对应的OopMap，只在特定位置生成对应的OopMap，这些位置就被称为安全点（SafePoint）（安全点太少会导致收集器等待时间过程，太多又回增大运行时的内存负荷）</p>
<p>可以作为安全点的几个地方：方法调用、循环跳转、异常跳转可以作为安全点</p>
<p>安全点=&gt;具有让程序长时间执行的特征=&gt;最明显的特征就是指令序列的复用，即上述的几个安全点</p>
<p>但是在我们进行垃圾回收，并不是所有的线程都会处于安全点。此时有两种方法可以解决这个问题</p>
<ul>
<li>抢先式中断：不需要线程执行代码配合，在GC时，系统让所有的用户线程全部中断如果线程没有到安全点，则恢复线程执行，知道线程执行到安全点目前几乎没有虚拟机使用这种方式</li>
<li>主动式中断：虚拟机会设置一个标志位，每个线程在执行过程中会不断地主动去轮询这个标识位一旦标志位true，线程就会在自己最近的安全点主动中断挂起<ul>
<li>由于轮询标识经常出现，需要考虑指令的高效。HotSpot使用内存保护陷阱的方式，当需要暂停用户线程时，就将0x160100的内存页设置为不可读</li>
</ul>
</li>
</ul>
<h4 id="安全区域"><a href="#安全区域" class="headerlink" title="安全区域"></a>安全区域</h4><p>刚刚上述说到的，都是在工作中的线程。但是正常运行的JVM虚拟机，肯定不止这种情况（Running）的线程，还有处于Sleep或者Blocked状态的线程，他们是无法响应虚拟机的中断请求的，无法走到安全点去挂起自己。此时就引入了个安全区域的概念</p>
<p>用户线程进入安全区域时，就会标识自己进入安全区域，那么在此期间虚拟机发起垃圾收集时，就不会去管这些已经声明自己在安全区域中的线程要离开时，会检查是否完成根结点的枚举，如果未完成则会一直等待，直到收到可以离开安全区域的信号为止</p>
<p>同时关于可达性算法，这里提一个概念，三色标记法</p>
<h4 id="三色标记法"><a href="#三色标记法" class="headerlink" title="三色标记法"></a>三色标记法</h4><ul>
<li>白色：对象未被垃圾收集器访问过</li>
<li>黑色：对象已被垃圾收集器访问过，且这个对象的所有引用都已经扫描过，它是安全存活的如果有其他对象引用指向了黑色对象，无须重新扫描一遍</li>
<li>灰色：标识对象已经被垃圾收集器访问过，但这个对象上至少存在一个引用还没有被扫描过</li>
</ul>
<h4 id="三色标记法的两个问题"><a href="#三色标记法的两个问题" class="headerlink" title="三色标记法的两个问题"></a>三色标记法的两个问题</h4><p>问题的前提：用户的线程与收集器并发的工作，在标记的时候，用户的线程也会去修改引用关系。会出现两个问题</p>
<ul>
<li>原本应该消亡的对象，被错误的标记为存活。（这个问题可以容忍，本身发生的概率不高，下次垃圾回收时再回收就可以了）</li>
<li>原本应该存活的对象被标记为消亡<strong>（这就不能容忍了）</strong></li>
</ul>
<p>第二种问题发生的原因：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://bb3e216f.onedrive-cf-index-ng-e34.pages.dev/api/raw?path=/Public/BlogImg/JVM/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%20%E4%B8%89%E8%89%B2%E6%A0%87%E8%AE%B0%E6%B3%95%E4%BA%A7%E7%94%9F%E7%9A%84%E9%97%AE%E9%A2%98.jpeg"
                      alt="垃圾回收 三色标记法产生的问题.jpeg"
                ></p>
<p>产生上述问题需要两个前提条件</p>
<ul>
<li>赋值器插入了一条或多条从黑色对象到白色对象的新引用</li>
<li>赋值器删除了全部从灰色对象到该白色对象的直接或间接引用</li>
</ul>
<p>增量更新（破坏第一个条件）：（CMS用到了）</p>
<p>当黑色对象插入新的指向白色对象的引用关系时，就将这个新插入的引用记录下来，等并发扫描结束之后，再将这些记录过的引用关系中的黑色对象为根，重新扫描一次。</p>
<p>这可以简化理解为，黑色对象一旦新插入了指向白色对象的引用之后，它就变回灰色对象了。</p>
<p>原始快照（破坏第二个条件）：（G1用到了）</p>
<p>当灰色对象要删除指向白色对象的引用关系时，就将这个要删 除的引用记录下来，在并发扫描结束之后，再将这些记录过的引用关系中的灰色对象为根，重新扫描一次。</p>
<p>这也可以简化理解为，无论引用关系删除与否，都会按照刚刚开始扫描那一刻的对象图快照来进行搜索。</p>
<p>即：将删除引用的白色对象作为根，重新扫描，保证当前白色对象不会被误删。不好的地方就是这个白色对象如果没有再被引用，也得等到下次垃圾收集时被回收<em>（ps：这一块仅是自己的理解，后续还需要求证）</em></p>
<h2 id="分代收集理论"><a href="#分代收集理论" class="headerlink" title="分代收集理论"></a>分代收集理论</h2><p>因为将Java堆划分出不同的区域，所以才会有垃圾收集器每次只回收其中一个或某些部分的区域</p>
<h3 id="为什么需要分代收集"><a href="#为什么需要分代收集" class="headerlink" title="为什么需要分代收集"></a>为什么需要分代收集</h3><p>如果一个区域内的大多数对象是朝生夕灭，难以熬过垃圾收集过程</p>
<p>那么将他们集中在一起，每次只需要考虑需要保留的少量存活对象而不是去标记那些大量需要回收的对象，</p>
<p>就可以以较低的成本回收大量的空间</p>
<p>同时，将那些难以回收的对象统一放在一个区域中，就可以以较低的频率去回收这块区域，</p>
<p>兼顾了垃圾收集的时间开销和内存空间的有效利用</p>
<h3 id="相关名词"><a href="#相关名词" class="headerlink" title="相关名词"></a>相关名词</h3><p>Partial GC（部分收集）才有了 Minor GC/Young GC（新生代收集）、Major GC/Old GC（老年代收集）、Full GC（整堆收集）、Mixed GC（收集整个新生代以及部分老年代，只有G1收集器有这样的行为）</p>
<p>也才能发展出 “标记-复制算法”，“标记-清除算法”，“标记-整理算法”</p>
<h3 id="跨代引用问题"><a href="#跨代引用问题" class="headerlink" title="跨代引用问题"></a>跨代引用问题</h3><p>新生代的对象可能会被老年代引用，老年代的对象也有可能会被新生代引用</p>
<p>假如此时我们要回收新生代的对象，就需要去扫描整个老年代，这无疑是一个不合理的操作</p>
<p>此时会在新生代上建立一个全局的数据结构（记忆集 Remembered Set），将老年代划分成若干小块，标记处老年代的那一块内存存在跨代引用。然后在MinorGC的时候，只需要把包含了跨代引用的小块内存里面的对象假如到GC Roots进行扫描即可</p>
<p>关于记忆集，存在三种精度</p>
<ul>
<li>字长精度：每个记录精确到一个机器字长（就是处理器的寻址位数，如常见的32位或64位，这个 精度决定了机器访问物理内存地址的指针长度），该字包含跨代指针。</li>
<li>对象精度：每个记录精确到一个对象，该对象里有字段含有跨代指针。</li>
<li>卡精度：每个记录精确到一块内存区域，该区域内有对象含有跨代指针。</li>
</ul>
<p>目前我们用到的最多的一种就是卡表。卡表（Card Table）是卡精度的一种实现方式</p>
<p>卡表中的么一个元素都对应着其标识的内存区域中一块特定大小的内存块，这个 内存块被称作“卡页”（Card Page）</p>
<p>一个卡页的内存中通常不止一个对象，只要一个卡页内有一个（或多个）对象存在跨代指针，则就在对应卡表的数组元素的值标识位1，代表这个元素变脏。（GC时只需要筛选出卡表中变脏的元素，然后将其加入到GC Roots中一并扫描）</p>
<p>此处HotSpot使用写屏障来维护卡表。（可以使用类比的思想，AOP的Around来看待写屏障维护卡表的操作）在引用对象的赋值会产生一个环绕（Around）通知。在赋值前的部分的写屏障叫作写前屏障（Pre-Write Barrier），在赋值后的则叫作写后屏障（Post-Write Barrier）。HotSpot虚拟机的许多收集器中都有使用到写屏障，但直 至G1收集器出现之前，其他收集器都只用到了写后屏障。</p>
<h2 id="垃圾回收算法"><a href="#垃圾回收算法" class="headerlink" title="垃圾回收算法"></a>垃圾回收算法</h2><ul>
<li>标记-清除算法（标记过程也会有STW，但是标记一般很快）（HotSpot的CMS收集器，关注延迟）</li>
<li>标记-复制算法</li>
<li>标记-整理算法（移动必须要STW，对象越多越大耗时越长）（HotSpot的ParallelScavenge收集器，关注吞吐）</li>
</ul>
<p>是否移动对象都存在弊端，移动则是在回收对象时复杂，不移动则是在内存分配时复杂。相比来说，内存分配和访问的频率会比回收高很多</p>

<div id="gitalk-container"></div>
<script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

		<script>
		var gitalkConfig = {"clientID":"26b8e6758f16d4524e69","clientSecret":"ecfd9e9a439bcb8a4c4fd21f4677fa102c68b352","repo":"beastmouth.github.io","owner":"beastmouth","admin":["beastmouth"],"distractionFreeMode":false,"createIssueManually":true};
	    gitalkConfig.id = md5(location.pathname);
		var gitalk = new Gitalk(gitalkConfig);
	    gitalk.render("gitalk-container");
	    </script>]]></content>
      <categories>
        <category>JVM</category>
      </categories>
  </entry>
  <entry>
    <title>对象创建（new一个对象）</title>
    <url>/2021/12/30/%E5%AF%B9%E8%B1%A1%E5%88%9B%E5%BB%BA%EF%BC%88new%E4%B8%80%E4%B8%AA%E5%AF%B9%E8%B1%A1%EF%BC%89/</url>
    <content><![CDATA[<h2 id="创建一个对象的流程"><a href="#创建一个对象的流程" class="headerlink" title="创建一个对象的流程"></a>创建一个对象的流程</h2><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://bb3e216f.onedrive-cf-index-ng-e34.pages.dev/api/raw?path=/Public/BlogImg/JVM/%E5%AF%B9%E8%B1%A1%E5%88%9B%E5%BB%BA%20%E6%B5%81%E7%A8%8B.png"
                      alt="对象创建 流程.jpg"
                ></p>
<p>这边着重讲几个东西</p>
<p>一个对象在创建前就已经知道会占用多大的空间</p>
<h2 id="关于分配内存时候的并发问题"><a href="#关于分配内存时候的并发问题" class="headerlink" title="关于分配内存时候的并发问题"></a>关于分配内存时候的并发问题</h2><p>关于分配内存的并发问题，需要从垃圾回收器等方面考虑</p>
<p>首先先介绍两个概念，<strong>指针碰撞与空闲列表</strong></p>
<p>假如我们的回收算法，在回收对象的时候还会有整理的功能，那么我们对中的内存始终是一块未使用，一块已使用的。然后他们中间放着一个指针作为分界点。每次分配空间就是将指针往空闲空间挪动指定大小</p>
<p>但是有些垃圾回收器并不会去做整理，此时就会产生很多不连续的空闲内存空间。对于这种，虚拟机就需要维护一个列表，来记录那些空闲空间。然后在分配对象需要申请空间的时候，就会去空闲列表上找出足够大的空间分配给对象实例</p>
<p>对应的一些使用场景</p>
<p>以Serial、ParNew等带有压缩整理过程的收集器，系统采用的是指针碰撞，即简单又高效</p>
<p>对于CMS这种基于清除（Sweep）算法的收集器，需要空闲列表来分配内存</p>
<p>说完了分配空间，回到一开始并发问题。分配空间是的并发问题指的是：</p>
<p>线程A在给对象A分配内存时，还未来得及将指针指向内存空间，此时线程B进来给对象B分配内存，重复使用了这块内存空间。</p>
<p>对此，虚拟机有两种方式解决：</p>
<ul>
<li>CAS+失败重试</li>
<li>把内存分配的操作按照线程划分在不同的空间上进行（即每个线程在Java堆中实现分配一小块内存 本地线程分配缓冲） TLAB<ul>
<li>会将赋零值的操作在这一步就完成</li>
</ul>
</li>
</ul>
<h2 id="句柄访问，直接指针的优缺点在哪里"><a href="#句柄访问，直接指针的优缺点在哪里" class="headerlink" title="句柄访问，直接指针的优缺点在哪里"></a>句柄访问，直接指针的优缺点在哪里</h2><p>句柄访问：Java堆中会额外划分出一块内存作为句柄池，reference中存储的就是对象的句柄地址，句柄中包括了对象实例数据与类型数据格子具体的地址信息</p>
<p>优点：因为垃圾回收时移动对象是一个很普遍的行为，在移动对象时我们只需要改变句柄中的实例数据的指针，不需要逐个修改reference</p>
<p>但是访问时会多加一次句柄池的访问，效率会较直接指针低一点</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://bb3e216f.onedrive-cf-index-ng-e34.pages.dev/api/raw?path=/Public/BlogImg/JVM/%E5%AF%B9%E8%B1%A1%E5%88%9B%E5%BB%BA%20%E9%80%9A%E8%BF%87%E5%8F%A5%E6%9F%84%E8%AE%BF%E9%97%AE%E5%AF%B9%E8%B1%A1.png"
                      alt="对象创建 通过句柄访问对象.png"
                ></p>
<p>直接指针：堆中对象实例数据会保留对象类型数据的地址信息</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://bb3e216f.onedrive-cf-index-ng-e34.pages.dev/api/raw?path=/Public/BlogImg/JVM/%E5%AF%B9%E8%B1%A1%E5%88%9B%E5%BB%BA%20%E7%9B%B4%E6%8E%A5%E9%93%BE%E6%8E%A5%E5%AF%B9%E8%B1%A1.png"
                      alt="对象创建 直接链接对象.png"
                ></p>
<h2 id="对象头"><a href="#对象头" class="headerlink" title="对象头"></a>对象头</h2><p>对象在堆内存中存储布局分为三个部分：对象头、实例数据、对齐填充</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://bb3e216f.onedrive-cf-index-ng-e34.pages.dev/api/raw?path=/Public/BlogImg/JVM/%E5%AF%B9%E8%B1%A1%E5%88%9B%E5%BB%BA%20%E5%AF%B9%E8%B1%A1%E5%A4%B4.png"
                      alt="对象创建 对象头.png"
                ></p>

<div id="gitalk-container"></div>
<script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

		<script>
		var gitalkConfig = {"clientID":"26b8e6758f16d4524e69","clientSecret":"ecfd9e9a439bcb8a4c4fd21f4677fa102c68b352","repo":"beastmouth.github.io","owner":"beastmouth","admin":["beastmouth"],"distractionFreeMode":false,"createIssueManually":true};
	    gitalkConfig.id = md5(location.pathname);
		var gitalk = new Gitalk(gitalkConfig);
	    gitalk.render("gitalk-container");
	    </script>]]></content>
      <categories>
        <category>JVM</category>
      </categories>
  </entry>
  <entry>
    <title>慢SQL语句执行分析</title>
    <url>/2023/10/24/%E6%85%A2SQL%E8%AF%AD%E5%8F%A5%E6%89%A7%E8%A1%8C%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<p>案例中的两张表</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `tradelog` (</span><br><span class="line">  `id` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `tradeid` <span class="type">varchar</span>(<span class="number">32</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `operator` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `t_modified` datetime <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`id`),</span><br><span class="line">  KEY `tradeid` (`tradeid`),</span><br><span class="line">  KEY `t_modified` (`t_modified`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8mb4;</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `trade_detail` (</span><br><span class="line">  `id` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `tradeid` <span class="type">varchar</span>(<span class="number">32</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `trade_step` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>, <span class="comment">/*操作步骤*/</span></span><br><span class="line">  `step_info` <span class="type">varchar</span>(<span class="number">32</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>, <span class="comment">/*步骤信息*/</span></span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`id`),</span><br><span class="line">  KEY `tradeid` (`tradeid`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8;</span><br><span class="line"></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> tradelog <span class="keyword">values</span>(<span class="number">1</span>, <span class="string">&#x27;aaaaaaaa&#x27;</span>, <span class="number">1000</span>, now());</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> tradelog <span class="keyword">values</span>(<span class="number">2</span>, <span class="string">&#x27;aaaaaaab&#x27;</span>, <span class="number">1000</span>, now());</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> tradelog <span class="keyword">values</span>(<span class="number">3</span>, <span class="string">&#x27;aaaaaaac&#x27;</span>, <span class="number">1000</span>, now());</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> trade_detail <span class="keyword">values</span>(<span class="number">1</span>, <span class="string">&#x27;aaaaaaaa&#x27;</span>, <span class="number">1</span>, <span class="string">&#x27;add&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> trade_detail <span class="keyword">values</span>(<span class="number">2</span>, <span class="string">&#x27;aaaaaaaa&#x27;</span>, <span class="number">2</span>, <span class="string">&#x27;update&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> trade_detail <span class="keyword">values</span>(<span class="number">3</span>, <span class="string">&#x27;aaaaaaaa&#x27;</span>, <span class="number">3</span>, <span class="string">&#x27;commit&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> trade_detail <span class="keyword">values</span>(<span class="number">4</span>, <span class="string">&#x27;aaaaaaab&#x27;</span>, <span class="number">1</span>, <span class="string">&#x27;add&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> trade_detail <span class="keyword">values</span>(<span class="number">5</span>, <span class="string">&#x27;aaaaaaab&#x27;</span>, <span class="number">2</span>, <span class="string">&#x27;update&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> trade_detail <span class="keyword">values</span>(<span class="number">6</span>, <span class="string">&#x27;aaaaaaab&#x27;</span>, <span class="number">3</span>, <span class="string">&#x27;update again&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> trade_detail <span class="keyword">values</span>(<span class="number">7</span>, <span class="string">&#x27;aaaaaaab&#x27;</span>, <span class="number">4</span>, <span class="string">&#x27;commit&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> trade_detail <span class="keyword">values</span>(<span class="number">8</span>, <span class="string">&#x27;aaaaaaac&#x27;</span>, <span class="number">1</span>, <span class="string">&#x27;add&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> trade_detail <span class="keyword">values</span>(<span class="number">9</span>, <span class="string">&#x27;aaaaaaac&#x27;</span>, <span class="number">2</span>, <span class="string">&#x27;update&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> trade_detail <span class="keyword">values</span>(<span class="number">10</span>, <span class="string">&#x27;aaaaaaac&#x27;</span>, <span class="number">3</span>, <span class="string">&#x27;update again&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> trade_detail <span class="keyword">values</span>(<span class="number">11</span>, <span class="string">&#x27;aaaaaaac&#x27;</span>, <span class="number">4</span>, <span class="string">&#x27;commit&#x27;</span>);</span><br></pre></td></tr></table></figure>
<h1 id="条件字段函数操作"><a href="#条件字段函数操作" class="headerlink" title="条件字段函数操作"></a>条件字段函数操作</h1><p>使用上索引但还是执行很慢</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 命中索引，但走全索引扫描</span></span><br><span class="line"><span class="keyword">select</span> <span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">from</span> tradelog <span class="keyword">where</span> <span class="keyword">month</span>(t_modified) <span class="operator">=</span> <span class="number">7</span>;</span><br></pre></td></tr></table></figure>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://bb3e216f.onedrive-cf-index-ng-e34.pages.dev/api/raw?path=/Public/BlogImg/MySQL/%E6%9D%A1%E4%BB%B6%E5%AD%97%E6%AE%B5%E5%87%BD%E6%95%B0%E6%93%8D%E4%BD%9C-1.png"
                      alt="image.png"
                ><br>优化器权衡后依然选择了走索引（t_modified），但是这个索引没有办法通过树搜索功能快速定位，只能全索引扫描(遍历索引树)。无法利用树搜索【原因：在树的根节点就不知道要前往哪个子节点，所以只能全量遍历叶子节点】<br>正确写法</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 命中索引</span></span><br><span class="line"><span class="keyword">select</span> <span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">from</span> tradelog <span class="keyword">where</span> (t_modified <span class="operator">&gt;=</span> <span class="string">&#x27;2016-7-1&#x27;</span> <span class="keyword">and</span> t_modified<span class="operator">&lt;</span><span class="string">&#x27;2016-8-1&#x27;</span>) <span class="keyword">or</span> (t_modified <span class="operator">&gt;=</span> <span class="string">&#x27;2017-7-1&#x27;</span> <span class="keyword">and</span> t_modified<span class="operator">&lt;</span><span class="string">&#x27;2017-8-1&#x27;</span>) <span class="keyword">or</span> (t_modified <span class="operator">&gt;=</span> <span class="string">&#x27;2018-7-1&#x27;</span> <span class="keyword">and</span> t_modified<span class="operator">&lt;</span><span class="string">&#x27;2018-8-1&#x27;</span>);</span><br></pre></td></tr></table></figure>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://bb3e216f.onedrive-cf-index-ng-e34.pages.dev/api/raw?path=/Public/BlogImg/MySQL/%E6%9D%A1%E4%BB%B6%E5%AD%97%E6%AE%B5%E5%87%BD%E6%95%B0%E6%93%8D%E4%BD%9C-2.png"
                      alt="image.png"
                ><br>使用索引且利用上树搜索</p>
<h1 id="隐式类型转换"><a href="#隐式类型转换" class="headerlink" title="隐式类型转换"></a>隐式类型转换</h1><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- tradeid为varchar类型，入参为int类型</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tradelog <span class="keyword">where</span> tradeid <span class="operator">=</span> <span class="number">110717</span>;</span><br><span class="line"><span class="comment">-- 等价于以下sql，放弃使用索引，遍历全表</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tradelog <span class="keyword">where</span> <span class="built_in">CAST</span>(tradid <span class="keyword">AS</span> signed <span class="type">int</span>) <span class="operator">=</span> <span class="number">110717</span>;</span><br></pre></td></tr></table></figure>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://bb3e216f.onedrive-cf-index-ng-e34.pages.dev/api/raw?path=/Public/BlogImg/MySQL/%E9%9A%90%E5%BC%8F%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2-1.png"
                      alt="image.png"
                ><br>因为tradeid为varchar类型，而我们的入参是int类型，此时会做一个字符串类型转换的操作<br>那么varchar类型和int类型匹配时，他们的转换规则是什么呢？【结论：字符串和数字做比较的话，是将字符串转换成数字】</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> &quot;10&quot; <span class="operator">&gt;</span> <span class="number">9</span>;</span><br></pre></td></tr></table></figure>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://bb3e216f.onedrive-cf-index-ng-e34.pages.dev/api/raw?path=/Public/BlogImg/MySQL/%E9%9A%90%E5%BC%8F%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2-2.png"
                      alt="image.png"
                ><br>那么，当类型转换发生在参数上的时候，又会命中索引</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tradelog <span class="keyword">where</span> id <span class="operator">=</span> &quot;1&quot;;</span><br><span class="line"><span class="comment">-- 等价于</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tradelog <span class="keyword">where</span> id <span class="operator">=</span> <span class="built_in">CAST</span>(&quot;1&quot; <span class="keyword">AS</span> signed <span class="type">int</span>);</span><br></pre></td></tr></table></figure>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://bb3e216f.onedrive-cf-index-ng-e34.pages.dev/api/raw?path=/Public/BlogImg/MySQL/%E9%9A%90%E5%BC%8F%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2-3.png"
                      alt="image.png"
                ><br>补充一个情况，假如我们的字符串中含有不能转换为int的内容，此时会如何转换</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="built_in">CAST</span>(&quot;10a&quot; <span class="keyword">AS</span> UNSIGNED <span class="type">INT</span>); 		<span class="comment">-- 结果是10</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">CAST</span>(<span class="string">&#x27;10a1&#x27;</span> <span class="keyword">AS</span> UNSIGNED <span class="type">INT</span>); 		<span class="comment">-- 结果是10</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">CAST</span>(<span class="string">&#x27;a10a1&#x27;</span> <span class="keyword">AS</span> UNSIGNED <span class="type">INT</span>);		<span class="comment">-- 结果是0</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">CAST</span>(<span class="string">&#x27;01a10&#x27;</span> <span class="keyword">AS</span> UNSIGNED <span class="type">INT</span>);		<span class="comment">-- 结果是1</span></span><br></pre></td></tr></table></figure>
<p>字符串转数字是从最左侧开始识别数字,直到碰到不是数字或者到最后截止,将识别出来是数字的字符串转为数字<br>再补充一个sql注入的例子</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tradelog <span class="keyword">where</span> tradeid <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="comment">-- 遇到不能转换被丢弃的数据时, 等价于 0 = 0 =&gt; true</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tradelog <span class="keyword">where</span> <span class="number">0</span> <span class="operator">=</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://bb3e216f.onedrive-cf-index-ng-e34.pages.dev/api/raw?path=/Public/BlogImg/MySQL/%E9%9A%90%E5%BC%8F%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2-4.png"
                      alt="image.png"
                ></p>
<h1 id="隐式字符编码转换"><a href="#隐式字符编码转换" class="headerlink" title="隐式字符编码转换"></a>隐式字符编码转换</h1><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> d.<span class="operator">*</span> <span class="keyword">from</span> tradelog l, trade_detail d <span class="keyword">where</span> d.tradeid<span class="operator">=</span>l.tradeid <span class="keyword">and</span> l.id<span class="operator">=</span><span class="number">2</span>;</span><br><span class="line"><span class="comment">-- 等价于 原因：utf8mb4 是 utf8 的超集，此处会进行编码转换【被驱动表进行编码转换】</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> trade_detail  <span class="keyword">where</span> <span class="keyword">CONVERT</span>(traideid <span class="keyword">USING</span> utf8mb4)<span class="operator">=</span>$L2.tradeid.value; </span><br></pre></td></tr></table></figure>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://bb3e216f.onedrive-cf-index-ng-e34.pages.dev/api/raw?path=/Public/BlogImg/MySQL/%E9%9A%90%E5%BC%8F%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81%E8%BD%AC%E6%8D%A2-1.png"
                      alt="image.png"
                ></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">explain <span class="keyword">select</span> l.operator <span class="keyword">from</span> tradelog l , trade_detail d <span class="keyword">where</span> d.tradeid<span class="operator">=</span>l.tradeid <span class="keyword">and</span> d.id<span class="operator">=</span><span class="number">4</span>;</span><br><span class="line"><span class="comment">-- 此时被驱动表为tradelog，tradelog是在入参做编码转换，可以使用上索引</span></span><br><span class="line"><span class="comment">-- 等价于</span></span><br><span class="line"><span class="keyword">select</span> operator <span class="keyword">from</span> tradelog  <span class="keyword">where</span> traideid <span class="operator">=</span><span class="keyword">CONVERT</span>($R4.tradeid.value <span class="keyword">USING</span> utf8mb4); </span><br></pre></td></tr></table></figure>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://bb3e216f.onedrive-cf-index-ng-e34.pages.dev/api/raw?path=/Public/BlogImg/MySQL/%E9%9A%90%E5%BC%8F%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81%E8%BD%AC%E6%8D%A2-2.png"
                      alt="image.png"
                ></p>
<p>写在最后，1024节日快乐！</p>

<div id="gitalk-container"></div>
<script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

		<script>
		var gitalkConfig = {"clientID":"26b8e6758f16d4524e69","clientSecret":"ecfd9e9a439bcb8a4c4fd21f4677fa102c68b352","repo":"beastmouth.github.io","owner":"beastmouth","admin":["beastmouth"],"distractionFreeMode":false,"createIssueManually":true};
	    gitalkConfig.id = md5(location.pathname);
		var gitalk = new Gitalk(gitalkConfig);
	    gitalk.render("gitalk-container");
	    </script>]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
  </entry>
  <entry>
    <title>批量删除Redis集群的数据</title>
    <url>/2023/10/26/%E6%89%B9%E9%87%8F%E5%88%A0%E9%99%A4Redis%E9%9B%86%E7%BE%A4%E7%9A%84%E6%95%B0%E6%8D%AE/</url>
    <content><![CDATA[<p>问题：Redis集群存在多节点问题，不同的数据存在不同的上，所以我们一次操作无法同时操作多个节点hash槽里面的数据。<br>下面分享几个常见的解决方案。但是他们的解决方案都是大同小异的，都是逐个操作每个键</p>
<h1 id="Redisson"><a href="#Redisson" class="headerlink" title="Redisson"></a>Redisson</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> &lt;T, R&gt; <span class="function">RFuture&lt;R&gt; <span class="title">executeBatchedAsync</span><span class="params">(<span class="keyword">boolean</span> readOnly, Codec codec, RedisCommand&lt;T&gt; command, SlotCallback&lt;T, R&gt; callback, String... keys)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 连接模式非集群模式</span></span><br><span class="line">    <span class="keyword">if</span> (!connectionManager.isClusterMode()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (readOnly) &#123;</span><br><span class="line">            <span class="keyword">return</span> readAsync((String) <span class="keyword">null</span>, codec, command, keys);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> writeAsync((String) <span class="keyword">null</span>, codec, command, keys);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Map&lt;MasterSlaveEntry, List&lt;String&gt;&gt; range2key = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (String key : keys) &#123;</span><br><span class="line">        <span class="keyword">int</span> slot = connectionManager.calcSlot(key);</span><br><span class="line">        MasterSlaveEntry entry = connectionManager.getEntry(slot);</span><br><span class="line">        <span class="comment">// 构建一个集群节点的map=》后续对集群节点逐个操作</span></span><br><span class="line">        List&lt;String&gt; list = range2key.computeIfAbsent(entry, k -&gt; <span class="keyword">new</span> ArrayList&lt;&gt;());</span><br><span class="line">        list.add(key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    RPromise&lt;R&gt; result = <span class="keyword">new</span> RedissonPromise&lt;&gt;();</span><br><span class="line">    AtomicLong executed = <span class="keyword">new</span> AtomicLong(keys.length);</span><br><span class="line">    AtomicReference&lt;Throwable&gt; failed = <span class="keyword">new</span> AtomicReference&lt;&gt;();</span><br><span class="line">    BiConsumer&lt;T, Throwable&gt; listener = (res, ex) -&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span> (ex != <span class="keyword">null</span>) &#123;</span><br><span class="line">            failed.set(ex);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (res != <span class="keyword">null</span>) &#123;</span><br><span class="line">                callback.onSlotResult(res);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (executed.decrementAndGet() == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (failed.get() != <span class="keyword">null</span>) &#123;</span><br><span class="line">                result.tryFailure(failed.get());</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                result.trySuccess(callback.onFinish());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (Entry&lt;MasterSlaveEntry, List&lt;String&gt;&gt; entry : range2key.entrySet()) &#123;</span><br><span class="line">        <span class="comment">// executes in batch due to CROSSLOT error</span></span><br><span class="line">        CommandBatchService executorService;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> <span class="keyword">instanceof</span> CommandBatchService) &#123;</span><br><span class="line">            executorService = (CommandBatchService) <span class="keyword">this</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            executorService = <span class="keyword">new</span> CommandBatchService(connectionManager);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (String key : entry.getValue()) &#123;</span><br><span class="line">            RedisCommand&lt;T&gt; c = command;</span><br><span class="line">            RedisCommand&lt;T&gt; newCommand = callback.createCommand(key);</span><br><span class="line">            <span class="keyword">if</span> (newCommand != <span class="keyword">null</span>) &#123;</span><br><span class="line">                c = newCommand;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 对集群节点逐个操作</span></span><br><span class="line">            <span class="keyword">if</span> (readOnly) &#123;</span><br><span class="line">                RFuture&lt;T&gt; f = executorService.readAsync(entry.getKey(), codec, c, key);</span><br><span class="line">                f.onComplete(listener);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                RFuture&lt;T&gt; f = executorService.writeAsync(entry.getKey(), codec, c, key);</span><br><span class="line">                f.onComplete(listener);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!(<span class="keyword">this</span> <span class="keyword">instanceof</span> CommandBatchService)) &#123;</span><br><span class="line">            executorService.executeAsync();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h1 id="SpringBoot原生Lettuce"><a href="#SpringBoot原生Lettuce" class="headerlink" title="SpringBoot原生Lettuce"></a>SpringBoot原生Lettuce</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Long <span class="title">del</span><span class="params">(<span class="keyword">byte</span>[]... keys)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    Assert.notNull(keys, <span class="string">&quot;Keys must not be null!&quot;</span>);</span><br><span class="line">    Assert.noNullElements(keys, <span class="string">&quot;Keys must not contain null elements!&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (isPipelined()) &#123;</span><br><span class="line">            pipeline(connection.newLettuceResult(getAsyncConnection().del(keys)));</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (isQueueing()) &#123;</span><br><span class="line">            transaction(connection.newLettuceResult(getAsyncConnection().del(keys)));</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> getConnection().del(keys);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">        <span class="keyword">throw</span> convertLettuceAccessException(ex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Delete a key with pipelining. Cross-slot keys will result in multiple calls to the particular cluster nodes.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> keys the key.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> RedisFuture&amp;lt;Long&amp;gt; integer-reply The number of keys that were removed.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">RedisFuture&lt;Long&gt; <span class="title">del</span><span class="params">(K... keys)</span></span>;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> RedisFuture&lt;Long&gt; <span class="title">del</span><span class="params">(Iterable&lt;K&gt; keys)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取hash槽=》判断涉及到的集群节点的个数</span></span><br><span class="line">    Map&lt;Integer, List&lt;K&gt;&gt; partitioned = SlotHash.partition(codec, keys);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 同一个节点</span></span><br><span class="line">    <span class="keyword">if</span> (partitioned.size() &lt; <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.del(keys);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Map&lt;Integer, RedisFuture&lt;Long&gt;&gt; executions = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 不同节点，逐个处理</span></span><br><span class="line">    <span class="keyword">for</span> (Map.Entry&lt;Integer, List&lt;K&gt;&gt; entry : partitioned.entrySet()) &#123;</span><br><span class="line">        RedisFuture&lt;Long&gt; del = <span class="keyword">super</span>.del(entry.getValue());</span><br><span class="line">        executions.put(entry.getKey(), del);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> MultiNodeExecution.aggregateAsync(executions);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="Jedis"><a href="#Jedis" class="headerlink" title="Jedis"></a>Jedis</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Long <span class="title">del</span><span class="params">(<span class="keyword">byte</span>[]... keys)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    Assert.notNull(keys, <span class="string">&quot;Keys must not be null!&quot;</span>);</span><br><span class="line">    Assert.noNullElements(keys, <span class="string">&quot;Keys must not contain null elements!&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 同一个节点上的</span></span><br><span class="line">    <span class="keyword">if</span> (ClusterSlotHashUtil.isSameSlotForAllKeys(keys)) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> connection.getCluster().del(keys);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">            <span class="keyword">throw</span> convertJedisAccessException(ex);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 不同节点</span></span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">long</span>) connection.getClusterCommandExecutor()</span><br><span class="line">            .executeMultiKeyCommand((JedisMultiKeyClusterCommandCallback&lt;Long&gt;) (client, key) -&gt; client.del(key),</span><br><span class="line">                                    Arrays.asList(keys))</span><br><span class="line">            .resultsAsList().size();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isSameSlotForAllKeys</span><span class="params">(<span class="keyword">byte</span>[]... keys)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    Assert.notNull(keys, <span class="string">&quot;Keys must not be null!&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (keys.length &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> slot = calculateSlot(keys[<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; keys.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (slot != calculateSlot(keys[i])) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<div id="gitalk-container"></div>
<script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

		<script>
		var gitalkConfig = {"clientID":"26b8e6758f16d4524e69","clientSecret":"ecfd9e9a439bcb8a4c4fd21f4677fa102c68b352","repo":"beastmouth.github.io","owner":"beastmouth","admin":["beastmouth"],"distractionFreeMode":false,"createIssueManually":true};
	    gitalkConfig.id = md5(location.pathname);
		var gitalk = new Gitalk(gitalkConfig);
	    gitalk.render("gitalk-container");
	    </script>]]></content>
      <categories>
        <category>Redis</category>
      </categories>
  </entry>
  <entry>
    <title>时间轮</title>
    <url>/2022/01/13/%E6%97%B6%E9%97%B4%E8%BD%AE/</url>
    <content><![CDATA[<h2 id="工作流程图"><a href="#工作流程图" class="headerlink" title="工作流程图"></a>工作流程图</h2><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://bb3e216f.onedrive-cf-index-ng-e34.pages.dev/api/raw?path=/Public/BlogImg/Netty/%E6%97%B6%E9%97%B4%E8%BD%AE%20NettyHashedWheelTimer%E6%B5%81%E7%A8%8B%E5%9B%BE.png"
                      alt="时间轮 NettyHashedWheelTimer流程图.jpg"
                ></p>
<p>由于netty动辄管理100w+的连接，每一个连接都会有很多超时任务。比如发送超时、心跳检测间隔等，如果每一个定时任务都启动一个<code>Timer</code>,不仅低效，而且会消耗大量的资源。</p>
<h2 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashedWheelTimer</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        ThreadFactory threadFactory,</span></span></span><br><span class="line"><span class="params"><span class="function">				// tickDuration 每一次指针持续时间</span></span></span><br><span class="line"><span class="params"><span class="function">				// ticksPerWheel 时间格的个数</span></span></span><br><span class="line"><span class="params"><span class="function">				// leakDetection 泄漏检测</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="keyword">long</span> tickDuration, TimeUnit unit, <span class="keyword">int</span> ticksPerWheel, <span class="keyword">boolean</span> leakDetection,</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="keyword">long</span> maxPendingTimeouts)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (threadFactory == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">&quot;threadFactory&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (unit == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">&quot;unit&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (tickDuration &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;tickDuration must be greater than 0: &quot;</span> + tickDuration);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (ticksPerWheel &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;ticksPerWheel must be greater than 0: &quot;</span> + ticksPerWheel);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Normalize ticksPerWheel to power of two and initialize the wheel.</span></span><br><span class="line">wheel =createWheel(ticksPerWheel);</span><br><span class="line">    mask = wheel.length - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Convert tickDuration to nanos.</span></span><br><span class="line"><span class="keyword">long</span> duration = unit.toNanos(tickDuration);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Prevent overflow.</span></span><br><span class="line"><span class="keyword">if</span> (duration &gt;= Long.MAX_VALUE / wheel.length) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(String.format(</span><br><span class="line">                <span class="string">&quot;tickDuration: %d (expected: 0 &lt; tickDuration in nanos &lt; %d&quot;</span>,</span><br><span class="line">                tickDuration, Long.MAX_VALUE / wheel.length));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (duration &lt; MILLISECOND_NANOS) &#123;</span><br><span class="line">        logger.warn(<span class="string">&quot;Configured tickDuration &#123;&#125; smaller then &#123;&#125;, using 1ms.&quot;</span>,</span><br><span class="line">                    tickDuration, MILLISECOND_NANOS);</span><br><span class="line">        <span class="keyword">this</span>.tickDuration = MILLISECOND_NANOS;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.tickDuration = duration;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    workerThread = threadFactory.newThread(worker);</span><br><span class="line"></span><br><span class="line">    leak = leakDetection || !workerThread.isDaemon() ? leakDetector.track(<span class="keyword">this</span>) : <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.maxPendingTimeouts = maxPendingTimeouts;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (INSTANCE_COUNTER.incrementAndGet() &gt; INSTANCE_COUNT_LIMIT &amp;&amp;</span><br><span class="line">        WARNED_TOO_MANY_INSTANCES.compareAndSet(<span class="keyword">false</span>, <span class="keyword">true</span>)) &#123;</span><br><span class="line">reportTooManyInstances();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 时间格</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> HashedWheelTimer.HashedWheelBucket[] createWheel(<span class="keyword">int</span> ticksPerWheel) &#123;</span><br><span class="line">    <span class="keyword">if</span> (ticksPerWheel &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;ticksPerWheel must be greater than 0: &quot;</span> + ticksPerWheel);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ticksPerWheel &gt; <span class="number">1073741824</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;ticksPerWheel may not be greater than 2^30: &quot;</span> + ticksPerWheel);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        ticksPerWheel = normalizeTicksPerWheel(ticksPerWheel);</span><br><span class="line">        HashedWheelTimer.HashedWheelBucket[] wheel = <span class="keyword">new</span> HashedWheelTimer.HashedWheelBucket[ticksPerWheel];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; wheel.length; ++i) &#123;</span><br><span class="line">						<span class="comment">// 每个时间格一条队列</span></span><br><span class="line">            wheel[i] = <span class="keyword">new</span> HashedWheelTimer.HashedWheelBucket();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> wheel;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="HashedWheelTimer源码之启动"><a href="#HashedWheelTimer源码之启动" class="headerlink" title="HashedWheelTimer源码之启动"></a><strong>HashedWheelTimer源码之</strong>启动</h2><p>不需要显示调用，添加任务时会自动执行</p>
<p>没有任务却启动时间轮，也是在空耗资源</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">// 判断当前时间轮的状态</span></span><br><span class="line">		<span class="comment">// 这里是一个Lock Free的设计。因为可能有多个线程调用启动方法，这里使用AtomicIntegerFieldUpdater原子的更新时间轮的状态</span></span><br><span class="line">    <span class="keyword">switch</span>(WORKER_STATE_UPDATER.get(<span class="keyword">this</span>)) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">if</span> (WORKER_STATE_UPDATER.compareAndSet(<span class="keyword">this</span>, <span class="number">0</span>, <span class="number">1</span>)) &#123;</span><br><span class="line">            <span class="keyword">this</span>.workerThread.start();</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;cannot be started once stopped&quot;</span>);</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">&quot;Invalid WorkerState&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 等待worker线程初始化时间轮的启动时间</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="keyword">this</span>.startTime == <span class="number">0L</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">this</span>.startTimeInitialized.await();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException var2) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="HashedWheelTimer源码之停止"><a href="#HashedWheelTimer源码之停止" class="headerlink" title="HashedWheelTimer源码之停止"></a><strong>HashedWheelTimer源码之</strong>停止</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Set&lt;Timeout&gt; <span class="title">stop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">// worker线程不能停止时间轮</span></span><br><span class="line">  <span class="keyword">if</span> (Thread.currentThread() == workerThread) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(</span><br><span class="line">              HashedWheelTimer.class.getSimpleName() +</span><br><span class="line">                      <span class="string">&quot;.stop() cannot be called from &quot;</span> +</span><br><span class="line">                      TimerTask.class.getSimpleName());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// CAS 替换状态为2:停止</span></span><br><span class="line">  <span class="keyword">if</span> (!WORKER_STATE_UPDATER.compareAndSet(<span class="keyword">this</span>, WORKER_STATE_STARTED, WORKER_STATE_SHUTDOWN)) &#123;</span><br><span class="line"><span class="comment">// workerState can be 0 or 2 at this moment - let it always be 2.</span></span><br><span class="line"><span class="keyword">if</span> (WORKER_STATE_UPDATER.getAndSet(<span class="keyword">this</span>, WORKER_STATE_SHUTDOWN) != WORKER_STATE_SHUTDOWN) &#123;</span><br><span class="line">          INSTANCE_COUNTER.decrementAndGet();</span><br><span class="line">          <span class="keyword">if</span> (leak != <span class="keyword">null</span>) &#123;</span><br><span class="line">              <span class="keyword">boolean</span> closed = leak.close(<span class="keyword">this</span>);</span><br><span class="line">              <span class="keyword">assert</span> closed;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> Collections.emptySet();</span><br><span class="line">  &#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 终止worker线程</span></span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">boolean</span> interrupted = <span class="keyword">false</span>;</span><br><span class="line">      <span class="keyword">while</span> (workerThread.isAlive()) &#123;</span><br><span class="line">          workerThread.interrupt();</span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">              workerThread.join(<span class="number">100</span>);</span><br><span class="line">          &#125; <span class="keyword">catch</span> (InterruptedException ignored) &#123;</span><br><span class="line">              interrupted = <span class="keyword">true</span>;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (interrupted) &#123;</span><br><span class="line">          Thread.currentThread().interrupt();</span><br><span class="line">      &#125;</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      INSTANCE_COUNTER.decrementAndGet();</span><br><span class="line">      <span class="keyword">if</span> (leak != <span class="keyword">null</span>) &#123;</span><br><span class="line">          <span class="keyword">boolean</span> closed = leak.close(<span class="keyword">this</span>);</span><br><span class="line">          <span class="keyword">assert</span> closed;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">	<span class="comment">// 返回未处理的任务</span></span><br><span class="line">  <span class="keyword">return</span> worker.unprocessedTimeouts();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="HashedWheelTimer源码之添加任务"><a href="#HashedWheelTimer源码之添加任务" class="headerlink" title="HashedWheelTimer源码之添加任务"></a><strong>HashedWheelTimer源码之</strong>添加任务</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Timeout <span class="title">newTimeout</span><span class="params">(TimerTask task, <span class="keyword">long</span> delay, TimeUnit unit)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// 参数校验</span></span><br><span class="line">    <span class="keyword">if</span> (task == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">&quot;task&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (unit == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">&quot;unit&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">long</span> pendingTimeoutsCount = pendingTimeouts.incrementAndGet();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (maxPendingTimeouts &gt; <span class="number">0</span> &amp;&amp; pendingTimeoutsCount &gt; maxPendingTimeouts) &#123;</span><br><span class="line">        pendingTimeouts.decrementAndGet();</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RejectedExecutionException(<span class="string">&quot;Number of pending timeouts (&quot;</span></span><br><span class="line">            + pendingTimeoutsCount + <span class="string">&quot;) is greater than or equal to maximum allowed pending &quot;</span></span><br><span class="line">            + <span class="string">&quot;timeouts (&quot;</span> + maxPendingTimeouts + <span class="string">&quot;)&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 如果时间轮没有启动，则启动</span></span><br><span class="line">    start();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Add the timeout to the timeout queue which will be processed on the next tick.</span></span><br><span class="line">    <span class="comment">// During processing all the queued HashedWheelTimeouts will be added to the correct HashedWheelBucket.</span></span><br><span class="line">		<span class="comment">// 计算deadline</span></span><br><span class="line">    <span class="keyword">long</span> deadline = System.nanoTime() + unit.toNanos(delay) - startTime;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Guard against overflow.</span></span><br><span class="line">    <span class="keyword">if</span> (delay &gt; <span class="number">0</span> &amp;&amp; deadline &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        deadline = Long.MAX_VALUE;</span><br><span class="line">    &#125;</span><br><span class="line">		<span class="comment">// 这里定时任务不是直接加入到对应的格子，而是先加入一个队列里，等到下一个tick的时候</span></span><br><span class="line">		<span class="comment">// 会从队列里取出100000个任务加入到指定的格子里</span></span><br><span class="line">    HashedWheelTimeout timeout = <span class="keyword">new</span> HashedWheelTimeout(<span class="keyword">this</span>, task, deadline);</span><br><span class="line">    timeouts.add(timeout);</span><br><span class="line">    <span class="keyword">return</span> timeout;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里使用的Queue不是普通java自带的Queue的实现，而是使用<a class="link"   href="https://github.com/JCTools/JCTools" >JCTool<i class="fas fa-external-link-alt"></i></a>–一个高性能的的并发Queue实现包。</p>
<h2 id="HashedWheelTimer源码之HashedWheelTimeout（任务）"><a href="#HashedWheelTimer源码之HashedWheelTimeout（任务）" class="headerlink" title="HashedWheelTimer源码之HashedWheelTimeout（任务）"></a><strong>HashedWheelTimer源码之HashedWheelTimeout（任务）</strong></h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">HashedWheelTimeout</span> <span class="keyword">implements</span> <span class="title">Timeout</span> </span>&#123;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">// 定义定时任务的3个状态：初始化、取消、过期</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> ST_INIT = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> ST_CANCELLED = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> ST_EXPIRED = <span class="number">2</span>;</span><br><span class="line">		<span class="comment">// 用来CAS方式更新定时任务状态</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> AtomicIntegerFieldUpdater&lt;HashedWheelTimeout&gt; STATE_UPDATER =</span><br><span class="line">            AtomicIntegerFieldUpdater.newUpdater(HashedWheelTimeout.class, <span class="string">&quot;state&quot;</span>);</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 时间轮引用</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> HashedWheelTimer timer;</span><br><span class="line">		<span class="comment">// 具体到期需要执行的任务</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> TimerTask task;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> deadline;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@SuppressWarnings(&#123;&quot;unused&quot;, &quot;FieldMayBeFinal&quot;, &quot;RedundantFieldInitialization&quot; &#125;)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> state = ST_INIT;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// remainingRounds will be calculated and set by Worker.transferTimeoutsToBuckets() before the</span></span><br><span class="line">    <span class="comment">// HashedWheelTimeout will be added to the correct HashedWheelBucket.</span></span><br><span class="line">		<span class="comment">// 离任务执行的轮数，当将此任务加入到格子中是计算该值，每过一轮，该值减一。</span></span><br><span class="line">    <span class="keyword">long</span> remainingRounds;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// This will be used to chain timeouts in HashedWheelTimerBucket via a double-linked-list.</span></span><br><span class="line">    <span class="comment">// As only the workerThread will act on it there is no need for synchronization / volatile.</span></span><br><span class="line">		<span class="comment">// 双向链表结构，由于只有worker线程会访问，这里不需要synchronization / volatile</span></span><br><span class="line">    HashedWheelTimeout next;</span><br><span class="line">    HashedWheelTimeout prev;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// The bucket to which the timeout was added</span></span><br><span class="line">		<span class="comment">// 定时任务所在的格子</span></span><br><span class="line">    HashedWheelBucket bucket;</span><br><span class="line"></span><br><span class="line">    HashedWheelTimeout(HashedWheelTimer timer, TimerTask task, <span class="keyword">long</span> deadline) &#123;</span><br><span class="line">        <span class="keyword">this</span>.timer = timer;</span><br><span class="line">        <span class="keyword">this</span>.task = task;</span><br><span class="line">        <span class="keyword">this</span>.deadline = deadline;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Timer <span class="title">timer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> timer;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TimerTask <span class="title">task</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> task;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">cancel</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// only update the state it will be removed from HashedWheelBucket on next tick.</span></span><br><span class="line">				<span class="comment">// 这里只是修改状态为ST_CANCELLED，会在下次tick时，在格子中移除</span></span><br><span class="line">        <span class="keyword">if</span> (!compareAndSetState(ST_INIT, ST_CANCELLED)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// If a task should be canceled we put this to another queue which will be processed on each tick.</span></span><br><span class="line">        <span class="comment">// So this means that we will have a GC latency of max. 1 tick duration which is good enough. This way</span></span><br><span class="line">        <span class="comment">// we can make again use of our MpscLinkedQueue and so minimize the locking / overhead as much as possible.</span></span><br><span class="line">				<span class="comment">// 加入到时间轮的待取消队列，并在每次tick的时候，从相应格子中移除。</span></span><br><span class="line">        timer.cancelledTimeouts.add(<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 从格子中移除自身</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        HashedWheelBucket bucket = <span class="keyword">this</span>.bucket;</span><br><span class="line">        <span class="keyword">if</span> (bucket != <span class="keyword">null</span>) &#123;</span><br><span class="line">            bucket.remove(<span class="keyword">this</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            timer.pendingTimeouts.decrementAndGet();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">compareAndSetState</span><span class="params">(<span class="keyword">int</span> expected, <span class="keyword">int</span> state)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> STATE_UPDATER.compareAndSet(<span class="keyword">this</span>, expected, state);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">state</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> state;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isCancelled</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> state() == ST_CANCELLED;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isExpired</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> state() == ST_EXPIRED;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 过期并执行任务</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">expire</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!compareAndSetState(ST_INIT, ST_EXPIRED)) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            task.run(<span class="keyword">this</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">            <span class="keyword">if</span> (logger.isWarnEnabled()) &#123;</span><br><span class="line">                logger.warn(<span class="string">&quot;An exception was thrown by &quot;</span> + TimerTask.class.getSimpleName() + <span class="string">&#x27;.&#x27;</span>, t);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">long</span> currentTime = System.nanoTime();</span><br><span class="line">        <span class="keyword">long</span> remaining = deadline - currentTime + timer.startTime;</span><br><span class="line"></span><br><span class="line">        StringBuilder buf = <span class="keyword">new</span> StringBuilder(<span class="number">192</span>)</span><br><span class="line">           .append(simpleClassName(<span class="keyword">this</span>))</span><br><span class="line">           .append(<span class="string">&#x27;(&#x27;</span>)</span><br><span class="line">           .append(<span class="string">&quot;deadline: &quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (remaining &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            buf.append(remaining)</span><br><span class="line">               .append(<span class="string">&quot; ns later&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (remaining &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            buf.append(-remaining)</span><br><span class="line">               .append(<span class="string">&quot; ns ago&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            buf.append(<span class="string">&quot;now&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (isCancelled()) &#123;</span><br><span class="line">            buf.append(<span class="string">&quot;, cancelled&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> buf.append(<span class="string">&quot;, task: &quot;</span>)</span><br><span class="line">                  .append(task())</span><br><span class="line">                  .append(<span class="string">&#x27;)&#x27;</span>)</span><br><span class="line">                  .toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="HashedWheelTimer源码之HashedWheelBucket"><a href="#HashedWheelTimer源码之HashedWheelBucket" class="headerlink" title="HashedWheelTimer源码之HashedWheelBucket"></a><strong>HashedWheelTimer源码之HashedWheelBucket</strong></h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">HashedWheelBucket</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Used for the linked-list datastructure</span></span><br><span class="line">		<span class="comment">// 指向格子中任务的首尾</span></span><br><span class="line">    <span class="keyword">private</span> HashedWheelTimeout head;</span><br><span class="line">    <span class="keyword">private</span> HashedWheelTimeout tail;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Add &#123;<span class="doctag">@link</span> HashedWheelTimeout&#125; to this bucket.</span></span><br><span class="line"><span class="comment">		 * 基础的链表添加操作</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addTimeout</span><span class="params">(HashedWheelTimeout timeout)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">assert</span> timeout.bucket == <span class="keyword">null</span>;</span><br><span class="line">        timeout.bucket = <span class="keyword">this</span>;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="keyword">null</span>) &#123;</span><br><span class="line">            head = tail = timeout;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            tail.next = timeout;</span><br><span class="line">            timeout.prev = tail;</span><br><span class="line">            tail = timeout;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Expire all &#123;<span class="doctag">@link</span> HashedWheelTimeout&#125;s for the given &#123;<span class="doctag">@code</span> deadline&#125;.</span></span><br><span class="line"><span class="comment">		 * 过期并执行格子中的到期任务，tick到该格子的时候，worker线程会调用这个方法，根据deadline和remainingRounds判断任务是否过期</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">expireTimeouts</span><span class="params">(<span class="keyword">long</span> deadline)</span> </span>&#123;</span><br><span class="line">        HashedWheelTimeout timeout = head;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// process all timeouts</span></span><br><span class="line">				<span class="comment">// 遍历</span></span><br><span class="line">        <span class="keyword">while</span> (timeout != <span class="keyword">null</span>) &#123;</span><br><span class="line">            HashedWheelTimeout next = timeout.next;</span><br><span class="line">            <span class="keyword">if</span> (timeout.remainingRounds &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                next = remove(timeout);</span><br><span class="line">                <span class="keyword">if</span> (timeout.deadline &lt;= deadline) &#123;</span><br><span class="line">                    timeout.expire();</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// The timeout was placed into a wrong slot. This should never happen.</span></span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(String.format(</span><br><span class="line">                            <span class="string">&quot;timeout.deadline (%d) &gt; deadline (%d)&quot;</span>, timeout.deadline, deadline));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (timeout.isCancelled()) &#123;</span><br><span class="line">                next = remove(timeout);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                timeout.remainingRounds --;</span><br><span class="line">            &#125;</span><br><span class="line">            timeout = next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> HashedWheelTimeout <span class="title">remove</span><span class="params">(HashedWheelTimeout timeout)</span> </span>&#123;</span><br><span class="line">        HashedWheelTimeout next = timeout.next;</span><br><span class="line">        <span class="comment">// remove timeout that was either processed or cancelled by updating the linked-list</span></span><br><span class="line">        <span class="keyword">if</span> (timeout.prev != <span class="keyword">null</span>) &#123;</span><br><span class="line">            timeout.prev.next = next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (timeout.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">            timeout.next.prev = timeout.prev;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (timeout == head) &#123;</span><br><span class="line">            <span class="comment">// if timeout is also the tail we need to adjust the entry too</span></span><br><span class="line">            <span class="keyword">if</span> (timeout == tail) &#123;</span><br><span class="line">                tail = <span class="keyword">null</span>;</span><br><span class="line">                head = <span class="keyword">null</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                head = next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (timeout == tail) &#123;</span><br><span class="line">            <span class="comment">// if the timeout is the tail modify the tail to be the prev node.</span></span><br><span class="line">            tail = timeout.prev;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// null out prev, next and bucket to allow for GC.</span></span><br><span class="line">        timeout.prev = <span class="keyword">null</span>;</span><br><span class="line">        timeout.next = <span class="keyword">null</span>;</span><br><span class="line">        timeout.bucket = <span class="keyword">null</span>;</span><br><span class="line">        timeout.timer.pendingTimeouts.decrementAndGet();</span><br><span class="line">        <span class="keyword">return</span> next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Clear this bucket and return all not expired / cancelled &#123;<span class="doctag">@link</span> Timeout&#125;s.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clearTimeouts</span><span class="params">(Set&lt;Timeout&gt; set)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            HashedWheelTimeout timeout = pollTimeout();</span><br><span class="line">            <span class="keyword">if</span> (timeout == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (timeout.isExpired() || timeout.isCancelled()) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            set.add(timeout);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> HashedWheelTimeout <span class="title">pollTimeout</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        HashedWheelTimeout head = <span class="keyword">this</span>.head;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        HashedWheelTimeout next = head.next;</span><br><span class="line">        <span class="keyword">if</span> (next == <span class="keyword">null</span>) &#123;</span><br><span class="line">            tail = <span class="keyword">this</span>.head =  <span class="keyword">null</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">this</span>.head = next;</span><br><span class="line">            next.prev = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// null out prev and next to allow for GC.</span></span><br><span class="line">        head.next = <span class="keyword">null</span>;</span><br><span class="line">        head.prev = <span class="keyword">null</span>;</span><br><span class="line">        head.bucket = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Worker"><a href="#Worker" class="headerlink" title="Worker"></a>Worker</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Worker</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Set&lt;Timeout&gt; unprocessedTimeouts = <span class="keyword">new</span> HashSet&lt;Timeout&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> tick;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Initialize the startTime.</span></span><br><span class="line">				<span class="comment">// 初始化startTime.只有所有任务的的deadline都是想对于这个时间点</span></span><br><span class="line">        startTime = System.nanoTime();</span><br><span class="line">				<span class="comment">// 由于System.nanoTime()可能返回0，甚至负数。并且0是一个标示符，用来判断startTime是否被初始化，所以当startTime=0的时候，重新赋值为1</span></span><br><span class="line">        <span class="keyword">if</span> (startTime == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// We use 0 as an indicator for the uninitialized value here, so make sure it&#x27;s not 0 when initialized.</span></span><br><span class="line">            startTime = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Notify the other threads waiting for the initialization at start().</span></span><br><span class="line">				<span class="comment">// 唤醒阻塞在start()的线程 时间轮线程</span></span><br><span class="line">        startTimeInitialized.countDown();</span><br><span class="line"></span><br><span class="line">				<span class="comment">// 只要时间轮的状态为WORKER_STATE_STARTED，就循环的“转动”tick，循环判断响应格子中的到期任务</span></span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">						<span class="comment">// waitForNextTick方法主要是计算下次tick的时间, 然后sleep到下次tick</span></span><br><span class="line">            <span class="comment">// 返回值就是System.nanoTime() - startTime, 也就是Timer启动后到这次tick, 所过去的时间</span></span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">long</span> deadline = waitForNextTick();</span><br><span class="line">						<span class="comment">// 可能溢出或者被中断的时候会返回负数, 所以小于等于0不管</span></span><br><span class="line">            <span class="keyword">if</span> (deadline &gt; <span class="number">0</span>) &#123;</span><br><span class="line">								<span class="comment">// 获取tick对应的格子索引</span></span><br><span class="line">                <span class="keyword">int</span> idx = (<span class="keyword">int</span>) (tick &amp; mask);</span><br><span class="line">								<span class="comment">// 移除被取消的任务</span></span><br><span class="line">                processCancelledTasks();</span><br><span class="line">                HashedWheelBucket bucket =</span><br><span class="line">                        wheel[idx];</span><br><span class="line">								<span class="comment">// 从任务队列中取出任务加入到对应的格子中</span></span><br><span class="line">                transferTimeoutsToBuckets();</span><br><span class="line">								<span class="comment">// 过期执行格子中的任务</span></span><br><span class="line">                bucket.expireTimeouts(deadline);</span><br><span class="line">                tick++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">while</span> (WORKER_STATE_UPDATER.get(HashedWheelTimer.<span class="keyword">this</span>) == WORKER_STATE_STARTED);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Fill the unprocessedTimeouts so we can return them from stop() method.</span></span><br><span class="line">				<span class="comment">// 这里应该是时间轮停止了，清除所有格子中的任务，并加入到未处理任务列表，以供stop()方法返回</span></span><br><span class="line">        <span class="keyword">for</span> (HashedWheelBucket bucket: wheel) &#123;</span><br><span class="line">            bucket.clearTimeouts(unprocessedTimeouts);</span><br><span class="line">        &#125;</span><br><span class="line">				</span><br><span class="line">				<span class="comment">// 将还没有加入到格子中的待处理定时任务队列中的任务取出，如果是未取消的任务，则加入到未处理任务队列中，以供stop()方法返回</span></span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            HashedWheelTimeout timeout = timeouts.poll();</span><br><span class="line">            <span class="keyword">if</span> (timeout == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (!timeout.isCancelled()) &#123;</span><br><span class="line">                unprocessedTimeouts.add(timeout);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">				<span class="comment">// 处理取消任务</span></span><br><span class="line">        processCancelledTasks();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 将newTimeout()方法中加入到待处理定时任务队列中的任务加入到指定的格子中</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">transferTimeoutsToBuckets</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// transfer only max. 100000 timeouts per tick to prevent a thread to stale the workerThread when it just</span></span><br><span class="line">        <span class="comment">// adds new timeouts in a loop.</span></span><br><span class="line">				<span class="comment">// 每次tick只处理10w个任务，以免阻塞worker线程</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100000</span>; i++) &#123;</span><br><span class="line">            HashedWheelTimeout timeout = timeouts.poll();</span><br><span class="line">            <span class="keyword">if</span> (timeout == <span class="keyword">null</span>) &#123;</span><br><span class="line">								<span class="comment">// 如果没有任务了，直接跳出循环</span></span><br><span class="line">                <span class="comment">// all processed</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">						<span class="comment">// 还没有放入到格子中就取消了，直接略过</span></span><br><span class="line">            <span class="keyword">if</span> (timeout.state() == HashedWheelTimeout.ST_CANCELLED) &#123;</span><br><span class="line">                <span class="comment">// Was cancelled in the meantime.</span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">						<span class="comment">// 计算任务需要经过多少个tick</span></span><br><span class="line">            <span class="keyword">long</span> calculated = timeout.deadline / tickDuration;</span><br><span class="line">						<span class="comment">// 计算任务的轮数</span></span><br><span class="line">            timeout.remainingRounds = (calculated - tick) / wheel.length;</span><br><span class="line"></span><br><span class="line">						<span class="comment">// 如果任务在timeouts队列里面放久了, 以至于已经过了执行时间, 这个时候就使用当前tick, 也就是放到当前bucket, 此方法调用完后就会被执行.</span></span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">long</span> ticks = Math.max(calculated, tick); <span class="comment">// Ensure we don&#x27;t schedule for past.</span></span><br><span class="line">            <span class="keyword">int</span> stopIndex = (<span class="keyword">int</span>) (ticks &amp; mask);</span><br><span class="line"></span><br><span class="line">						<span class="comment">// 将任务加入到响应的格子中</span></span><br><span class="line">            HashedWheelBucket bucket = wheel[stopIndex];</span><br><span class="line">            bucket.addTimeout(timeout);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 将取消的任务取出，并从格子中移除</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">processCancelledTasks</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            HashedWheelTimeout timeout = cancelledTimeouts.poll();</span><br><span class="line">            <span class="keyword">if</span> (timeout == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// all processed</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                timeout.remove();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">                <span class="keyword">if</span> (logger.isWarnEnabled()) &#123;</span><br><span class="line">                    logger.warn(<span class="string">&quot;An exception was thrown while process a cancellation task&quot;</span>, t);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * calculate goal nanoTime from startTime and current tick number,</span></span><br><span class="line"><span class="comment">     * then wait until that goal has been reached.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> Long.MIN_VALUE if received a shutdown request,</span></span><br><span class="line"><span class="comment">     * current time otherwise (with Long.MIN_VALUE changed by +1)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">		<span class="comment">//sleep, 直到下次tick到来, 然后返回该次tick和启动时间之间的时长</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">long</span> <span class="title">waitForNextTick</span><span class="params">()</span> </span>&#123;</span><br><span class="line">				<span class="comment">//下次tick的时间点, 用于计算需要sleep的时间</span></span><br><span class="line">        <span class="keyword">long</span> deadline = tickDuration * (tick + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">						<span class="comment">// 计算需要sleep的时间, 之所以加999999后再除10000000, 是为了保证足够的sleep时间</span></span><br><span class="line">            <span class="comment">// 例如：当deadline - currentTime=2000002的时候，如果不加999999，则只睡了2ms，</span></span><br><span class="line">            <span class="comment">// 而2ms其实是未到达deadline这个时间点的，所有为了使上述情况能sleep足够的时间，加上999999后，会多睡1ms</span></span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">long</span> currentTime = System.nanoTime() - startTime;</span><br><span class="line">            <span class="keyword">long</span> sleepTimeMs = (deadline - currentTime + <span class="number">999999</span>) / <span class="number">1000000</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (sleepTimeMs &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (currentTime == Long.MIN_VALUE) &#123;</span><br><span class="line">										<span class="comment">// 移除问题</span></span><br><span class="line">                    <span class="keyword">return</span> -Long.MAX_VALUE;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">return</span> currentTime;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Check if we run on windows, as if thats the case we will need</span></span><br><span class="line">            <span class="comment">// to round the sleepTime as workaround for a bug that only affect</span></span><br><span class="line">            <span class="comment">// the JVM if it runs on windows.</span></span><br><span class="line">            <span class="comment">//</span></span><br><span class="line">            <span class="comment">// See https://github.com/netty/netty/issues/356</span></span><br><span class="line">            <span class="keyword">if</span> (PlatformDependent.isWindows()) &#123;</span><br><span class="line">                sleepTimeMs = sleepTimeMs / <span class="number">10</span> * <span class="number">10</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(sleepTimeMs);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException ignored) &#123;</span><br><span class="line">								<span class="comment">// 调用HashedWheelTimer.stop()时优雅退出</span></span><br><span class="line">                <span class="keyword">if</span> (WORKER_STATE_UPDATER.get(HashedWheelTimer.<span class="keyword">this</span>) == WORKER_STATE_SHUTDOWN) &#123;</span><br><span class="line">                    <span class="keyword">return</span> Long.MIN_VALUE;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Set&lt;Timeout&gt; <span class="title">unprocessedTimeouts</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Collections.unmodifiableSet(unprocessedTimeouts);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><ul>
<li>关于在timeouts里面的队列里面的任务，还没有来得及执行就到期了的情况（存在吗？存在的话怎么解决的）</li>
</ul>
<p>问题是存在的</p>
<p>在 transferTimeoutsToBuckets 方法有一个处理：</p>
<p>如果任务在timeouts队列里面放久了, 以至于已经过了执行时间, 这个时候就使用当前tick, 也就是放到当前bucket, 此方法调用完后就会被执行.</p>

<div id="gitalk-container"></div>
<script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

		<script>
		var gitalkConfig = {"clientID":"26b8e6758f16d4524e69","clientSecret":"ecfd9e9a439bcb8a4c4fd21f4677fa102c68b352","repo":"beastmouth.github.io","owner":"beastmouth","admin":["beastmouth"],"distractionFreeMode":false,"createIssueManually":true};
	    gitalkConfig.id = md5(location.pathname);
		var gitalk = new Gitalk(gitalkConfig);
	    gitalk.render("gitalk-container");
	    </script>]]></content>
      <categories>
        <category>Netty</category>
      </categories>
  </entry>
  <entry>
    <title>线程的六种状态及其生命周期</title>
    <url>/2021/12/30/%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%85%AD%E7%A7%8D%E7%8A%B6%E6%80%81%E5%8F%8A%E5%85%B6%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/</url>
    <content><![CDATA[<h3 id="线程的六种状态及其生命周期"><a href="#线程的六种状态及其生命周期" class="headerlink" title="线程的六种状态及其生命周期"></a>线程的六种状态及其生命周期</h3><ul>
<li>New：新建线程，未执行start方法</li>
<li>Runnable：可运行/运行中的状态<ul>
<li>正在运行</li>
<li>运行前等待CPU分配资源</li>
<li>已经拿到CPU资源，运行到一半，CPU资源被分配给其他线程，等待分配CPU资源</li>
</ul>
</li>
<li>Blocked：进入synchronized修饰的代码块，锁（monitor）已经被其他线程拿走，线程拿不到锁。<strong>只针对synchronized</strong></li>
<li>Waiting：没有设置timeout参数的object.wait()方法</li>
<li>Timed Waiting：计时等待</li>
<li>Terminated：已终止</li>
</ul>
<p>线程六种状态切换图（其中 阻塞状态：BLOCKED，WAITING，TIME_WAITING）</p>
<p><strong>不遵循下图的两种情况</strong>：</p>
<ul>
<li>Object.wait()状态被唤醒后（很大一部分情况下是获取不到锁的，因为唤醒它的线程需要持有同一把锁，唤醒它的线程完成唤醒动作后可能还没有执行完synchronzed代码块），所以当前线程先进入Blocked状态，抢到锁后再进入Runnable状态</li>
<li>在wait期间发生异常，不用先进入Runnable，直接跳到Terminated状态</li>
</ul>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://bb3e216f.onedrive-cf-index-ng-e34.pages.dev/api/raw?path=/Public/BlogImg/%E7%BA%BF%E7%A8%8B/%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%85%AD%E7%A7%8D%E7%8A%B6%E6%80%81.jpeg"
                      alt="线程的六种状态.jpeg"
                ></p>

<div id="gitalk-container"></div>
<script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

		<script>
		var gitalkConfig = {"clientID":"26b8e6758f16d4524e69","clientSecret":"ecfd9e9a439bcb8a4c4fd21f4677fa102c68b352","repo":"beastmouth.github.io","owner":"beastmouth","admin":["beastmouth"],"distractionFreeMode":false,"createIssueManually":true};
	    gitalkConfig.id = md5(location.pathname);
		var gitalk = new Gitalk(gitalkConfig);
	    gitalk.render("gitalk-container");
	    </script>]]></content>
      <categories>
        <category>Thread</category>
      </categories>
  </entry>
</search>
